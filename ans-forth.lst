  Sat May  7 2016 20:07                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;===============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;-------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The DP register is used for the Forth data stack is values can be accessed
    27                        ; using the direct-page addressing modes. The code uses the same offsets as
    28                        ; would be used with the stack relative instructions (i.e <1, <3, etc.).
    29                        ;
    30                        ; The Y register holds the forth instruction pointer leaving X free for general
    31                        ; use in words. Some words push Y if they need an extra register.
    32                        ;
    33                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    34                        ; CamelForth implementations.
    35                        ;
    36                        ;-------------------------------------------------------------------------------
    37                        
    38                                        pw      132
    39                                        inclist on
    40                                        maclist off
    41                        
    42                                        chip    65816
    43                                        longi   off
    44                                        longa   off
    45                        
    46                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
  Sat May  7 2016 20:07                                                                                                    Page 2


     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        longa   off
    57                                        longi   off
    58                                        endm
    59                        
    60                        ; Puts the processor in native mode. The size of the memory and index register
    61                        ; operations is not controlled by the M & X bits in the status register.
    62                        
    63                        native          macro
    64                                        clc
  Sat May  7 2016 20:07                                                                                                    Page 3


    65                                        xce
    66                                        endm
    67                        
    68                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    69                         
    70                        long_a          macro
    71                                        rep     #M_FLAG
    72                                        longa   on
    73                                        endm
    74                        
    75                        ; Resets the X bit making the index registers 16-bits wide
    76                        
    77                        long_i          macro
    78                                        rep     #X_FLAG
    79                                        longi   on
    80                                        endm
    81                        
    82                        ; Resets the M and X bits making the accumulator, memory accesses and index
    83                        ; registers 16-bits wide.
    84                                        
    85                        long_ai         macro
    86                                        rep     #M_FLAG|X_FLAG
    87                                        longa   on
    88                                        longi   on
    89                                        endm
    90                        
    91                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    92                        
    93                        short_a         macro
    94                                        sep     #M_FLAG
    95                                        longa   off
    96                                        endm
    97                        
    98                        ; Sets the X bit making the index registers 8-bits wide.
    99                        
   100                        short_i         macro
   101                                        sep     #X_FLAG
   102                                        longi   off
   103                                        endm
   104                                        
   105                        ; Sets the M & X bits making the accumulator, memory accesses and index
   106                        ; registers 8-bits wide.
   107                        
   108                        short_ai        macro
   109                                        sep     #M_FLAG|X_FLAG
   110                                        longa   off
   111                                        longi   off
   112                                        endm
    47                                        
    48                        ;===============================================================================
    49                        ; Macros
    50                        ;-------------------------------------------------------------------------------
    51                        
    52                        ; The LINK macro deposits the link section of a word header automatically
    53                        ; linking the new word to the last.
    54                        
    55             00000000   WORDZ           set     0                       ; Word counter
    56             00000000   WORD0           equ     0                       ; Null address for first word
  Sat May  7 2016 20:07                                                                                                    Page 4


    57                        
    58                        LINK            macro   TYPE
    59                                        dw      WORD@<WORDZ>            ; Link
    60                                        db      TYPE                    ; Type
    61                        WORDZ           set     WORDZ+1
    62                        WORD@<WORDZ>:
    63                                        endm
    64                        
    65                        ; Deposits a word header containing the name which is linked back to the
    66                        ; previous word.
    67                        ;
    68                        ; The WDC assembler does not handle string parameters to macros very well,
    69                        ; stopping at the first comma or space in them, so some headers must be
    70                        ; manually constructed.
    71                        
    72             00000000   NORMAL          equ     $00
    73             00000080   IMMEDIATE       equ     $80
    74                        
    75                        HEADER          macro   LEN,NAME,TYPE
    76                                        LINK    TYPE
    77                                        db      LEN,NAME
    78                                        endm
    79                        
    80                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    81                        ; word pointer.
    82                        
    83                        CONTINUE        macro
    84                                        tyx                             ; Copy IP to X
    85                                        iny
    86                                        iny
    87                                        jmp     (0,x)                   ; Then execute word
    88                                        endm
    89                        
    90                        TRAILER         macro
    91                        LAST_WORD       dw      WORD@<WORDZ>
    92                                        endm
    93                        
    94                        ;===============================================================================
    95                        ; Definitions
    96                        ;-------------------------------------------------------------------------------
    97                        
    98             00000016   USER_SIZE       equ     22
    99             00000080   DSTACK_SIZE     equ     128
   100             00000080   RSTACK_SIZE     equ     128
   101                        
   102             00000000   TO_IN_OFFSET    equ     0
   103             00000002   BASE_OFFSET     equ     2
   104             00000004   BLK_OFFSET      equ     4
   105             00000006   DP_OFFSET       equ     6
   106             00000008   LATEST_OFFSET   equ     8
   107             0000000A   SCR_OFFSET      equ     10
   108             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   109             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   110             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   111             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   112             00000014   HP_OFFSET       equ     20
   113                        
   114             00000080   TIB_SIZE        equ     128
  Sat May  7 2016 20:07                                                                                                    Page 5


   115             00000030   PAD_SIZE        equ     48
   116                        
   117                        ;===============================================================================
   118                        ; Data Areas
   119                        ;-------------------------------------------------------------------------------
   120                        
   121             00000000   USER_AREA       equ     $0000                   ; User variable area
   122             00000016   TIB_AREA        equ     USER_AREA+USER_SIZE     ; Terminal Input Buffer
   123             00000096   PAD_AREA        equ     TIB_AREA+TIB_SIZE       ; Scratch pad   
   124             000000C6   PAD_END         equ     PAD_AREA+PAD_SIZE
   125                                        
   126             00000100   DSTACK_START    equ     $0100
   127             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   128                        
   129             00000180   RSTACK_START    equ     DSTACK_END
   130             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   131                        
   132                        ;===============================================================================
   133                        ; Forth Entry Point
   134                        ;-------------------------------------------------------------------------------
   135                        
   136                                        code
   137                                        public  Start
   138                                        extern  NEXT_WORD
   139                        Start:
   140 00:0000: 18 FB                        native                          ; Go to native mode
   141 00:0002: C2 30                        long_ai                         ; And all 16-bit registers
   142 00:0004: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   143 00:0007: 1B                           tcs
   144 00:0008: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   145 00:000B: 5B                           tcd
   146                        
   147 00:000C: A0 xx xx                     ldy     #COLD                   ; Then perform COLD start
   148 00:000F: BB C8 C8 7C                  CONTINUE
       00:0013: 00 00 
   149                        
   150                        COLD:
   151 00:0015: xx xx                        dw      DECIMAL
   152 00:0017: xx xx                        dw      ZERO
   153 00:0019: xx xx                        dw      BLK
   154 00:001B: xx xx                        dw      STORE
   155 00:001D: xx xx                        dw      FALSE
   156 00:001F: xx xx                        dw      STATE
   157 00:0021: xx xx                        dw      STORE
   158 00:0023: xx xx xx xx                  dw      DO_LITERAL,NEXT_WORD
   159 00:0027: xx xx                        dw      DP
   160 00:0029: xx xx                        dw      STORE
   161 00:002B: xx xx xx xx                  dw      DO_LITERAL,LAST_WORD
   162 00:002F: xx xx                        dw      FETCH
   163 00:0031: xx xx                        dw      LATEST
   164 00:0033: xx xx                        dw      STORE
   165 00:0035: xx xx                        dw      CR
   166 00:0037: xx xx                        dw      CR
   167 00:0039: xx xx                        dw      DO_TITLE
   168 00:003B: xx xx                        dw      TYPE
   169 00:003D: xx xx                        dw      CR
   170 00:003F: xx xx                        dw      CR
   171 00:0041: xx xx                        dw      ABORT
  Sat May  7 2016 20:07                                                                                                    Page 6


   172                        
   173                        ;===============================================================================
   174                        ; System/User Variables
   175                        ;-------------------------------------------------------------------------------
   176                        
   177                        ; #TIB ( -- a-addr )
   178                        ;
   179                        ; a-addr is the address of a cell containing the number of characters in the
   180                        ; terminal input buffer.
   181                        
   182 00:0043: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0047: 23 54 49 42 
   183 00:004B: 20 xx xx     HASH_TIB:       jsr     DO_CONSTANT
   184 00:004E: xx xx                        dw      $+2
   185 00:0050: 7E 00                        dw      TIB_SIZE-2
   186                        
   187                        ; >IN ( -- a-addr )
   188                        ;
   189                        ; a-addr is the address of a cell containing the offset in characters from the
   190                        ; start of the input buffer to the start of the parse area.
   191                        
   192 00:0052: xx xx 00 03                  HEADER  3,">IN",NORMAL
       00:0056: 3E 49 4E 
   193 00:0059: 20 xx xx     TO_IN:          jsr     DO_USER
   194 00:005C: 00 00                        dw      TO_IN_OFFSET
   195                        
   196                        ; BASE ( -- a-addr )
   197                        ;
   198                        ; a-addr is the address of a cell containing the current number-conversion
   199                        ; radix {{2...36}}.
   200                        
   201 00:005E: xx xx 00 04                  HEADER  4,"BASE",NORMAL
       00:0062: 42 41 53 45 
   202 00:0066: 20 xx xx     BASE:           jsr     DO_USER
   203 00:0069: 02 00                        dw      BASE_OFFSET
   204                        
   205                        ; BLK ( -- a-addr )
   206                        ;
   207                        ; a-addr is the address of a cell containing zero or the number of the mass-
   208                        ; storage block being interpreted. If BLK contains zero, the input source is
   209                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   210                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   211                        
   212 00:006B: xx xx 00 03                  HEADER  3,"BLK",NORMAL
       00:006F: 42 4C 4B 
   213 00:0072: 20 xx xx     BLK:            jsr     DO_USER
   214 00:0075: 04 00                        dw      BLK_OFFSET
   215                        
   216                        ; (BUFFER)
   217                        
   218 00:0077: 20 xx xx     BUFFER:         jsr     DO_USER
   219 00:007A: 10 00                        dw      BUFFER_OFFSET
   220                        
   221                        ; DP ( -- a-addr )
   222                        ;
   223                        ; Dictionary Pointer
   224                        
   225 00:007C: xx xx 00 02                  HEADER  2,"DP",NORMAL
  Sat May  7 2016 20:07                                                                                                    Page 7


       00:0080: 44 50 
   226 00:0082: 20 xx xx     DP:             jsr     DO_USER
   227 00:0085: 06 00                        dw      DP_OFFSET
   228                        
   229                        ; HP ( -- a-addr )
   230                        ;
   231                        ; Hold Pointer
   232                        
   233 00:0087: 20 xx xx     HP:             jsr     DO_USER
   234 00:008A: 14 00                        dw      HP_OFFSET
   235                        
   236                        ; LATEST ( -- a-addr )
   237                        
   238 00:008C: xx xx 00 06                  HEADER  6,"LATEST",NORMAL
       00:0090: 4C 41 54 45 
       00:0094: 53 54 
   239 00:0096: 20 xx xx     LATEST:         jsr     DO_USER
   240 00:0099: 08 00                        dw      LATEST_OFFSET
   241                        
   242                        ; (LENGTH)
   243                        
   244 00:009B: 20 xx xx     LENGTH:         jsr     DO_USER
   245 00:009E: 12 00                        dw      LENGTH_OFFSET
   246                        
   247                        ; SCR ( -- a-addr )
   248                        ;
   249                        ; a-addr is the address of a cell containing the block number of the block most
   250                        ; recently LISTed.
   251                        
   252 00:00A0: xx xx 00 03                  HEADER  3,"SCR",NORMAL
       00:00A4: 53 43 52 
   253 00:00A7: 20 xx xx     SCR:            jsr     DO_USER
   254 00:00AA: 0A 00                        dw      SCR_OFFSET
   255                        
   256                        ; (SOURCE-ID)
   257                        
   258 00:00AC: 20 xx xx     SOURCEID:       jsr     DO_USER
   259 00:00AF: 0C 00                        dw      SOURCEID_OFFSET
   260                        
   261                        ; STATE ( -- a-addr )
   262                        ;
   263                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   264                        ; is true when in compilation state, false otherwise. The true value in STATE
   265                        ; is non-zero, but is otherwise implementation-defined.
   266                        
   267 00:00B1: xx xx 00 05                  HEADER  5,"STATE",NORMAL
       00:00B5: 53 54 41 54 
       00:00B9: 45 
   268 00:00BA: 20 xx xx     STATE:          jsr     DO_USER
   269 00:00BD: 0E 00                        dw      STATE_OFFSET
   270                        
   271                        ; TIB ( -- c-addr )
   272                        ;
   273                        ; c-addr is the address of the terminal input buffer.
   274                        
   275 00:00BF: xx xx 00 03                  HEADER  3,"TIB",NORMAL
       00:00C3: 54 49 42 
   276 00:00C6: 20 xx xx     TIB:            jsr     DO_CONSTANT
  Sat May  7 2016 20:07                                                                                                    Page 8


   277 00:00C9: 16 00                        dw      TIB_AREA
   278                        
   279                        ;===============================================================================
   280                        ; Constants
   281                        ;-------------------------------------------------------------------------------
   282                        
   283                        ; 0 ( -- 0 )
   284                        ;
   285                        ; Push the constant value zero on the stack
   286                        
   287 00:00CB: xx xx 00 01                  HEADER  1,"0",NORMAL
       00:00CF: 30 
   288                        ZERO:
   289 00:00D0: 7B                           tdc
   290 00:00D1: 3A                           dec     a                       ; Make space on the stack
   291 00:00D2: 3A                           dec     a
   292 00:00D3: 5B                           tcd
   293 00:00D4: 64 01                        stz     <1                      ; And create a zero value
   294 00:00D6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:00DA: 00 00 
   295                        
   296                        ; BL ( -- char )
   297                        ;
   298                        ; char is the character value for a space.
   299                        
   300 00:00DC: xx xx 00 02                  HEADER  2,"BL",NORMAL
       00:00E0: 42 4C 
   301                        BL:
   302 00:00E2: 7B                           tdc
   303 00:00E3: 3A                           dec     a                       ; Make space on the stack
   304 00:00E4: 3A                           dec     a
   305 00:00E5: 5B                           tcd
   306 00:00E6: A9 20 00                     lda     #' '                    ; And save a space value
   307 00:00E9: 85 01                        sta     <1
   308 00:00EB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:00EF: 00 00 
   309                        
   310                        ; FALSE ( -- false )
   311                        ;
   312                        ; Return a false flag.
   313                        
   314 00:00F1: xx xx 00 05                  HEADER  5,"FALSE",NORMAL
       00:00F5: 46 41 4C 53 
       00:00F9: 45 
   315                        FALSE:
   316 00:00FA: 7B                           tdc
   317 00:00FB: 3A                           dec     a                       ; Make space on the stack
   318 00:00FC: 3A                           dec     a
   319 00:00FD: 5B                           tcd
   320 00:00FE: 64 01                        stz     <1                      ; And create a false value
   321 00:0100: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0104: 00 00 
   322                        
   323                        ; TRUE ( -- true )
   324                        ;
   325                        ; Return a true flag, a single-cell value with all bits set.
   326                        
   327 00:0106: xx xx 00 04                  HEADER  4,"TRUE",NORMAL
  Sat May  7 2016 20:07                                                                                                    Page 9


       00:010A: 54 52 55 45 
   328                        TRUE:
   329 00:010E: 7B                           tdc
   330 00:010F: 3A                           dec     a                       ; Make space on the stack
   331 00:0110: 3A                           dec     a
   332 00:0111: 5B                           tcd
   333 00:0112: 64 01                        stz     <1                      ; And create a true value
   334 00:0114: C6 01                        dec     <1
   335 00:0116: BB C8 C8 7C                  CONTINUE                        ; Done
       00:011A: 00 00 
   336                        
   337                        ;===============================================================================
   338                        ; Radix
   339                        ;-------------------------------------------------------------------------------
   340                        
   341                        ; DECIMAL ( -- )
   342                        ;
   343                        ; Set the numeric conversion radix to ten (decimal).
   344                        
   345 00:011C: xx xx 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:0120: 44 45 43 49 
       00:0124: 4D 41 4C 
   346 00:0127: 20 xx xx     DECIMAL:        jsr     DO_COLON
   347 00:012A: xx xx 0A 00                  dw      DO_LITERAL,10
   348 00:012E: xx xx                        dw      BASE
   349 00:0130: xx xx                        dw      STORE
   350 00:0132: xx xx                        dw      EXIT
   351                        
   352                        ; HEX ( -- )
   353                        ;
   354                        ; Set contents of BASE to sixteen.
   355                        
   356 00:0134: xx xx 00 03                  HEADER  3,"HEX",NORMAL
       00:0138: 48 45 58 
   357 00:013B: 20 xx xx     HEX:            jsr     DO_COLON
   358 00:013E: xx xx 10 00                  dw      DO_LITERAL,16
   359 00:0142: xx xx                        dw      BASE
   360 00:0144: xx xx                        dw      STORE
   361 00:0146: xx xx                        dw      EXIT
   362                        
   363                        ;===============================================================================
   364                        ; Memory Operations
   365                        ;-------------------------------------------------------------------------------
   366                        
   367                        ; ! ( x a-addr -- )
   368                        ;
   369                        ; Store x at a-addr.
   370                        
   371 00:0148: xx xx 00 01                  HEADER  1,"!",NORMAL
       00:014C: 21 
   372                        STORE:
   373 00:014D: A5 03                        lda     <3                      ; Fetch data value
   374 00:014F: 92 01                        sta     (1)                     ; .. and store
   375 00:0151: 7B                           tdc                             ; Clean up data stack
   376 00:0152: 1A                           inc     a
   377 00:0153: 1A                           inc     a
   378 00:0154: 1A                           inc     a
   379 00:0155: 1A                           inc     a
  Sat May  7 2016 20:07                                                                                                    Page 10


   380 00:0156: 5B                           tcd
   381 00:0157: BB C8 C8 7C                  CONTINUE                        ; Done
       00:015B: 00 00 
   382                        
   383                        ; +! ( n|u a-addr -- )
   384                        ;
   385                        ; Add n|u to the single-cell number at a-addr.
   386                        
   387 00:015D: xx xx 00 02                  HEADER  2,"+!",NORMAL
       00:0161: 2B 21 
   388                        PLUS_STORE:
   389 00:0163: 18                           clc
   390 00:0164: A5 03                        lda     <3                      ; Fetch data value
   391 00:0166: 72 01                        adc     (1)
   392 00:0168: 92 01                        sta     (1)
   393 00:016A: 7B                           tdc                             ; Clean up data stack
   394 00:016B: 1A                           inc     a
   395 00:016C: 1A                           inc     a
   396 00:016D: 1A                           inc     a
   397 00:016E: 1A                           inc     a
   398 00:016F: 5B                           tcd
   399 00:0170: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0174: 00 00 
   400                        
   401                        ; , ( x -- )
   402                        ;
   403                        ; Reserve one cell of data space and store x in the cell. If the data-space
   404                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   405                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   406                        ; is not aligned prior to execution of ,.
   407                        ;
   408                        ; In this implementation is its defined as:
   409                        ;
   410                        ;   HERE ! 1 CELLS ALLOT
   411                        
   412 00:0176: xx xx 00                     LINK    NORMAL
   413 00:0179: 01 2C                        db      1,","
   414 00:017B: 20 xx xx     COMMA:          jsr     DO_COLON
   415 00:017E: xx xx                        dw      HERE
   416 00:0180: xx xx                        dw      STORE
   417 00:0182: xx xx 01 00                  dw      DO_LITERAL,1
   418 00:0186: xx xx                        dw      CELLS
   419 00:0188: xx xx                        dw      ALLOT
   420 00:018A: xx xx                        dw      EXIT
   421                        
   422                        ; 2! ( x1 x2 a-addr -- )
   423                        ;
   424                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   425                        ; consecutive cell.
   426                        ;
   427                        ; In this implementation is its defined as:
   428                        ;
   429                        ;   SWAP OVER ! CELL+ !.
   430                        
   431 00:018C: xx xx 00 02                  HEADER  2,"2!",NORMAL
       00:0190: 32 21 
   432 00:0192: 20 xx xx     TWO_STORE:      jsr     DO_COLON
   433 00:0195: xx xx                        dw      SWAP
  Sat May  7 2016 20:07                                                                                                    Page 11


   434 00:0197: xx xx                        dw      OVER
   435 00:0199: xx xx                        dw      STORE
   436 00:019B: xx xx                        dw      CELL_PLUS
   437 00:019D: xx xx                        dw      STORE
   438 00:019F: xx xx                        dw      EXIT
   439                        
   440                        ; 2@ ( a-addr -- x1 x2 )
   441                        ;
   442                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   443                        ; the next consecutive cell.
   444                        ;
   445                        ; In this implementation is its defined as:
   446                        ;
   447                        ;   DUP CELL+ @ SWAP @
   448                        
   449 00:01A1: xx xx 00 02                  HEADER  2,"2@",NORMAL
       00:01A5: 32 40 
   450 00:01A7: 20 xx xx     TWO_FETCH:      jsr     DO_COLON
   451 00:01AA: xx xx                        dw      DUP
   452 00:01AC: xx xx                        dw      CELL_PLUS
   453 00:01AE: xx xx                        dw      FETCH
   454 00:01B0: xx xx                        dw      SWAP
   455 00:01B2: xx xx                        dw      FETCH
   456 00:01B4: xx xx                        dw      EXIT
   457                        
   458                        ; @ ( a-addr -- x )
   459                        ;
   460                        ; x is the value stored at a-addr.
   461                        
   462 00:01B6: xx xx 00 01                  HEADER  1,"@",NORMAL
       00:01BA: 40 
   463                        FETCH:
   464 00:01BB: B2 01                        lda     (1)                     ; Fetch from memory
   465 00:01BD: 85 01                        sta     <1                      ; .. and replace top value
   466 00:01BF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:01C3: 00 00 
   467                        
   468                        ; ALLOT ( n -- )
   469                        ;
   470                        ; If n is greater than zero, reserve n address units of data space. If n is
   471                        ; less than zero, release |n| address units of data space. If n is zero, leave
   472                        ; the data-space pointer unchanged.
   473                        ;
   474                        ; In this implementation its is defined as:
   475                        ;
   476                        ;   DP +!
   477                        
   478 00:01C5: xx xx 00 05                  HEADER  5,"ALLOT",NORMAL
       00:01C9: 41 4C 4C 4F 
       00:01CD: 54 
   479 00:01CE: 20 xx xx     ALLOT:          jsr     DO_COLON
   480 00:01D1: xx xx                        dw      DP
   481 00:01D3: xx xx                        dw      PLUS_STORE
   482 00:01D5: xx xx                        dw      EXIT
   483                        
   484                        ; C! ( char c-addr -- )
   485                        ;
   486                        ; Store char at c-addr. When character size is smaller than cell size, only the
  Sat May  7 2016 20:07                                                                                                    Page 12


   487                        ; number of low-order bits corresponding to character size are transferred.
   488                        
   489 00:01D7: xx xx 00 02                  HEADER  2,"C!",NORMAL
       00:01DB: 43 21 
   490                        C_STORE:
   491 00:01DD: A5 03                        lda     <3                      ; Fetch the data value
   492 00:01DF: E2 20                        short_a
   493 00:01E1: 92 01                        sta     (1)                     ; And store it
   494 00:01E3: C2 20                        long_a
   495 00:01E5: 7B                           tdc                             ; Clean up the stack
   496 00:01E6: 1A                           inc     a
   497 00:01E7: 1A                           inc     a
   498 00:01E8: 1A                           inc     a
   499 00:01E9: 1A                           inc     a
   500 00:01EA: 5B                           tcd
   501 00:01EB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:01EF: 00 00 
   502                        
   503                        ; C, ( char -- )
   504                        ;
   505                        ; Reserve space for one character in the data space and store char in the
   506                        ; space. If the data-space pointer is character aligned when C, begins
   507                        ; execution, it will remain character aligned when C, finishes execution.
   508                        ; An ambiguous condition exists if the data-space pointer is not character-
   509                        ; aligned prior to execution of C,
   510                        ;
   511                        ;   HERE C! 1 CHARS ALLOT
   512                        
   513 00:01F1: xx xx 00                     LINK    NORMAL
   514 00:01F4: 02 43 2C                     db      2,"C,"
   515 00:01F7: 20 xx xx     C_COMMA:        jsr     DO_COLON
   516 00:01FA: xx xx                        dw      HERE
   517 00:01FC: xx xx                        dw      C_STORE
   518 00:01FE: xx xx 01 00                  dw      DO_LITERAL,1
   519 00:0202: xx xx                        dw      CHARS
   520 00:0204: xx xx                        dw      ALLOT
   521 00:0206: xx xx                        dw      EXIT
   522                        
   523                        ; C@ ( c-addr -- char )
   524                        ;
   525                        ; Fetch the character stored at c-addr. When the cell size is greater than
   526                        ; character size, the unused high-order bits are all zeroes.
   527                        
   528 00:0208: xx xx 00 02                  HEADER  2,"C@",NORMAL
       00:020C: 43 40 
   529                        C_FETCH:
   530 00:020E: E2 20                        short_a
   531 00:0210: B2 01                        lda     (1)                     ; Fetch the data byte
   532 00:0212: 85 01                        sta     <1                      ; .. and replace stack value
   533 00:0214: 64 02                        stz     <2
   534 00:0216: C2 20                        long_a
   535 00:0218: BB C8 C8 7C                  CONTINUE                        ; Done
       00:021C: 00 00 
   536                        
   537                        ; HERE ( -- addr )
   538                        ;
   539                        ; addr is the data-space pointer.
   540                        
  Sat May  7 2016 20:07                                                                                                    Page 13


   541 00:021E: xx xx 00 04                  HEADER  4,"HERE",NORMAL
       00:0222: 48 45 52 45 
   542 00:0226: 20 xx xx     HERE:           jsr     DO_COLON
   543 00:0229: xx xx                        dw      DP
   544 00:022B: xx xx                        dw      FETCH
   545 00:022D: xx xx                        dw      EXIT
   546                        
   547                        ;===============================================================================
   548                        ; Alignment
   549                        ;-------------------------------------------------------------------------------
   550                        
   551                        ; ALIGN ( -- )
   552                        ;
   553                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   554                        
   555 00:022F: xx xx 00 05                  HEADER  5,"ALIGN",NORMAL
       00:0233: 41 4C 49 47 
       00:0237: 4E 
   556                        ALIGN:
   557 00:0238: BB C8 C8 7C                  CONTINUE                        ; Done
       00:023C: 00 00 
   558                        
   559                        ; ALIGNED ( addr -- a-addr )
   560                        ;
   561                        ; a-addr is the first aligned address greater than or equal to addr.
   562                        
   563 00:023E: xx xx 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:0242: 41 4C 49 47 
       00:0246: 4E 45 44 
   564                        ALIGNED:
   565 00:0249: BB C8 C8 7C                  CONTINUE                        ; Done
       00:024D: 00 00 
   566                        
   567                        ; CELL+ ( a-addr1 -- a-addr2 )
   568                        ;
   569                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   570                        
   571 00:024F: xx xx 00 05                  HEADER  5,"CELL+",NORMAL
       00:0253: 43 45 4C 4C 
       00:0257: 2B 
   572                        CELL_PLUS:
   573 00:0258: E6 01                        inc     <1                      ; Bump the address by two
   574 00:025A: E6 01                        inc     <1
   575 00:025C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0260: 00 00 
   576                        
   577                        ; CELLS ( n1 -- n2 )
   578                        ;
   579                        ; n2 is the size in address units of n1 cells.
   580                        
   581 00:0262: xx xx 00 05                  HEADER  5,"CELLS",NORMAL
       00:0266: 43 45 4C 4C 
       00:026A: 53 
   582                        CELLS:
   583 00:026B: 06 01                        asl     <1                      ; Two bytes per cell
   584 00:026D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0271: 00 00 
   585                        
  Sat May  7 2016 20:07                                                                                                    Page 14


   586                        ; CHAR+ ( c-addr1 -- c-addr2 )
   587                        ;
   588                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   589                        
   590 00:0273: xx xx 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0277: 43 48 41 52 
       00:027B: 2B 
   591                        CHAR_PLUS:
   592 00:027C: E6 01                        inc     <1                      ; Bump the address by one
   593 00:027E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0282: 00 00 
   594                        
   595                        ; CHAR- ( c-addr1 -- c-addr2 )
   596                        ;
   597                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   598                        
   599 00:0284: xx xx 00 05                  HEADER  5,"CHAR-",NORMAL
       00:0288: 43 48 41 52 
       00:028C: 2D 
   600                        CHAR_MINUS:
   601 00:028D: C6 01                        dec     <1
   602 00:028F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0293: 00 00 
   603                        
   604                        ; CHARS ( n1 -- n2 )
   605                        ;
   606                        ; n2 is the size in address units of n1 characters.
   607                        
   608 00:0295: xx xx 00 05                  HEADER  5,"CHARS",NORMAL
       00:0299: 43 48 41 52 
       00:029D: 53 
   609                        CHARS:
   610 00:029E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:02A2: 00 00 
   611                        
   612                        ;===============================================================================
   613                        ; Stack Operations
   614                        ;-------------------------------------------------------------------------------
   615                        
   616                        ; 2DROP ( x1 x2 -- )
   617                        ;
   618                        ; Drop cell pair x1 x2 from the stack.
   619                        
   620 00:02A4: xx xx 00 05                  HEADER  5,"2DROP",NORMAL
       00:02A8: 32 44 52 4F 
       00:02AC: 50 
   621                        TWO_DROP:
   622 00:02AD: 7B                           tdc                             ; Removed two words from stack
   623 00:02AE: 1A                           inc     a
   624 00:02AF: 1A                           inc     a
   625 00:02B0: 1A                           inc     a
   626 00:02B1: 1A                           inc     a
   627 00:02B2: 5B                           tcd
   628 00:02B3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:02B7: 00 00 
   629                        
   630                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   631                        ;
  Sat May  7 2016 20:07                                                                                                    Page 15


   632                        ; Duplicate cell pair x1 x2.
   633                        
   634 00:02B9: xx xx 00 04                  HEADER  4,"2DUP",NORMAL
       00:02BD: 32 44 55 50 
   635                        TWO_DUP:
   636 00:02C1: 7B                           tdc                             ; Make space for new value
   637 00:02C2: 3A                           dec     a
   638 00:02C3: 3A                           dec     a
   639 00:02C4: 3A                           dec     a
   640 00:02C5: 3A                           dec     a
   641 00:02C6: 5B                           tcd
   642 00:02C7: A5 05                        lda     <5                      ; Copy top two values
   643 00:02C9: 85 01                        sta     <1
   644 00:02CB: A5 07                        lda     <7
   645 00:02CD: 85 03                        sta     <3
   646 00:02CF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:02D3: 00 00 
   647                        
   648                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   649                        ;
   650                        ; Copy cell pair x1 x2 to the top of the stack.
   651                        
   652 00:02D5: xx xx 00 05                  HEADER  5,"2OVER",NORMAL
       00:02D9: 32 4F 56 45 
       00:02DD: 52 
   653                        TWO_OVER:
   654 00:02DE: 7B                           tdc                             ; Make space for new value
   655 00:02DF: 3A                           dec     a
   656 00:02E0: 3A                           dec     a
   657 00:02E1: 3A                           dec     a
   658 00:02E2: 3A                           dec     a
   659 00:02E3: 5B                           tcd
   660 00:02E4: A5 09                        lda     <9                      ; Ciopy top two values
   661 00:02E6: 85 01                        sta     <1
   662 00:02E8: A5 0B                        lda     <11
   663 00:02EA: 85 03                        sta     <3
   664 00:02EC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:02F0: 00 00 
   665                        
   666                        ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
   667                        ;
   668                        ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
   669                        ; the top of the stack.
   670                        
   671 00:02F2: xx xx 00 04                  HEADER  4,"2ROT",NORMAL
       00:02F6: 32 52 4F 54 
   672 00:02FA: 20 xx xx     TWO_ROT:        jsr     DO_COLON
   673 00:02FD: A5 0B                        lda     <11                     ; Save x1
   674 00:02FF: 48                           pha
   675 00:0300: A5 09                        lda     <9                      ; Save x2
   676 00:0302: 48                           pha
   677 00:0303: A5 07                        lda     <7                      ; Move x3
   678 00:0305: 85 0B                        sta     <11
   679 00:0307: A5 05                        lda     <5                      ; Move x4
   680 00:0309: 85 09                        sta     <9
   681 00:030B: A5 03                        lda     <3                      ; Move x5
   682 00:030D: 85 07                        sta     <7
   683 00:030F: A5 01                        lda     <1                      ; Move x6
  Sat May  7 2016 20:07                                                                                                    Page 16


   684 00:0311: 85 05                        sta     <5
   685 00:0313: 68                           pla                             ; Restore x2
   686 00:0314: 85 01                        sta     <1
   687 00:0316: 68                           pla                             ; Restore x1
   688 00:0317: 85 03                        sta     <3
   689 00:0319: BB C8 C8 7C                  CONTINUE                        ; Done
       00:031D: 00 00 
   690                        
   691                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   692                        ;
   693                        ; Exchange the top two cell pairs.
   694                        
   695 00:031F: xx xx 00 05                  HEADER  5,"2SWAP",NORMAL
       00:0323: 32 53 57 41 
       00:0327: 50 
   696                        TWO_SWAP:
   697 00:0328: A5 03                        lda     <3                      ; Save x3
   698 00:032A: 48                           pha
   699 00:032B: A5 01                        lda     <1                      ; Save x4
   700 00:032D: 48                           pha
   701 00:032E: A5 07                        lda     <7                      ; Move x1
   702 00:0330: 85 03                        sta     <3
   703 00:0332: A5 05                        lda     <5                      ; Move x2
   704 00:0334: 85 01                        sta     <1
   705 00:0336: 68                           pla                             ; Move x4
   706 00:0337: 85 05                        sta     <5
   707 00:0339: 68                           pla                             ; Move x3
   708 00:033A: 85 07                        sta     <7
   709 00:033C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0340: 00 00 
   710                        
   711                        ; ?DUP ( x -- 0 | x x )
   712                        ;
   713                        ; Duplicate x if it is non-zero.
   714                        
   715 00:0342: xx xx 00 04                  HEADER  4,"?DUP",NORMAL
       00:0346: 3F 44 55 50 
   716                        QUERY_DUP:
   717 00:034A: A5 01                        lda     <1                      ; Fetch top value
   718 00:034C: D0 39                        bne     DUP                     ; Non-zero value?
   719 00:034E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0352: 00 00 
   720                        
   721                        ; DEPTH ( -- +n )
   722                        ;
   723                        ; +n is the number of single-cell values contained in the data stack before +n
   724                        ; was placed on the stack.
   725                        
   726 00:0354: xx xx 00 05                  HEADER  5,"DEPTH",NORMAL
       00:0358: 44 45 50 54 
       00:035C: 48 
   727 00:035D: 20 xx xx     DEPTH:          jsr     DO_COLON
   728 00:0360: xx xx                        dw      AT_DP
   729 00:0362: xx xx 7F 01                  dw      DO_LITERAL,DSTACK_END-1
   730 00:0366: xx xx                        dw      SWAP
   731 00:0368: xx xx                        dw      MINUS
   732 00:036A: xx xx                        dw      TWO_SLASH
   733 00:036C: xx xx                        dw      EXIT
  Sat May  7 2016 20:07                                                                                                    Page 17


   734                        
   735                        ; DROP ( x -- )
   736                        ;
   737                        ; Remove x from the stack.
   738                        
   739 00:036E: xx xx 00 04                  HEADER  4,"DROP",NORMAL
       00:0372: 44 52 4F 50 
   740                        DROP:
   741 00:0376: 7B                           tdc                             ; Drop the top value
   742 00:0377: 1A                           inc     a
   743 00:0378: 1A                           inc     a
   744 00:0379: 5B                           tcd
   745 00:037A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:037E: 00 00 
   746                        
   747                        ; DUP ( x -- x x )
   748                        ;
   749                        ; Duplicate x.
   750                        
   751 00:0380: xx xx 00 03                  HEADER  3,"DUP",NORMAL
       00:0384: 44 55 50 
   752                        DUP:
   753 00:0387: 7B                           tdc
   754 00:0388: 3A                           dec     a
   755 00:0389: 3A                           dec     a
   756 00:038A: 5B                           tcd
   757 00:038B: A5 03                        lda     <3                      ; Fetch top value
   758 00:038D: 85 01                        sta     <1                      ; And make a copy
   759 00:038F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0393: 00 00 
   760                        
   761                        ; NIP ( x1 x2 -- x2 )
   762                        ;
   763                        ; Drop the first item below the top of stack.
   764                        
   765 00:0395: xx xx 00 03                  HEADER  3,"NIP",NORMAL
       00:0399: 4E 49 50 
   766                        NIP:
   767 00:039C: A5 01                        lda     <1                      ; Copy x2 over x1
   768 00:039E: 85 03                        sta     <3
   769 00:03A0: 80 D4                        bra     DROP
   770                        
   771                        ; OVER ( x1 x2 -- x1 x2 x1 )
   772                        ;
   773                        ; Place a copy of x1 on top of the stack.
   774                        
   775 00:03A2: xx xx 00 04                  HEADER  4,"OVER",NORMAL
       00:03A6: 4F 56 45 52 
   776                        OVER:
   777 00:03AA: 7B                           tdc
   778 00:03AB: 3A                           dec     a
   779 00:03AC: 3A                           dec     a
   780 00:03AD: 5B                           tcd
   781 00:03AE: A5 05                        lda     <5                      ; Fetch second value
   782 00:03B0: 85 01                        sta     <1                      ; And make a copy
   783 00:03B2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:03B6: 00 00 
   784                        
  Sat May  7 2016 20:07                                                                                                    Page 18


   785                        ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
   786                        ;
   787                        ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
   788                        ; if there are less than u+2 items on the stack before PICK is executed.
   789                        
   790 00:03B8: xx xx 00 04                  HEADER  4,"PICK",NORMAL
       00:03BC: 50 49 43 4B 
   791                        PICK:
   792 00:03C0: A5 01                        lda     <1                      ; Fetch the index
   793 00:03C2: 0A                           asl     a
   794 00:03C3: AA                           tax
   795 00:03C4: B5 03                        lda     <3,x                    ; Load the target value
   796 00:03C6: 85 01                        sta     <1                      ; .. and save
   797 00:03C8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:03CC: 00 00 
   798                        
   799                        ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   800                        ;
   801                        ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
   802                        ; exists if there are less than u+2 items on the stack before ROLL is executed.
   803                        
   804 00:03CE: xx xx 00 04                  HEADER  4,"ROLL",NORMAL
       00:03D2: 52 4F 4C 4C 
   805                        ROLL:
   806 00:03D6: 06 01                        asl     <1                      ; Convert count to index
   807 00:03D8: A6 01                        ldx     <1
   808 00:03DA: F0 0E                        beq     ROLL_2                  ; Zero? Nothing to do
   809 00:03DC: B5 03                        lda     <3,x                    ; Save the final value
   810 00:03DE: 48                           pha
   811 00:03DF: B5 01        ROLL_1:         lda     <1,x                    ; Move x-1 to x
   812 00:03E1: 95 03                        sta     <3,x
   813 00:03E3: CA                           dex                             ; And repeat
   814 00:03E4: CA                           dex
   815 00:03E5: D0 F8                        bne     ROLL_1
   816 00:03E7: 68                           pla                             ; Recover the new top value
   817 00:03E8: 85 03                        sta     <3
   818 00:03EA: 4C xx xx     ROLL_2:         jmp     DROP                    ; Drop the count
   819                        
   820                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   821                        ;
   822                        ; Rotate the top three stack entries.
   823                        
   824 00:03ED: xx xx 00 03                  HEADER  3,"ROT",NORMAL
       00:03F1: 52 4F 54 
   825                        ROT:
   826 00:03F4: A6 05                        ldx     <5                      ; Save x1
   827 00:03F6: A5 03                        lda     <3                      ; Move x2
   828 00:03F8: 85 05                        sta     <5
   829 00:03FA: A5 01                        lda     <1                      ; Move x3
   830 00:03FC: 85 03                        sta     <3
   831 00:03FE: 86 01                        stx     <1                      ; Restore x1
   832 00:0400: BB C8 C8 7C                  CONTINUE
       00:0404: 00 00 
   833                        
   834                        ; SWAP ( x1 x2 -- x2 x1 )
   835                        ;
   836                        ; Exchange the top two stack items.
   837                        
  Sat May  7 2016 20:07                                                                                                    Page 19


   838 00:0406: xx xx 00 04                  HEADER  4,"SWAP",NORMAL
       00:040A: 53 57 41 50 
   839                        SWAP:
   840 00:040E: A5 01                        lda     <1                      ; Switch top two words
   841 00:0410: A6 03                        ldx     <3
   842 00:0412: 85 03                        sta     <3
   843 00:0414: 86 01                        stx     <1
   844 00:0416: BB C8 C8 7C                  CONTINUE                        ; Done
       00:041A: 00 00 
   845                        
   846                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   847                        ;
   848                        ; Copy the first (top) stack item below the second stack item.
   849                        
   850 00:041C: xx xx 00 04                  HEADER  4,"TUCK",NORMAL
       00:0420: 54 55 43 4B 
   851 00:0424: 20 xx xx     TUCK:           jsr     DO_COLON
   852 00:0427: xx xx                        dw      SWAP
   853 00:0429: xx xx                        dw      OVER
   854 00:042B: xx xx                        dw      EXIT
   855                        
   856                        ;===============================================================================
   857                        ; Return Stack Operations
   858                        ;-------------------------------------------------------------------------------
   859                        
   860                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   861                        ;
   862                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   863                        ; SWAP >R >R.
   864                        
   865 00:042D: xx xx 00 03                  HEADER  3,"2>R",NORMAL
       00:0431: 32 3E 52 
   866                        TWO_TO_R:
   867 00:0434: A5 03                        lda     <3                      ; Transfer x1
   868 00:0436: 48                           pha
   869 00:0437: A5 01                        lda     <1                      ; Transfer x2
   870 00:0439: 48                           pha
   871 00:043A: 7B                           tdc
   872 00:043B: 1A                           inc     a                       ; Clean up data stack
   873 00:043C: 1A                           inc     a
   874 00:043D: 1A                           inc     a
   875 00:043E: 1A                           inc     a
   876 00:043F: 5B                           tcd
   877 00:0440: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0444: 00 00 
   878                        
   879                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   880                        ;
   881                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   882                        ; R> SWAP.
   883                        
   884 00:0446: xx xx 00 03                  HEADER  3,"2R>",NORMAL
       00:044A: 32 52 3E 
   885                        TWO_R_FROM:
   886 00:044D: 7B                           tdc
   887 00:044E: 3A                           dec     a                       ; Make space for values
   888 00:044F: 3A                           dec     a
   889 00:0450: 3A                           dec     a
  Sat May  7 2016 20:07                                                                                                    Page 20


   890 00:0451: 3A                           dec     a
   891 00:0452: 5B                           tcd
   892 00:0453: 68                           pla                             ; Transfer x2
   893 00:0454: 85 01                        sta     <1
   894 00:0456: 68                           pla                             ; Transfer x1
   895 00:0457: 85 03                        sta     <3
   896 00:0459: BB C8 C8 7C                  CONTINUE                        ; Done
       00:045D: 00 00 
   897                        
   898                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   899                        ;
   900                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   901                        ; 2DUP >R >R SWAP.
   902                        
   903 00:045F: xx xx 00 03                  HEADER  3,"2R@",NORMAL
       00:0463: 32 52 40 
   904                        TWO_R_FETCH:
   905 00:0466: 7B                           tdc
   906 00:0467: 3A                           dec     a                       ; Make space for values
   907 00:0468: 3A                           dec     a
   908 00:0469: 3A                           dec     a
   909 00:046A: 3A                           dec     a
   910 00:046B: 5B                           tcd
   911 00:046C: A3 01                        lda     1,s                     ; Transfer x2
   912 00:046E: 85 01                        sta     <1
   913 00:0470: A3 03                        lda     3,s                     ; Transfer x1
   914 00:0472: 85 03                        sta     <3
   915 00:0474: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0478: 00 00 
   916                        
   917                        ; >R ( x -- ) ( R: -- x )
   918                        ;
   919                        ; Move x to the return stack.
   920                        
   921 00:047A: xx xx 00 02                  HEADER  2,">R",NORMAL
       00:047E: 3E 52 
   922                        TO_R:
   923 00:0480: A5 01                        lda     <1                      ; Transfer top value
   924 00:0482: 48                           pha                             ; .. to return stack
   925 00:0483: 7B                           tdc
   926 00:0484: 1A                           inc     a
   927 00:0485: 1A                           inc     a
   928 00:0486: 5B                           tcd
   929 00:0487: BB C8 C8 7C                  CONTINUE                        ; Done
       00:048B: 00 00 
   930                        
   931                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   932                        ;
   933                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   934                        ; exists if the loop control parameters are unavailable.
   935                        
   936 00:048D: xx xx 00 01                  HEADER  1,"I",NORMAL
       00:0491: 49 
   937                        I:
   938 00:0492: 7B                           tdc
   939 00:0493: 3A                           dec     a
   940 00:0494: 3A                           dec     a
   941 00:0495: 5B                           tcd
  Sat May  7 2016 20:07                                                                                                    Page 21


   942 00:0496: A3 01                        lda     1,s
   943 00:0498: 85 01                        sta     <1
   944 00:049A: BB C8 C8 7C                  CONTINUE
       00:049E: 00 00 
   945                        
   946                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   947                        ;
   948                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   949                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   950                        ; unavailable.
   951                        
   952 00:04A0: xx xx 00 01                  HEADER  1,"J",NORMAL
       00:04A4: 4A 
   953                        J:
   954 00:04A5: 7B                           tdc
   955 00:04A6: 3A                           dec     a
   956 00:04A7: 3A                           dec     a
   957 00:04A8: 5B                           tcd
   958 00:04A9: A3 05                        lda     5,s
   959 00:04AB: 85 01                        sta     <1
   960 00:04AD: BB C8 C8 7C                  CONTINUE
       00:04B1: 00 00 
   961                        
   962                        ; R> ( -- x ) ( R: x -- )
   963                        ;
   964                        ; Move x from the return stack to the data stack.
   965                        
   966 00:04B3: xx xx 00 02                  HEADER  2,"R>",NORMAL
       00:04B7: 52 3E 
   967                        R_FROM:
   968 00:04B9: 7B                           tdc
   969 00:04BA: 3A                           dec     a
   970 00:04BB: 3A                           dec     a
   971 00:04BC: 5B                           tcd
   972 00:04BD: 68                           pla                             ; Fetch return stack value
   973 00:04BE: 85 01                        sta     <1
   974 00:04C0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04C4: 00 00 
   975                        
   976                        ; R@ ( -- x ) ( R: x -- x )
   977                        ;
   978                        ; Copy x from the return stack to the data stack.
   979                        
   980 00:04C6: xx xx 00 02                  HEADER  2,"R@",NORMAL
       00:04CA: 52 40 
   981                        R_FETCH:
   982 00:04CC: 7B                           tdc
   983 00:04CD: 3A                           dec     a
   984 00:04CE: 3A                           dec     a
   985 00:04CF: 5B                           tcd
   986 00:04D0: A3 01                        lda     1,s
   987 00:04D2: 85 01                        sta     <1
   988 00:04D4: BB C8 C8 7C                  CONTINUE
       00:04D8: 00 00 
   989                        
   990                        ;===============================================================================
   991                        ; Single Precision Arithmetic
   992                        ;-------------------------------------------------------------------------------
  Sat May  7 2016 20:07                                                                                                    Page 22


   993                        
   994                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   995                        ;
   996                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   997                        ;
   998                        ; In this implementation it is defined as:
   999                        ;
  1000                        ;   M* DROP
  1001                        
  1002 00:04DA: xx xx 00 01                  HEADER  1,"*",NORMAL
       00:04DE: 2A 
  1003 00:04DF: 20 xx xx     STAR:           jsr     DO_COLON
  1004 00:04E2: xx xx                        dw      M_STAR
  1005 00:04E4: xx xx                        dw      DROP
  1006 00:04E6: xx xx                        dw      EXIT
  1007                        
  1008                        ; */ ( n1 n2 n3 -- n4 )
  1009                        ;
  1010                        ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
  1011                        ; by n3 giving the single-cell quotient n4. An ambiguous condition exists if
  1012                        ; n3 is zero or if the quotient n4 lies outside the range of a signed number.
  1013                        ; If d and n3 differ in sign, the implementation-defined result returned will
  1014                        ; be the same as that returned by either the phrase >R M* R> FM/MOD SWAP DROP
  1015                        ; or the phrase >R M* R> SM/REM SWAP DROP.
  1016                        ;
  1017                        ; In this implementation it is defined as:
  1018                        ;
  1019                        ;   >R M* R> FM/MOD SWAP DROP
  1020                        
  1021 00:04E8: xx xx 00 02                  HEADER  2,"*/",NORMAL
       00:04EC: 2A 2F 
  1022 00:04EE: 20 xx xx     STAR_SLASH:     jsr     DO_COLON
  1023 00:04F1: xx xx                        dw      TO_R
  1024 00:04F3: xx xx                        dw      M_STAR
  1025 00:04F5: xx xx                        dw      R_FROM
  1026 00:04F7: xx xx                        dw      FM_SLASH_MOD
  1027 00:04F9: xx xx                        dw      SWAP
  1028 00:04FB: xx xx                        dw      DROP
  1029 00:04FD: xx xx                        dw      EXIT
  1030                        
  1031                        ; */MOD ( n1 n2 n3 -- n4 n5 )
  1032                        ;
  1033                        ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
  1034                        ; by n3 producing the single-cell remainder n4 and the single-cell quotient n5.
  1035                        ; An ambiguous condition exists if n3 is zero, or if the quotient n5 lies
  1036                        ; outside the range of a single-cell signed integer. If d and n3 differ in
  1037                        ; sign, the implementation-defined result returned will be the same as that
  1038                        ; returned by either the phrase >R M* R> FM/MOD or the phrase >R M* R> SM/REM.
  1039                        ;
  1040                        ; In this implementation it is defined as:
  1041                        ;
  1042                        ;   >R M* R> FM/MOD
  1043                        
  1044 00:04FF: xx xx 00 05                  HEADER  5,"*/MOD",NORMAL
       00:0503: 2A 2F 4D 4F 
       00:0507: 44 
  1045 00:0508: 20 xx xx     STAR_SLASH_MOD: jsr     DO_COLON
  1046 00:050B: xx xx                        dw      TO_R
  Sat May  7 2016 20:07                                                                                                    Page 23


  1047 00:050D: xx xx                        dw      M_STAR
  1048 00:050F: xx xx                        dw      R_FROM
  1049 00:0511: xx xx                        dw      FM_SLASH_MOD
  1050 00:0513: xx xx                        dw      EXIT
  1051                        
  1052                        ; + ( n1|u1 n2|u2 -- n3|u3 )
  1053                        ;
  1054                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
  1055                        
  1056 00:0515: xx xx 00 01                  HEADER  1,"+",NORMAL
       00:0519: 2B 
  1057                        PLUS:
  1058 00:051A: 18                           clc                             ; Add top two values
  1059 00:051B: A5 03                        lda     <3
  1060 00:051D: 65 01                        adc     <1
  1061 00:051F: 85 03                        sta     <3                      ; Save result
  1062 00:0521: 7B                           tdc
  1063 00:0522: 1A                           inc     a                       ; Clean up data stack
  1064 00:0523: 1A                           inc     a
  1065 00:0524: 5B                           tcd
  1066 00:0525: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0529: 00 00 
  1067                        
  1068                        ; - ( n1|u1 n2|u2 -- n3|u3 )
  1069                        ;
  1070                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
  1071                        
  1072 00:052B: xx xx 00 01                  HEADER  1,"-",NORMAL
       00:052F: 2D 
  1073                        MINUS:
  1074 00:0530: 38                           sec                             ; Subtract top two values
  1075 00:0531: A5 03                        lda     <3
  1076 00:0533: E5 01                        sbc     <1
  1077 00:0535: 85 03                        sta     <3                      ; Save result
  1078 00:0537: 7B                           tdc
  1079 00:0538: 1A                           inc     a                       ; Clean up data stack
  1080 00:0539: 1A                           inc     a
  1081 00:053A: 5B                           tcd
  1082 00:053B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:053F: 00 00 
  1083                        
  1084                        ; / ( n1 n2 -- n3 )
  1085                        ;
  1086                        ; Divide n1 by n2, giving the single-cell quotient n3. An ambiguous condition
  1087                        ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
  1088                        ; result returned will be the same as that returned by either the phrase >R S>D
  1089                        ; R> FM/MOD SWAP DROP or the phrase >R S>D R> SM/REM SWAP DROP.
  1090                        ;
  1091                        ; In this implementatio it is defined as:
  1092                        ;
  1093                        ;   >R S>D R> FM/MOD SWAP DROP
  1094                        
  1095 00:0541: xx xx 00 01                  HEADER  1,"/",NORMAL
       00:0545: 2F 
  1096 00:0546: 20 xx xx     SLASH:          jsr     DO_COLON
  1097 00:0549: xx xx                        dw      TO_R
  1098 00:054B: xx xx                        dw      S_TO_D
  1099 00:054D: xx xx                        dw      R_FROM
  Sat May  7 2016 20:07                                                                                                    Page 24


  1100 00:054F: xx xx                        dw      FM_SLASH_MOD
  1101 00:0551: xx xx                        dw      SWAP
  1102 00:0553: xx xx                        dw      DROP
  1103 00:0555: xx xx                        dw      EXIT
  1104                        
  1105                        ; /MOD ( n1 n2 -- n3 n4 )
  1106                        ;
  1107                        ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
  1108                        ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
  1109                        ; in sign, the implementation-defined result returned will be the same as that
  1110                        ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
  1111                        ;
  1112                        ; In this implementation it is defined as:
  1113                        ;
  1114                        ;   >R S>D R> FM/MOD
  1115                        
  1116 00:0557: xx xx 00 04                  HEADER  4,"/MOD",NORMAL
       00:055B: 2F 4D 4F 44 
  1117 00:055F: 20 xx xx     SLASH_MOD:      jsr     DO_COLON
  1118 00:0562: xx xx                        dw      TO_R
  1119 00:0564: xx xx                        dw      S_TO_D
  1120 00:0566: xx xx                        dw      R_FROM
  1121 00:0568: xx xx                        dw      FM_SLASH_MOD
  1122 00:056A: xx xx                        dw      EXIT
  1123                        
  1124                        ; 1+ ( n1|u1 -- n2|u2 )
  1125                        ;
  1126                        ; Add one (1) to n1|u1 giving the sum n2|u2.
  1127                        
  1128 00:056C: xx xx 00 02                  HEADER  2,"1+",NORMAL
       00:0570: 31 2B 
  1129                        ONE_PLUS:
  1130 00:0572: E6 01                        inc     <1                      ; Increment top of stack
  1131 00:0574: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0578: 00 00 
  1132                        
  1133                        ; 1- ( n1|u1 -- n2|u2 )
  1134                        ;
  1135                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
  1136                        
  1137 00:057A: xx xx 00 02                  HEADER  2,"1-",NORMAL
       00:057E: 31 2D 
  1138                        ONE_MINUS:
  1139 00:0580: C6 01                        dec     <1                      ; Decrement top of stack
  1140 00:0582: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0586: 00 00 
  1141                        
  1142                        ; 2* ( x1 -- x2 )
  1143                        ;
  1144                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1145                        ; filling the vacated least-significant bit with zero.
  1146                        
  1147 00:0588: xx xx 00 02                  HEADER  2,"2*",NORMAL
       00:058C: 32 2A 
  1148                        TWO_STAR:
  1149 00:058E: 06 01                        asl     <1                      ; Multiply top value by two
  1150 00:0590: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0594: 00 00 
  Sat May  7 2016 20:07                                                                                                    Page 25


  1151                        
  1152                        ; 2/ ( x1 -- x2 )
  1153                        ;
  1154                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1155                        ; leaving the most-significant bit unchanged.
  1156                        
  1157 00:0596: xx xx 00 02                  HEADER  2,"2/",NORMAL
       00:059A: 32 2F 
  1158                        TWO_SLASH:
  1159 00:059C: A5 01                        lda     <1                      ; Load the top value
  1160 00:059E: 2A                           rol     a                       ; Extract the top bit
  1161 00:059F: 66 01                        ror     <1                      ; And shift back into value
  1162 00:05A1: BB C8 C8 7C                  CONTINUE
       00:05A5: 00 00 
  1163                        
  1164                        ; ?NEGATE ( x sign -- x/-x)
  1165                        ;
  1166                        ; If the sign value is negative then negate the value of x to match.
  1167                        ;
  1168                        ; In this implementation it is defined as:
  1169                        ;
  1170                        ;   0< IF NEGATE THEN
  1171                        
  1172 00:05A7: 20 xx xx     QUERY_NEGATE:   jsr     DO_COLON
  1173 00:05AA: xx xx                        dw      ZERO_LESS
  1174 00:05AC: xx xx xx xx                  dw      QUERY_BRANCH,QUERY_NEGATE_1
  1175 00:05B0: xx xx                        dw      NEGATE
  1176 00:05B2: xx xx        QUERY_NEGATE_1: dw      EXIT
  1177                        
  1178                        ; ABS ( n -- u )
  1179                        ;
  1180                        ; u is the absolute value of n.
  1181                        
  1182 00:05B4: xx xx 00 03                  HEADER  3,"ABS",NORMAL
       00:05B8: 41 42 53 
  1183                        ABS:
  1184 00:05BB: A5 01                        lda     <1
  1185 00:05BD: 10 03                        bpl     ABS_1
  1186 00:05BF: 4C xx xx                     jmp     NEGATE
  1187 00:05C2: BB C8 C8 7C  ABS_1:          CONTINUE                        ; Done
       00:05C6: 00 00 
  1188                        
  1189                        ; FM/MOD ( n1 n2 -- n3 n4 )
  1190                        ;
  1191                        ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
  1192                        ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
  1193                        ; in sign, the implementation-defined result returned will be the same as that
  1194                        ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
  1195                        ;
  1196                        ; In this implementation it is defined as:
  1197                        ;
  1198                        ;   DUP >R                      divisor
  1199                        ;   2DUP XOR >R                 sign of quotient
  1200                        ;   >R                          divisor
  1201                        ;   DABS R@ ABS UM/MOD
  1202                        ;   SWAP R> ?NEGATE SWAP        apply sign to remainder
  1203                        ;   R> 0< IF                    if quotient negative,
  1204                        ;       NEGATE
  Sat May  7 2016 20:07                                                                                                    Page 26


  1205                        ;       OVER IF                 if remainder nonzero,
  1206                        ;       R@ ROT - SWAP 1-        adjust rem,quot
  1207                        ;       THEN
  1208                        ;   THEN  R> DROP ;
  1209                        
  1210 00:05C8: xx xx 00 06                  HEADER  6,"FM/MOD",NORMAL
       00:05CC: 46 4D 2F 4D 
       00:05D0: 4F 44 
  1211 00:05D2: 20 xx xx     FM_SLASH_MOD:   jsr     DO_COLON
  1212 00:05D5: xx xx                        dw      DUP
  1213 00:05D7: xx xx                        dw      TO_R
  1214 00:05D9: xx xx                        dw      TWO_DUP
  1215 00:05DB: xx xx                        dw      XOR
  1216 00:05DD: xx xx                        dw      TO_R
  1217 00:05DF: xx xx                        dw      TO_R
  1218 00:05E1: xx xx                        dw      DABS
  1219 00:05E3: xx xx                        dw      R_FETCH
  1220 00:05E5: xx xx                        dw      ABS
  1221 00:05E7: xx xx                        dw      UM_SLASH_MOD
  1222 00:05E9: xx xx                        dw      SWAP
  1223 00:05EB: xx xx                        dw      R_FROM
  1224 00:05ED: xx xx                        dw      QUERY_NEGATE
  1225 00:05EF: xx xx                        dw      SWAP
  1226 00:05F1: xx xx                        dw      R_FROM
  1227 00:05F3: xx xx                        dw      ZERO_LESS
  1228 00:05F5: xx xx xx xx                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1229 00:05F9: xx xx                        dw      NEGATE
  1230 00:05FB: xx xx                        dw      OVER
  1231 00:05FD: xx xx xx xx                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1232 00:0601: xx xx                        dw      R_FETCH
  1233 00:0603: xx xx                        dw      ROT
  1234 00:0605: xx xx                        dw      MINUS
  1235 00:0607: xx xx                        dw      SWAP
  1236 00:0609: xx xx                        dw      ONE_MINUS
  1237 00:060B: xx xx        FM_SLASH_MOD_1: dw      R_FROM
  1238 00:060D: xx xx                        dw      DROP
  1239 00:060F: xx xx                        dw      EXIT
  1240                        
  1241                        ; MAX ( n1 n2 -- n3 )
  1242                        ;
  1243                        ; n3 is the greater of n1 and n2.
  1244                        
  1245 00:0611: xx xx 00 03                  HEADER  3,"MAX",NORMAL
       00:0615: 4D 41 58 
  1246 00:0618: 20 xx xx     MAX:            jsr     DO_COLON
  1247 00:061B: xx xx                        dw      TWO_DUP
  1248 00:061D: xx xx                        dw      LESS
  1249 00:061F: xx xx xx xx                  dw      QUERY_BRANCH,MAX_1
  1250 00:0623: xx xx                        dw      SWAP
  1251 00:0625: xx xx        MAX_1:          dw      DROP
  1252 00:0627: xx xx                        dw      EXIT
  1253                        
  1254                        ; MIN ( n1 n2 -- n3 )
  1255                        ;
  1256                        ; n3 is the lesser of n1 and n2.
  1257                        
  1258 00:0629: xx xx 00 03                  HEADER  3,"MIN",NORMAL
       00:062D: 4D 49 4E 
  Sat May  7 2016 20:07                                                                                                    Page 27


  1259 00:0630: 20 xx xx     MIN:            jsr     DO_COLON
  1260 00:0633: xx xx                        dw      TWO_DUP
  1261 00:0635: xx xx                        dw      GREATER
  1262 00:0637: xx xx xx xx                  dw      QUERY_BRANCH,MIN_1
  1263 00:063B: xx xx                        dw      SWAP
  1264 00:063D: xx xx        MIN_1:          dw      DROP
  1265 00:063F: xx xx                        dw      EXIT
  1266                        
  1267                        ; MOD ( n1 n2 -- n3 )
  1268                        ;
  1269                        ; Divide n1 by n2, giving the single-cell remainder n3. An ambiguous condition
  1270                        ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
  1271                        ; result returned will be the same as that returned by either the phrase >R S>D
  1272                        ; R> FM/MOD DROP or the phrase >R S>D R> SM/REM DROP.
  1273                        ;
  1274                        ; In this implementation it is defined as:
  1275                        ;
  1276                        ;   >R S>D R> FM/MOD DROP
  1277                        
  1278 00:0641: xx xx 00 03                  HEADER  3,"MOD",NORMAL
       00:0645: 4D 4F 44 
  1279 00:0648: 20 xx xx     MOD:            jsr     DO_COLON
  1280 00:064B: xx xx                        dw      TO_R
  1281 00:064D: xx xx                        dw      S_TO_D
  1282 00:064F: xx xx                        dw      R_FROM
  1283 00:0651: xx xx                        dw      FM_SLASH_MOD
  1284 00:0653: xx xx                        dw      DROP
  1285 00:0655: xx xx                        dw      EXIT
  1286                        
  1287                        ; NEGATE ( n1 -- n2 )
  1288                        ;
  1289                        ; Negate n1, giving its arithmetic inverse n2.
  1290                        
  1291 00:0657: xx xx 00 06                  HEADER  6,"NEGATE",NORMAL
       00:065B: 4E 45 47 41 
       00:065F: 54 45 
  1292                        NEGATE:
  1293 00:0661: 38                           sec                             ; Negate the top of stack
  1294 00:0662: A9 00 00                     lda     #0
  1295 00:0665: E5 01                        sbc     <1
  1296 00:0667: 85 01                        sta     <1
  1297 00:0669: BB C8 C8 7C                  CONTINUE                        ; Done
       00:066D: 00 00 
  1298                        
  1299                        ; UMAX ( x1 x2 -- x3 )
  1300                        ;
  1301                        ; x3 is the greater of x1 and x2.
  1302                        
  1303 00:066F: xx xx 00 04                  HEADER  4,"UMAX",NORMAL
       00:0673: 55 4D 41 58 
  1304                        UMAX:
  1305 00:0677: A5 01                        lda     <1                      ; Compare the top values
  1306 00:0679: C5 03                        cmp     <3
  1307 00:067B: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1308 00:067D: 4C xx xx                     jmp     DROP                    ; No, x1 is
  1309 00:0680: 4C xx xx     UMAX_EXIT:      jmp     NIP
  1310                        
  1311                        ; UMIN ( x1 x2 -- x3 )
  Sat May  7 2016 20:07                                                                                                    Page 28


  1312                        ;
  1313                        ; x3 is the lesser of x1 and x2.
  1314                        
  1315 00:0683: xx xx 00 04                  HEADER  4,"UMIN",NORMAL
       00:0687: 55 4D 49 4E 
  1316                        UMIN:
  1317 00:068B: A5 01                        lda     <1                      ; Compare the top values
  1318 00:068D: C5 03                        cmp     <3
  1319 00:068F: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1320 00:0691: 4C xx xx                     jmp     DROP                    ; No, x1 is
  1321 00:0694: 4C xx xx     UMIN_EXIT:      jmp     NIP
  1322                        
  1323                        ;===============================================================================
  1324                        ; Double Precision Arithmetic
  1325                        ;-------------------------------------------------------------------------------
  1326                        
  1327                        ; ?DNEGATE ( d1 sign -- d1/-d1 )
  1328                        ;
  1329                        ; If sign is less than zero than negate d1 otherwise leave it unchanged.
  1330                        
  1331 00:0697: 20 xx xx     QUERY_DNEGATE:  jsr     DO_COLON
  1332 00:069A: xx xx                        dw      ZERO_LESS
  1333 00:069C: xx xx xx xx                  dw      QUERY_BRANCH,QUERY_DNEG_1
  1334 00:06A0: xx xx                        dw      DNEGATE
  1335 00:06A2: xx xx        QUERY_DNEG_1:   dw      EXIT
  1336                        
  1337                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1338                        ;
  1339                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1340                        
  1341 00:06A4: xx xx 00 02                  HEADER  2,"D+",NORMAL
       00:06A8: 44 2B 
  1342                        D_PLUS:
  1343 00:06AA: 18                           clc
  1344 00:06AB: A5 07                        lda     <7                      ; Add low words
  1345 00:06AD: 65 03                        adc     <3
  1346 00:06AF: 85 07                        sta     <7
  1347 00:06B1: A5 05                        lda     <5                      ; Then the high words
  1348 00:06B3: 65 01                        adc     <1
  1349 00:06B5: 85 05                        sta     <5
  1350 00:06B7: 7B                           tdc                             ; Drop top double
  1351 00:06B8: 1A                           inc     a
  1352 00:06B9: 1A                           inc     a
  1353 00:06BA: 1A                           inc     a
  1354 00:06BB: 1A                           inc     a
  1355 00:06BC: 5B                           tcd
  1356 00:06BD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06C1: 00 00 
  1357                        
  1358                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1359                        ;
  1360                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1361                        
  1362 00:06C3: xx xx 00 02                  HEADER  2,"D-",NORMAL
       00:06C7: 44 2D 
  1363                        D_MINUS:
  1364 00:06C9: 38                           sec
  1365 00:06CA: A5 07                        lda     <7                      ; Subtract low words
  Sat May  7 2016 20:07                                                                                                    Page 29


  1366 00:06CC: E5 03                        sbc     <3
  1367 00:06CE: 85 07                        sta     <7
  1368 00:06D0: A5 05                        lda     <5                      ; Then the high words
  1369 00:06D2: E5 01                        sbc     <1
  1370 00:06D4: 85 05                        sta     <5
  1371 00:06D6: 7B                           tdc                             ; Drop top double
  1372 00:06D7: 1A                           inc     a
  1373 00:06D8: 1A                           inc     a
  1374 00:06D9: 1A                           inc     a
  1375 00:06DA: 1A                           inc     a
  1376 00:06DB: 5B                           tcd
  1377 00:06DC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06E0: 00 00 
  1378                        
  1379                        ; D0< ( d -- flag )
  1380                        ;
  1381                        ; flag is true if and only if d is less than zero.
  1382                        
  1383 00:06E2: xx xx 00 03                  HEADER  3,"D0<",NORMAL
       00:06E6: 44 30 3C 
  1384                        D_ZERO_LESS:
  1385 00:06E9: A6 01                        ldx     <1                      ; Fetch sign
  1386 00:06EB: 7B                           tdc                             ; Drop a word
  1387 00:06EC: 1A                           inc     a
  1388 00:06ED: 1A                           inc     a
  1389 00:06EE: 5B                           tcd
  1390 00:06EF: 64 01                        stz     <1                      ; Assume false
  1391 00:06F1: 8A                           txa
  1392 00:06F2: 10 02                        bpl     D_ZERO_LESS_1
  1393 00:06F4: C6 01                        dec     <1
  1394 00:06F6: BB C8 C8 7C  D_ZERO_LESS_1:  CONTINUE
       00:06FA: 00 00 
  1395                        
  1396                        ; D0= ( d -- flag )
  1397                        ;
  1398                        ; flag is true if and only if d is equal to zero.
  1399                        
  1400 00:06FC: xx xx 00 03                  HEADER  3,"D0=",NORMAL
       00:0700: 44 30 3D 
  1401                        D_ZERO_EQUAL:
  1402 00:0703: A6 01                        ldx     <1                      ; Fetch sign
  1403 00:0705: 7B                           tdc                             ; Drop a word
  1404 00:0706: 1A                           inc     a
  1405 00:0707: 1A                           inc     a
  1406 00:0708: 5B                           tcd
  1407 00:0709: 64 01                        stz     <1                      ; Assume false
  1408 00:070B: 8A                           txa
  1409 00:070C: D0 02                        bne     D_ZERO_EQUAL_1
  1410 00:070E: C6 01                        dec     <1
  1411 00:0710: BB C8 C8 7C  D_ZERO_EQUAL_1: CONTINUE
       00:0714: 00 00 
  1412                        
  1413                        ; D2* ( xd1 -- xd2 )
  1414                        ;
  1415                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1416                        ; filling the vacated least-significant bit with zero.
  1417                        
  1418 00:0716: xx xx 00 03                  HEADER  3,"D2*",NORMAL
  Sat May  7 2016 20:07                                                                                                    Page 30


       00:071A: 44 32 2A 
  1419                        D_TWO_STAR:
  1420 00:071D: 06 03                        asl     <3
  1421 00:071F: 26 01                        rol     <1
  1422 00:0721: BB C8 C8 7C                  CONTINUE
       00:0725: 00 00 
  1423                        
  1424                        ; D2/ ( xd1 -- xd2 )
  1425                        ;
  1426                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1427                        ; leaving the most-significant bit unchanged.
  1428                        
  1429 00:0727: xx xx 00 03                  HEADER  3,"D2/",NORMAL
       00:072B: 44 32 2F 
  1430                        D_TWO_SLASH:
  1431 00:072E: A5 01                        lda     <1
  1432 00:0730: 2A                           rol     a
  1433 00:0731: 66 01                        ror     <1
  1434 00:0733: 66 03                        ror     <3
  1435 00:0735: BB C8 C8 7C                  CONTINUE
       00:0739: 00 00 
  1436                        
  1437                        ; D< ( d1 d2 -- flag )
  1438                        ;
  1439                        ; flag is true if and only if d1 is less than d2.
  1440                        
  1441 00:073B: xx xx 00 02                  HEADER  2,"D<",NORMAL
       00:073F: 44 3C 
  1442 00:0741: 20 xx xx     D_LESS:         jsr     DO_COLON
  1443 00:0744: xx xx                        dw      D_MINUS
  1444 00:0746: xx xx                        dw      D_ZERO_LESS
  1445 00:0748: xx xx                        dw      EXIT
  1446                        
  1447                        ; D= ( d1 d2 -- flag )
  1448                        ;
  1449                        ; flag is true if and only if d1 is bit-for-bit the same as d2.
  1450                        
  1451 00:074A: xx xx 00 02                  HEADER  2,"D=",NORMAL
       00:074E: 44 3D 
  1452 00:0750: 20 xx xx     D_EQUAL:        jsr     DO_COLON
  1453 00:0753: xx xx                        dw      D_MINUS
  1454 00:0755: xx xx                        dw      D_ZERO_EQUAL
  1455 00:0757: xx xx                        dw      EXIT
  1456                        
  1457                        ; DABS ( d -- ud )
  1458                        ;
  1459                        ; ud is the absolute value of d.
  1460                        
  1461 00:0759: xx xx 00 04                  HEADER  4,"DABS",NORMAL
       00:075D: 44 41 42 53 
  1462                        DABS:
  1463 00:0761: A5 01                        lda     <1
  1464 00:0763: 10 03                        bpl     DABS_1
  1465 00:0765: 4C xx xx                     jmp     DNEGATE
  1466 00:0768: BB C8 C8 7C  DABS_1:         CONTINUE
       00:076C: 00 00 
  1467                        
  1468                        ; DMAX ( d1 d2 -- d3 )
  Sat May  7 2016 20:07                                                                                                    Page 31


  1469                        ;
  1470                        ; d3 is the greater of d1 and d2.
  1471                        
  1472 00:076E: xx xx 00 04                  HEADER  4,"DMAX",NORMAL
       00:0772: 44 4D 41 58 
  1473 00:0776: 20 xx xx     DMAX:           jsr     DO_COLON
  1474 00:0779: xx xx                        dw      TWO_OVER
  1475 00:077B: xx xx                        dw      TWO_OVER
  1476 00:077D: xx xx                        dw      D_LESS
  1477 00:077F: xx xx xx xx                  dw      QUERY_BRANCH,DMAX_1
  1478 00:0783: xx xx                        dw      TWO_SWAP
  1479 00:0785: xx xx        DMAX_1:         dw      TWO_DROP
  1480 00:0787: xx xx                        dw      EXIT
  1481                        
  1482                        ; DMIN ( d1 d2 -- d3 )
  1483                        ;
  1484                        ; d3 is the lesser of d1 and d2.
  1485                        
  1486 00:0789: xx xx 00 04                  HEADER  4,"DMIN",NORMAL
       00:078D: 44 4D 49 4E 
  1487 00:0791: 20 xx xx     DMIN:           jsr     DO_COLON
  1488 00:0794: xx xx                        dw      TWO_OVER
  1489 00:0796: xx xx                        dw      TWO_OVER
  1490 00:0798: xx xx                        dw      D_LESS
  1491 00:079A: xx xx                        dw      INVERT
  1492 00:079C: xx xx xx xx                  dw      QUERY_BRANCH,DMIN_1
  1493 00:07A0: xx xx                        dw      TWO_SWAP
  1494 00:07A2: xx xx        DMIN_1:         dw      TWO_DROP
  1495 00:07A4: xx xx                        dw      EXIT
  1496                        
  1497                        ; DNEGATE ( d1 -- d2 )
  1498                        ;
  1499                        ; d2 is the negation of d1.
  1500                        
  1501 00:07A6: xx xx 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:07AA: 44 4E 45 47 
       00:07AE: 41 54 45 
  1502                        DNEGATE:
  1503 00:07B1: 38                           sec
  1504 00:07B2: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1505 00:07B5: E5 03                        sbc     <3
  1506 00:07B7: 85 03                        sta     <3
  1507 00:07B9: A9 00 00                     lda     #0                      ; Then the high word
  1508 00:07BC: E5 01                        sbc     <1
  1509 00:07BE: 85 01                        sta     <1
  1510 00:07C0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07C4: 00 00 
  1511                        
  1512                        ;===============================================================================
  1513                        ; Mixed Arithmetic
  1514                        ;-------------------------------------------------------------------------------
  1515                        
  1516                        ; D>S ( d -- n )
  1517                        ;
  1518                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1519                        ; range of a signed single-cell number.
  1520                        
  1521 00:07C6: xx xx 00 03                  HEADER  3,"D>S",NORMAL
  Sat May  7 2016 20:07                                                                                                    Page 32


       00:07CA: 44 3E 53 
  1522                        D_TO_S:
  1523 00:07CD: 7B                           tdc
  1524 00:07CE: 1A                           inc     a                       ; Drop the high word
  1525 00:07CF: 1A                           inc     a
  1526 00:07D0: 5B                           tcd
  1527 00:07D1: BB C8 C8 7C                  CONTINUE
       00:07D5: 00 00 
  1528                        
  1529                        ; M* ( n1 n2 -- d )
  1530                        ;
  1531                        ; d is the signed product of n1 times n2.
  1532                        ;
  1533                        ; In this implementation it is defined as:
  1534                        ;
  1535                        ;   2DUP XOR >R                 carries sign of the result
  1536                        ;   SWAP ABS SWAP ABS UM*
  1537                        ;   R> ?DNEGATE
  1538                        
  1539 00:07D7: xx xx 00 02                  HEADER  2,"M*",NORMAL
       00:07DB: 4D 2A 
  1540 00:07DD: 20 xx xx     M_STAR:         jsr     DO_COLON
  1541 00:07E0: xx xx                        dw      TWO_DUP
  1542 00:07E2: xx xx                        dw      XOR
  1543 00:07E4: xx xx                        dw      TO_R
  1544 00:07E6: xx xx                        dw      SWAP
  1545 00:07E8: xx xx                        dw      ABS
  1546 00:07EA: xx xx                        dw      SWAP
  1547 00:07EC: xx xx                        dw      ABS
  1548 00:07EE: xx xx                        dw      UM_STAR
  1549 00:07F0: xx xx                        dw      R_FROM
  1550 00:07F2: xx xx                        dw      QUERY_DNEGATE
  1551 00:07F4: xx xx                        dw      EXIT
  1552                        
  1553                        ; M*/ ( d1 n1 +n2 -- d2 )
  1554                        ;
  1555                        ; Multiply d1 by n1 producing the triple-cell intermediate result t. Divide t
  1556                        ; by +n2 giving the double-cell quotient d2. An ambiguous condition exists if
  1557                        ; +n2 is zero or negative, or the quotient lies outside of the range of a
  1558                        ; double-precision signed integer.
  1559                        
  1560                        
  1561                        
  1562                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1563                        ;
  1564                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1565                        
  1566 00:07F6: xx xx 00 02                  HEADER  2,"M+",NORMAL
       00:07FA: 4D 2B 
  1567                        M_PLUS:
  1568 00:07FC: 18                           clc
  1569 00:07FD: A5 01                        lda     <1
  1570 00:07FF: 65 05                        adc     <5
  1571 00:0801: 85 05                        sta     <5
  1572 00:0803: 90 02                        bcc     $+4
  1573 00:0805: E6 03                        inc     <3
  1574 00:0807: 7B                           tdc
  1575 00:0808: 1A                           inc     a
  Sat May  7 2016 20:07                                                                                                    Page 33


  1576 00:0809: 1A                           inc     a
  1577 00:080A: 5B                           tcd
  1578 00:080B: BB C8 C8 7C                  CONTINUE
       00:080F: 00 00 
  1579                        
  1580                        ; S>D ( n -- d )
  1581                        ;
  1582                        ; Convert the number n to the double-cell number d with the same numerical
  1583                        ; value.
  1584                        
  1585 00:0811: xx xx 00 03                  HEADER  3,"S>D",NORMAL
       00:0815: 53 3E 44 
  1586                        S_TO_D:
  1587 00:0818: 7B                           tdc
  1588 00:0819: 3A                           dec     a                       ; Assume n is positive
  1589 00:081A: 3A                           dec     a
  1590 00:081B: 5B                           tcd
  1591 00:081C: 64 01                        stz     <1                      ; .. push a zero value
  1592 00:081E: A5 03                        lda     <3                      ; Test the number
  1593 00:0820: 10 02                        bpl     S_TO_D_1
  1594 00:0822: C6 01                        dec     <1                      ; Make top -1 if negative
  1595 00:0824: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0828: 00 00 
  1596                        
  1597                        ; SM/REM ( d1 n1 -- n2 n3 )
  1598                        ;
  1599                        ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
  1600                        ; Input and output stack arguments are signed. An ambiguous condition exists if
  1601                        ; n1 is zero or if the quotient lies outside the range of a single-cell signed
  1602                        ; integer.
  1603                        ;
  1604                        ; In this implementation it is defined as:
  1605                        ;
  1606                        ;   2DUP XOR >R                 sign of quotient
  1607                        ;   OVER >R                     sign of remainder
  1608                        ;   ABS >R DABS R> UM/MOD
  1609                        ;   SWAP R> ?NEGATE
  1610                        ;   SWAP R> ?NEGATE ;
  1611                        
  1612 00:082A: xx xx 00 06                  HEADER  6,"SM/REM",NORMAL
       00:082E: 53 4D 2F 52 
       00:0832: 45 4D 
  1613 00:0834: 20 xx xx     SM_SLASH_REM:   jsr     DO_COLON
  1614 00:0837: xx xx                        dw      TWO_DUP
  1615 00:0839: xx xx                        dw      XOR
  1616 00:083B: xx xx                        dw      TO_R
  1617 00:083D: xx xx                        dw      OVER
  1618 00:083F: xx xx                        dw      TO_R
  1619 00:0841: xx xx                        dw      ABS
  1620 00:0843: xx xx                        dw      TO_R
  1621 00:0845: xx xx                        dw      DABS
  1622 00:0847: xx xx                        dw      R_FROM
  1623 00:0849: xx xx                        dw      UM_SLASH_MOD
  1624 00:084B: xx xx                        dw      SWAP
  1625 00:084D: xx xx                        dw      R_FROM
  1626 00:084F: xx xx                        dw      QUERY_NEGATE
  1627 00:0851: xx xx                        dw      SWAP
  1628 00:0853: xx xx                        dw      R_FROM
  Sat May  7 2016 20:07                                                                                                    Page 34


  1629 00:0855: xx xx                        dw      QUERY_NEGATE
  1630 00:0857: xx xx                        dw      EXIT
  1631                        
  1632                        ; UD* ( ud1 d2 -- ud3)
  1633                        ;
  1634                        ; 32*16->32 multiply
  1635                        ;
  1636                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1637                        
  1638 00:0859: xx xx 00 03                  HEADER  3,"UD*",NORMAL
       00:085D: 55 44 2A 
  1639 00:0860: 20 xx xx     UD_STAR:        jsr     DO_COLON
  1640 00:0863: xx xx                        dw      DUP
  1641 00:0865: xx xx                        dw      TO_R
  1642 00:0867: xx xx                        dw      UM_STAR
  1643 00:0869: xx xx                        dw      DROP
  1644 00:086B: xx xx                        dw      SWAP
  1645 00:086D: xx xx                        dw      R_FROM
  1646 00:086F: xx xx                        dw      UM_STAR
  1647 00:0871: xx xx                        dw      ROT
  1648 00:0873: xx xx                        dw      PLUS
  1649 00:0875: xx xx                        dw      EXIT
  1650                        
  1651                        ; UM* ( u1 u2 -- ud )
  1652                        ;
  1653                        ; Multiply u1 by u2, giving the unsigned double-cell product ud. All values and
  1654                        ; arithmetic are unsigned.
  1655                        
  1656 00:0877: xx xx 00 03                  HEADER  3,"UM*",NORMAL
       00:087B: 55 4D 2A 
  1657                        UM_STAR:
  1658 00:087E: A5 01                        lda     <1                      ; Fetch multiplier
  1659 00:0880: 48                           pha
  1660 00:0881: 64 01                        stz     <1                      ; Clear the result
  1661 00:0883: A2 10 00                     ldx     #16
  1662 00:0886: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1663 00:0888: 4A                           lsr     a
  1664 00:0889: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1665 00:088B: A3 01                        lda     1,s                     ; Fetch multiplicand
  1666 00:088D: 18                           clc
  1667 00:088E: 65 01                        adc     <1
  1668 00:0890: 85 01                        sta     <1
  1669 00:0892: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1670 00:0894: 66 03                        ror     <3
  1671 00:0896: CA                           dex
  1672 00:0897: D0 ED                        bne     UM_STAR_1
  1673 00:0899: 68                           pla
  1674 00:089A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:089E: 00 00 
  1675                        
  1676                        ; UM/MOD ( ud u1 -- u2 u3 )
  1677                        ;
  1678                        ; Divide ud by u1, giving the quotient u3 and the remainder u2. All values and
  1679                        ; arithmetic are unsigned. An ambiguous condition exists if u1 is zero or if the
  1680                        ; quotient lies outside the range of a single-cell unsigned integer.
  1681                        
  1682 00:08A0: xx xx 00 06                  HEADER  6,"UM/MOD",NORMAL
       00:08A4: 55 4D 2F 4D 
  Sat May  7 2016 20:07                                                                                                    Page 35


       00:08A8: 4F 44 
  1683                        UM_SLASH_MOD:
  1684 00:08AA: 38                           sec                             ; Check for overflow
  1685 00:08AB: A5 03                        lda     <3
  1686 00:08AD: E5 01                        sbc     <1
  1687 00:08AF: B0 1A                        bcs     UM_SLASH_MOD_3
  1688                        
  1689 00:08B1: A2 11 00                     ldx     #17
  1690 00:08B4: 26 05        UM_SLASH_MOD_1: rol     <5                      ; Rotate dividend lo
  1691 00:08B6: CA                           dex
  1692 00:08B7: F0 19                        beq     UM_SLASH_MOD_4
  1693 00:08B9: 26 03                        rol     <3
  1694 00:08BB: B0 06                        bcs     UM_SLASH_MOD_2          ; Carry set dividend > divisor
  1695                        
  1696 00:08BD: A5 03                        lda     <3                      ; Is dividend < divisor?
  1697 00:08BF: C5 01                        cmp     <1
  1698 00:08C1: 90 F1                        bcc     UM_SLASH_MOD_1          ; Yes, shift in 0
  1699                        
  1700 00:08C3: A5 03        UM_SLASH_MOD_2: lda     <3                      ; Reduce dividend
  1701 00:08C5: E5 01                        sbc     <1
  1702 00:08C7: 85 03                        sta     <3
  1703 00:08C9: 80 E9                        bra     UM_SLASH_MOD_1          ; Shift in 1
  1704                        
  1705 00:08CB: A9 FF FF     UM_SLASH_MOD_3: lda     #$ffff                  ; Overflowed set results
  1706 00:08CE: 85 03                        sta     <3
  1707 00:08D0: 85 05                        sta     <5
  1708 00:08D2: 7B           UM_SLASH_MOD_4: tdc                             ; Drop top word
  1709 00:08D3: 1A                           inc     a
  1710 00:08D4: 1A                           inc     a
  1711 00:08D5: 5B                           tcd
  1712 00:08D6: 4C xx xx                     jmp     SWAP                    ; Swap quotient and remainder
  1713                        
  1714                        ;===============================================================================
  1715                        ; Comparisons
  1716                        ;-------------------------------------------------------------------------------
  1717                        
  1718                        ; 0< ( n -- flag )
  1719                        ;
  1720                        ; flag is true if and only if n is less than zero.
  1721                        
  1722 00:08D9: xx xx 00 02                  HEADER  2,"0<",NORMAL
       00:08DD: 30 3C 
  1723                        ZERO_LESS:
  1724 00:08DF: A5 01                        lda     <1                      ; Test top of stack
  1725 00:08E1: 64 01                        stz     <1                      ; Assume false result
  1726 00:08E3: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1727 00:08E5: C6 01                        dec     <1                      ; Yes, make true result
  1728 00:08E7: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:08EB: 00 00 
  1729                        
  1730                        ; 0<> ( x -- flag )
  1731                        ;
  1732                        ; flag is true if and only if x is not equal to zero.
  1733                        
  1734 00:08ED: xx xx 00 03                  HEADER  3,"0<>",NORMAL
       00:08F1: 30 3C 3E 
  1735                        ZERO_NOT_EQUAL:
  1736 00:08F4: A5 01                        lda     <1                      ; Test top of stack
  Sat May  7 2016 20:07                                                                                                    Page 36


  1737 00:08F6: 64 01                        stz     <1                      ; Assume false result
  1738 00:08F8: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1739 00:08FA: C6 01                        dec     <1                      ; Yes, make true result
  1740 00:08FC: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0900: 00 00 
  1741                        
  1742                        ; 0= ( x -- flag )
  1743                        ;
  1744                        ; flag is true if and only if x is equal to zero.
  1745                        
  1746 00:0902: xx xx 00 02                  HEADER  2,"0=",NORMAL
       00:0906: 30 3D 
  1747                        ZERO_EQUAL:
  1748 00:0908: A5 01                        lda     <1                      ; Test top of stack
  1749 00:090A: 64 01                        stz     <1                      ; Assume false result
  1750 00:090C: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1751 00:090E: C6 01                        dec     <1                      ; Yes, make true result
  1752 00:0910: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0914: 00 00 
  1753                        
  1754                        ; 0> ( n -- flag )
  1755                        ;
  1756                        ; flag is true if and only if n is greater than zero.
  1757                        
  1758 00:0916: xx xx 00 02                  HEADER  2,"0>",NORMAL
       00:091A: 30 3E 
  1759                        ZERO_GREATER:
  1760 00:091C: A5 01                        lda     <1                      ; Test top of stack
  1761 00:091E: 64 01                        stz     <1                      ; Assume false result
  1762 00:0920: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1763 00:0922: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1764 00:0924: C6 01                        dec     <1                      ; Yes, make true result
  1765 00:0926: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:092A: 00 00 
  1766                        
  1767                        ; < ( n1 n2 -- flag )
  1768                        ;
  1769                        ; flag is true if and only if n1 is less than n2.
  1770                        
  1771 00:092C: xx xx 00 01                  HEADER  1,"<",NORMAL
       00:0930: 3C 
  1772 00:0931: 20 xx xx     LESS:           jsr     DO_COLON
  1773 00:0934: xx xx                        dw      SWAP
  1774 00:0936: xx xx                        dw      GREATER
  1775 00:0938: xx xx                        dw      EXIT
  1776                        
  1777                        ; <> ( x1 x2 -- flag )
  1778                        ;
  1779                        ; flag is true if and only if x1 is not bit-for-bit the same as x2.
  1780                        
  1781 00:093A: xx xx 00 02                  HEADER  2,"<>",NORMAL
       00:093E: 3C 3E 
  1782                        NOT_EQUAL:
  1783 00:0940: A6 01                        ldx     <1                      ; Pull x2 from stack
  1784 00:0942: 7B                           tdc
  1785 00:0943: 1A                           inc     a
  1786 00:0944: 1A                           inc     a
  1787 00:0945: 5B                           tcd
  Sat May  7 2016 20:07                                                                                                    Page 37


  1788 00:0946: E4 01                        cpx     <1                      ; Compare with x1
  1789 00:0948: 64 01                        stz     <1                      ; Assume equal
  1790 00:094A: F0 02                        beq     NE_EXIT                 ; Test flags
  1791 00:094C: C6 01                        dec     <1                      ; Make result true
  1792 00:094E: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0952: 00 00 
  1793                        
  1794                        ; = ( x1 x2 -- flag )
  1795                        ;
  1796                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1797                        
  1798 00:0954: xx xx 00 01                  HEADER  1,"=",NORMAL
       00:0958: 3D 
  1799                        EQUAL:
  1800 00:0959: A6 01                        ldx     <1                      ; Pull x2 from stack
  1801 00:095B: 7B                           tdc
  1802 00:095C: 1A                           inc     a
  1803 00:095D: 1A                           inc     a
  1804 00:095E: 5B                           tcd
  1805 00:095F: E4 01                        cpx     <1                      ; Compare with x1
  1806 00:0961: 64 01                        stz     <1                      ; Assume not equal
  1807 00:0963: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1808 00:0965: C6 01                        dec     <1                      ; Make result true
  1809 00:0967: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:096B: 00 00 
  1810                        
  1811                        ; > ( n1 n2 -- flag )
  1812                        ;
  1813                        ; flag is true if and only if n1 is greater than n2.
  1814                        
  1815 00:096D: xx xx 00 01                  HEADER  1,">",NORMAL
       00:0971: 3E 
  1816                        GREATER:
  1817 00:0972: A6 01                        ldx     <1                      ; Pull x2 from stack
  1818 00:0974: 7B                           tdc
  1819 00:0975: 1A                           inc     a
  1820 00:0976: 1A                           inc     a
  1821 00:0977: 5B                           tcd
  1822 00:0978: 8A                           txa
  1823 00:0979: 38                           sec                             ; Compare with x1
  1824 00:097A: E5 01                        sbc     <1
  1825 00:097C: 64 01                        stz     <1                      ; Assume false result
  1826 00:097E: 50 03                        bvc     GREATER_1
  1827 00:0980: 49 00 80                     eor     #$8000
  1828 00:0983: 10 02        GREATER_1:      bpl     GREATER_2               ; V == 1 && N == 1
  1829 00:0985: C6 01                        dec     <1
  1830 00:0987: BB C8 C8 7C  GREATER_2:      CONTINUE
       00:098B: 00 00 
  1831                        
  1832                        ; U< ( u1 u2 -- flag )
  1833                        ;
  1834                        ; flag is true if and only if u1 is less than u2.
  1835                        
  1836 00:098D: xx xx 00 02                  HEADER  2,"U<",NORMAL
       00:0991: 55 3C 
  1837                        U_LESS:
  1838 00:0993: A6 01                        ldx     <1                      ; Pull x2
  1839 00:0995: 7B                           tdc                             ; Drop from stack
  Sat May  7 2016 20:07                                                                                                    Page 38


  1840 00:0996: 1A                           inc     a
  1841 00:0997: 1A                           inc     a
  1842 00:0998: 5B                           tcd
  1843 00:0999: E4 01                        cpx     <1                      ; Compare with x1
  1844 00:099B: 64 01                        stz     <1                      ; Assume false
  1845 00:099D: F0 04                        beq     U_LESS_1                ; Equal
  1846 00:099F: 90 02                        bcc     U_LESS_1                ; Less
  1847 00:09A1: C6 01                        dec     <1
  1848 00:09A3: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:09A7: 00 00 
  1849                        
  1850                        ; U> ( u1 u2 -- flag )
  1851                        ;
  1852                        ; flag is true if and only if u1 is greater than u2.
  1853                        
  1854 00:09A9: xx xx 00 02                  HEADER  2,"U>",NORMAL
       00:09AD: 55 3E 
  1855 00:09AF: 20 xx xx     U_GREATER:      jsr     DO_COLON
  1856 00:09B2: xx xx                        dw      SWAP
  1857 00:09B4: xx xx                        dw      U_LESS
  1858 00:09B6: xx xx                        dw      EXIT
  1859                        
  1860                        ;===============================================================================
  1861                        ; Logical Operations
  1862                        ;-------------------------------------------------------------------------------
  1863                        
  1864                        ; AND ( x1 x2 -- x3 )
  1865                        ;
  1866                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1867                        
  1868 00:09B8: xx xx 00 03                  HEADER  3,"AND",NORMAL
       00:09BC: 41 4E 44 
  1869                        AND:
  1870 00:09BF: A5 01                        lda     <1
  1871 00:09C1: 25 03                        and     <3
  1872 00:09C3: 85 03                        sta     <3
  1873 00:09C5: 7B                           tdc
  1874 00:09C6: 1A                           inc     a
  1875 00:09C7: 1A                           inc     a
  1876 00:09C8: 5B                           tcd
  1877 00:09C9: BB C8 C8 7C                  CONTINUE
       00:09CD: 00 00 
  1878                        
  1879                        ; INVERT ( x1 -- x2 )
  1880                        ;
  1881                        ; Invert all bits of x1, giving its logical inverse x2.
  1882                        
  1883 00:09CF: xx xx 00 06                  HEADER  6,"INVERT",NORMAL
       00:09D3: 49 4E 56 45 
       00:09D7: 52 54 
  1884                        INVERT:
  1885 00:09D9: A5 01                        lda     <1                      ; Fetch top value
  1886 00:09DB: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1887 00:09DE: 85 01                        sta     <1                      ; .. and write back
  1888 00:09E0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:09E4: 00 00 
  1889                        
  1890                        ; LSHIFT ( x1 u -- x2 )
  Sat May  7 2016 20:07                                                                                                    Page 39


  1891                        ;
  1892                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1893                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1894                        ; exists if u is greater than or equal to the number of bits in a cell.
  1895                        
  1896 00:09E6: xx xx 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:09EA: 4C 53 48 49 
       00:09EE: 46 54 
  1897                        LSHIFT:
  1898 00:09F0: A6 01                        ldx     <1                      ; Pull bit count
  1899 00:09F2: 08                           php
  1900 00:09F3: 7B                           tdc
  1901 00:09F4: 1A                           inc     a                       ; .. from the stack
  1902 00:09F5: 1A                           inc     a
  1903 00:09F6: 5B                           tcd
  1904 00:09F7: 28                           plp
  1905 00:09F8: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1906 00:09FA: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1907 00:09FD: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1908 00:09FF: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1909 00:0A01: CA                           dex                             ; Update count
  1910 00:0A02: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1911 00:0A04: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0A08: 00 00 
  1912 00:0A0A: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1913 00:0A0C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A10: 00 00 
  1914                        
  1915                        ; OR ( x1 x2 -- x3 )
  1916                        ;
  1917                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1918                        
  1919 00:0A12: xx xx 00 02                  HEADER  2,"OR",NORMAL
       00:0A16: 4F 52 
  1920                        OR:
  1921 00:0A18: A5 01                        lda     <1
  1922 00:0A1A: 05 03                        ora     <3
  1923 00:0A1C: 85 03                        sta     <3
  1924 00:0A1E: 7B                           tdc
  1925 00:0A1F: 1A                           inc     a
  1926 00:0A20: 1A                           inc     a
  1927 00:0A21: 5B                           tcd
  1928 00:0A22: BB C8 C8 7C                  CONTINUE
       00:0A26: 00 00 
  1929                        
  1930                        ; RSHIFT ( x1 u -- x2 )
  1931                        ;
  1932                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1933                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1934                        ; exists if u is greater than or equal to the number of bits in a cell.
  1935                        
  1936 00:0A28: xx xx 00 06                  HEADER  6,"RSHIFT",NORMAL
       00:0A2C: 52 53 48 49 
       00:0A30: 46 54 
  1937                        RSHIFT:
  1938 00:0A32: A6 01                        ldx     <1                      ; Pull bit count
  1939 00:0A34: 08                           php
  1940 00:0A35: 7B                           tdc
  Sat May  7 2016 20:07                                                                                                    Page 40


  1941 00:0A36: 1A                           inc     a                       ; .. from the stack
  1942 00:0A37: 1A                           inc     a
  1943 00:0A38: 5B                           tcd
  1944 00:0A39: 28                           plp
  1945 00:0A3A: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1946 00:0A3C: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1947 00:0A3F: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1948 00:0A41: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1949 00:0A43: CA                           dex                             ; Update count
  1950 00:0A44: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1951 00:0A46: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0A4A: 00 00 
  1952 00:0A4C: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1953 00:0A4E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A52: 00 00 
  1954                        
  1955                        ; XOR ( x1 x2 -- x3 )
  1956                        ;
  1957                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1958                        
  1959 00:0A54: xx xx 00 03                  HEADER  3,"XOR",NORMAL
       00:0A58: 58 4F 52 
  1960                        XOR:
  1961 00:0A5B: A5 01                        lda     <1
  1962 00:0A5D: 45 03                        eor     <3
  1963 00:0A5F: 85 03                        sta     <3
  1964 00:0A61: 7B                           tdc
  1965 00:0A62: 1A                           inc     a
  1966 00:0A63: 1A                           inc     a
  1967 00:0A64: 5B                           tcd
  1968 00:0A65: BB C8 C8 7C                  CONTINUE
       00:0A69: 00 00 
  1969                        
  1970                        ;===============================================================================
  1971                        ; Control Words
  1972                        ;-------------------------------------------------------------------------------
  1973                        
  1974                        ; ?ABORT
  1975                        ;
  1976                        ;   ROT IF TYPE ABORT THEN 2DROP ;
  1977                        
  1978 00:0A6B: 20 xx xx     QUERY_ABORT:    jsr     DO_COLON
  1979 00:0A6E: xx xx                        dw      ROT
  1980 00:0A70: xx xx xx xx                  dw      QUERY_BRANCH,QUERY_ABORT_1
  1981 00:0A74: xx xx                        dw      TYPE
  1982 00:0A76: xx xx                        dw      ABORT
  1983 00:0A78: xx xx        QUERY_ABORT_1:  dw      TWO_DROP
  1984 00:0A7A: xx xx                        dw      EXIT
  1985                        
  1986                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1987                        ;
  1988                        ; Empty the data stack and perform the function of QUIT, which includes
  1989                        ; emptying the return stack, without displaying a message.
  1990                        
  1991 00:0A7C: xx xx 00 05                  HEADER  5,"ABORT",NORMAL
       00:0A80: 41 42 4F 52 
       00:0A84: 54 
  1992 00:0A85: 20 xx xx     ABORT:          jsr     DO_COLON
  Sat May  7 2016 20:07                                                                                                    Page 41


  1993 00:0A88: xx xx                        dw      DO_ABORT
  1994 00:0A8A: xx xx                        dw      QUIT
  1995                        
  1996                        DO_ABORT:
  1997 00:0A8C: A9 7F 01                     lda     #DSTACK_END-1
  1998 00:0A8F: 5B                           tcd
  1999 00:0A90: BB C8 C8 7C                  CONTINUE
       00:0A94: 00 00 
  2000                        
  2001                        ; (BUILD) ( dtc-addr -- )
  2002                        ;
  2003                        ; Adds a jump the to exection function for the new word.
  2004                        
  2005                        ;               HEADER  7,"(BUILD)",NORMAL
  2006 00:0A96: 20 xx xx     BUILD:          jsr     DO_COLON
  2007 00:0A99: xx xx 20 00                  dw      DO_LITERAL,$20
  2008 00:0A9D: xx xx                        dw      C_COMMA
  2009 00:0A9F: xx xx                        dw      COMMA
  2010 00:0AA1: xx xx                        dw      EXIT
  2011                        
  2012                        ; CREATE ( -- )
  2013                        ;
  2014                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2015                        ; definition for name with the execution semantics defined below. If the data-
  2016                        ; space pointer is not aligned, reserve enough data space to align it. The new
  2017                        ; data-space pointer defines names data field. CREATE does not allocate data
  2018                        ; space in names data field.
  2019                        
  2020 00:0AA3: xx xx 00 06                  HEADER  6,"CREATE",NORMAL
       00:0AA7: 43 52 45 41 
       00:0AAB: 54 45 
  2021 00:0AAD: 20 xx xx     CREATE:         jsr     DO_COLON
  2022 00:0AB0: xx xx                        dw      LATEST
  2023 00:0AB2: xx xx                        dw      FETCH
  2024 00:0AB4: xx xx                        dw      COMMA
  2025 00:0AB6: xx xx                        dw      ZERO
  2026 00:0AB8: xx xx                        dw      C_COMMA
  2027 00:0ABA: xx xx                        dw      HERE
  2028 00:0ABC: xx xx                        dw      LATEST
  2029 00:0ABE: xx xx                        dw      STORE
  2030 00:0AC0: xx xx                        dw      BL
  2031 00:0AC2: xx xx                        dw      WORD
  2032 00:0AC4: xx xx                        dw      C_FETCH
  2033 00:0AC6: xx xx                        dw      ONE_PLUS
  2034 00:0AC8: xx xx                        dw      ALLOT
  2035 00:0ACA: xx xx                        dw      EXIT
  2036                        
  2037                        ; EXECUTE ( i*x xt -- j*x )
  2038                        ;
  2039                        ; Remove xt from the stack and perform the semantics identified by it. Other
  2040                        ; stack effects are due to the word EXECUTEd.
  2041                        
  2042 00:0ACC: xx xx 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0AD0: 45 58 45 43 
       00:0AD4: 55 54 45 
  2043                        EXECUTE:
  2044 00:0AD7: A6 01                        ldx     <1
  2045 00:0AD9: 7B                           tdc
  Sat May  7 2016 20:07                                                                                                    Page 42


  2046 00:0ADA: 1A                           inc     a
  2047 00:0ADB: 1A                           inc     a
  2048 00:0ADC: 5B                           tcd
  2049 00:0ADD: CA                           dex
  2050 00:0ADE: DA                           phx
  2051 00:0ADF: 60                           rts
  2052                        
  2053                        ; EXIT ( -- ) ( R: nest-sys -- )
  2054                        ;
  2055                        ; Return control to the calling definition specified by nest-sys. Before
  2056                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  2057                        ; parameters by executing UNLOOP.
  2058                        
  2059 00:0AE0: xx xx 00 04                  HEADER  4,"EXIT",NORMAL
       00:0AE4: 45 58 49 54 
  2060                        EXIT:
  2061 00:0AE8: 7A                           ply
  2062 00:0AE9: BB C8 C8 7C                  CONTINUE
       00:0AED: 00 00 
  2063                        
  2064                        ; QUIT ( -- ) ( R: i*x -- )
  2065                        ;
  2066                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  2067                        ; user input device the input source, and enter interpretation state. Do not
  2068                        ; display a message. Repeat the following:
  2069                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  2070                        ;   and interpret.
  2071                        ;  Display the implementation-defined system prompt if in interpretation state,
  2072                        ;   all processing has been completed, and no ambiguous condition exists.
  2073                        ;
  2074                        ; In this implementation it is defined as:
  2075                        ;
  2076                        ;   DO_QUIT 0 STATE !
  2077                        ;   0 (SOURCE-ID) !
  2078                        ;   BEGIN
  2079                        ;     REFILL
  2080                        ;     WHILE SOURCE EVALUATE
  2081                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  2082                        ;   AGAIN ;
  2083                        
  2084 00:0AEF: xx xx 00 04                  HEADER  4,"QUIT",NORMAL
       00:0AF3: 51 55 49 54 
  2085 00:0AF7: 20 xx xx     QUIT:           jsr     DO_COLON
  2086 00:0AFA: xx xx                        dw      DO_QUIT
  2087 00:0AFC: xx xx                        dw      ZERO
  2088 00:0AFE: xx xx                        dw      STATE
  2089 00:0B00: xx xx                        dw      STORE
  2090 00:0B02: xx xx                        dw      ZERO
  2091 00:0B04: xx xx                        dw      SOURCEID
  2092 00:0B06: xx xx                        dw      STORE
  2093 00:0B08: xx xx        QUIT_1:         dw      REFILL
  2094 00:0B0A: xx xx xx xx                  dw      QUERY_BRANCH,QUIT_2
  2095 00:0B0E: xx xx                        dw      INTERPRET
  2096 00:0B10: xx xx        QUIT_2:         dw      STATE
  2097 00:0B12: xx xx                        dw      FETCH
  2098 00:0B14: xx xx                        dw      ZERO_EQUAL
  2099 00:0B16: xx xx xx xx                  dw      QUERY_BRANCH,QUIT_3
  2100 00:0B1A: xx xx                        dw      DO_S_QUOTE
  Sat May  7 2016 20:07                                                                                                    Page 43


  2101 00:0B1C: 02 4F 6B                     db      2,"Ok"
  2102 00:0B1F: xx xx                        dw      TYPE
  2103 00:0B21: xx xx                        dw      CR
  2104 00:0B23: xx xx xx xx  QUIT_3:         dw      BRANCH,QUIT_1
  2105                        
  2106                        DO_QUIT:
  2107 00:0B27: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  2108 00:0B2A: 1B                           tcs
  2109 00:0B2B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0B2F: 00 00 
  2110                        
  2111                        ;===============================================================================
  2112                        ; Parser & Interpreter
  2113                        ;-------------------------------------------------------------------------------
  2114                        
  2115                        ; ?NUMBER
  2116                        ;
  2117                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  2118                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  2119                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  2120                        ;   ELSE 2DROP NIP R>
  2121                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  2122                        ;   THEN ;
  2123                        
  2124 00:0B31: xx xx 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0B35: 3F 4E 55 4D 
       00:0B39: 42 45 52 
  2125 00:0B3C: 20 xx xx     QUERY_NUMBER:   jsr     DO_COLON
  2126 00:0B3F: xx xx                        dw      DUP
  2127 00:0B41: xx xx                        dw      ZERO
  2128 00:0B43: xx xx                        dw      ZERO
  2129 00:0B45: xx xx                        dw      ROT
  2130 00:0B47: xx xx                        dw      COUNT
  2131 00:0B49: xx xx                        dw      QUERY_SIGN
  2132 00:0B4B: xx xx                        dw      TO_R
  2133 00:0B4D: xx xx                        dw      TO_NUMBER
  2134 00:0B4F: xx xx xx xx                  dw      QUERY_BRANCH,QNUM_1
  2135 00:0B53: xx xx                        dw      R_FROM
  2136 00:0B55: xx xx                        dw      TWO_DROP
  2137 00:0B57: xx xx                        dw      TWO_DROP
  2138 00:0B59: xx xx                        dw      ZERO
  2139 00:0B5B: xx xx xx xx                  dw      BRANCH,QNUM_3
  2140 00:0B5F: xx xx        QNUM_1:         dw      TWO_DROP
  2141 00:0B61: xx xx                        dw      NIP
  2142 00:0B63: xx xx                        dw      R_FROM
  2143 00:0B65: xx xx xx xx                  dw      QUERY_BRANCH,QNUM_2
  2144 00:0B69: xx xx                        dw      NEGATE
  2145 00:0B6B: xx xx FF FF  QNUM_2:         dw      DO_LITERAL,-1
  2146 00:0B6F: xx xx        QNUM_3:         dw      EXIT
  2147                        
  2148                        ; ?SIGN ( c-addr n -- adr' n' f )
  2149                        ;
  2150                        ;   OVER C@                 -- adr n c
  2151                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  2152                        ;   DUP IF 1+               -- +=0, -=+2
  2153                        ;       >R 1 /STRING R>     -- adr' n' f
  2154                        ;   THEN ;
  2155                        
  Sat May  7 2016 20:07                                                                                                    Page 44


  2156 00:0B71: xx xx 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0B75: 3F 53 49 47 
       00:0B79: 4E 
  2157 00:0B7A: 20 xx xx     QUERY_SIGN:     jsr     DO_COLON
  2158 00:0B7D: xx xx                        dw      OVER
  2159 00:0B7F: xx xx                        dw      C_FETCH
  2160 00:0B81: xx xx 2C 00                  dw      DO_LITERAL,','
  2161 00:0B85: xx xx                        dw      MINUS
  2162 00:0B87: xx xx                        dw      DUP
  2163 00:0B89: xx xx                        dw      ABS
  2164 00:0B8B: xx xx 01 00                  dw      DO_LITERAL,1
  2165 00:0B8F: xx xx                        dw      EQUAL
  2166 00:0B91: xx xx                        dw      AND
  2167 00:0B93: xx xx                        dw      DUP
  2168 00:0B95: xx xx xx xx                  dw      QUERY_BRANCH,QSIGN_1
  2169 00:0B99: xx xx                        dw      ONE_PLUS
  2170 00:0B9B: xx xx                        dw      TO_R
  2171 00:0B9D: xx xx 01 00                  dw      DO_LITERAL,1
  2172 00:0BA1: xx xx                        dw      SLASH_STRING
  2173 00:0BA3: xx xx                        dw      R_FROM
  2174 00:0BA5: xx xx        QSIGN_1:        dw      EXIT
  2175                        
  2176                        ; >COUNTED ( c-addr n -- )
  2177                        ;
  2178                        ;   2DUP C! CHAR+ SWAP CMOVE
  2179                        
  2180 00:0BA7: 20 xx xx     TO_COUNTED:     jsr     DO_COLON
  2181 00:0BAA: xx xx                        dw      TWO_DUP
  2182 00:0BAC: xx xx                        dw      C_STORE
  2183 00:0BAE: xx xx                        dw      CHAR_PLUS
  2184 00:0BB0: xx xx                        dw      SWAP
  2185 00:0BB2: xx xx                        dw      CMOVE
  2186 00:0BB4: xx xx                        dw      EXIT
  2187                        
  2188                        ; >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
  2189                        ;
  2190                        ; ud2 is the unsigned result of converting the characters within the string
  2191                        ; specified by c-addr1 u1 into digits, using the number in BASE, and adding
  2192                        ; each into ud1 after multiplying ud1 by the number in BASE. Conversion
  2193                        ; continues left-to-right until a character that is not convertible, including
  2194                        ; any + or -, is encountered or the string is entirely converted. c-addr2
  2195                        ; is the location of the first unconverted character or the first character
  2196                        ; past the end of the string if the string was entirely converted. u2 is the
  2197                        ; number of unconverted characters in the string. An ambiguous condition exists
  2198                        ; if ud2 overflows during the conversion.
  2199                        ;
  2200                        ; In this implementation its is defined as:
  2201                        ;
  2202                        ;   BEGIN
  2203                        ;   DUP WHILE
  2204                        ;       OVER C@ DIGIT?
  2205                        ;       0= IF DROP EXIT THEN
  2206                        ;       >R 2SWAP BASE @ UD*
  2207                        ;       R> M+ 2SWAP
  2208                        ;       1 /STRING
  2209                        ;   REPEAT ;
  2210                        
  2211 00:0BB6: xx xx 00 07                  HEADER  7,">NUMBER",NORMAL
  Sat May  7 2016 20:07                                                                                                    Page 45


       00:0BBA: 3E 4E 55 4D 
       00:0BBE: 42 45 52 
  2212 00:0BC1: 20 xx xx     TO_NUMBER:      jsr     DO_COLON
  2213 00:0BC4: xx xx        TO_NUM_1:       dw      DUP
  2214 00:0BC6: xx xx xx xx                  dw      QUERY_BRANCH,TO_NUM_3
  2215 00:0BCA: xx xx                        dw      OVER
  2216 00:0BCC: xx xx                        dw      C_FETCH
  2217 00:0BCE: xx xx                        dw      DIGIT_QUERY
  2218 00:0BD0: xx xx                        dw      ZERO_EQUAL
  2219 00:0BD2: xx xx xx xx                  dw      QUERY_BRANCH,TO_NUM_2
  2220 00:0BD6: xx xx                        dw      DROP
  2221 00:0BD8: xx xx                        dw      EXIT
  2222 00:0BDA: xx xx        TO_NUM_2:       dw      TO_R
  2223 00:0BDC: xx xx                        dw      TWO_SWAP
  2224 00:0BDE: xx xx                        dw      BASE
  2225 00:0BE0: xx xx                        dw      FETCH
  2226 00:0BE2: xx xx                        dw      UD_STAR
  2227 00:0BE4: xx xx                        dw      R_FROM
  2228 00:0BE6: xx xx                        dw      M_PLUS
  2229 00:0BE8: xx xx                        dw      TWO_SWAP
  2230 00:0BEA: xx xx 01 00                  dw      DO_LITERAL,1
  2231 00:0BEE: xx xx                        dw      SLASH_STRING
  2232 00:0BF0: xx xx xx xx                  dw      BRANCH,TO_NUM_1
  2233 00:0BF4: xx xx        TO_NUM_3:       dw      EXIT
  2234                        
  2235                        ; ACCEPT ( c-addr +n1 -- +n2 )
  2236                        ;
  2237                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  2238                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  2239                        ; received. A program that depends on the presence or absence of non-graphic
  2240                        ; characters in the string has an environmental dependency. The editing
  2241                        ; functions, if any, that the system performs in order to construct the string
  2242                        ; are implementation-defined.
  2243                        ;
  2244                        ; Input terminates when an implementation-defined line terminator is received.
  2245                        ; When input terminates, nothing is appended to the string, and the display is
  2246                        ; maintained in an implementation-defined way.
  2247                        ;
  2248                        ; +n2 is the length of the string stored at c-addr.
  2249                        ;
  2250                        ; In this implementation it is defined as:
  2251                        ;
  2252                        ;   OVER + 1- OVER      -- sa ea a
  2253                        ;   BEGIN KEY           -- sa ea a c
  2254                        ;   DUP 0D <> WHILE
  2255                        ;     DUP 8 = OVER 127 = OR IF
  2256                        ;       DROP 1-
  2257                        ;       >R OVER R> UMAX
  2258                        ;       8 EMIT SPACE 8 EMIT
  2259                        ;     ELSE
  2260                        ;       DUP EMIT        -- sa ea a c
  2261                        ;       OVER C! 1+ OVER UMIN
  2262                        ;     THEN              -- sa ea a
  2263                        ;   REPEAT              -- sa ea a c
  2264                        ;   DROP NIP SWAP - ;
  2265                        
  2266 00:0BF6: xx xx 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0BFA: 41 43 43 45 
  Sat May  7 2016 20:07                                                                                                    Page 46


       00:0BFE: 50 54 
  2267 00:0C00: 20 xx xx     ACCEPT:         jsr     DO_COLON
  2268 00:0C03: xx xx                        dw      OVER
  2269 00:0C05: xx xx                        dw      PLUS
  2270 00:0C07: xx xx                        dw      ONE_MINUS
  2271 00:0C09: xx xx                        dw      OVER
  2272 00:0C0B: xx xx        ACCEPT_1:       dw      KEY
  2273 00:0C0D: xx xx                        dw      DUP
  2274 00:0C0F: xx xx 0D 00                  dw      DO_LITERAL,$0D
  2275 00:0C13: xx xx                        dw      NOT_EQUAL
  2276 00:0C15: xx xx xx xx                  dw      QUERY_BRANCH,ACCEPT_4
  2277 00:0C19: xx xx                        dw      DUP
  2278 00:0C1B: xx xx 08 00                  dw      DO_LITERAL,$08
  2279 00:0C1F: xx xx                        dw      EQUAL
  2280 00:0C21: xx xx                        dw      OVER
  2281 00:0C23: xx xx 7F 00                  dw      DO_LITERAL,$7f
  2282 00:0C27: xx xx                        dw      EQUAL
  2283 00:0C29: xx xx                        dw      OR
  2284 00:0C2B: xx xx xx xx                  dw      QUERY_BRANCH,ACCEPT_2
  2285 00:0C2F: xx xx                        dw      DROP
  2286 00:0C31: xx xx                        dw      ONE_MINUS
  2287 00:0C33: xx xx                        dw      TO_R
  2288 00:0C35: xx xx                        dw      OVER
  2289 00:0C37: xx xx                        dw      R_FROM
  2290 00:0C39: xx xx                        dw      UMAX
  2291 00:0C3B: xx xx 08 00                  dw      DO_LITERAL,8
  2292 00:0C3F: xx xx                        dw      EMIT
  2293 00:0C41: xx xx                        dw      SPACE
  2294 00:0C43: xx xx 08 00                  dw      DO_LITERAL,8
  2295 00:0C47: xx xx                        dw      EMIT
  2296 00:0C49: xx xx xx xx                  dw      BRANCH,ACCEPT_3
  2297 00:0C4D: xx xx        ACCEPT_2:       dw      DUP
  2298 00:0C4F: xx xx                        dw      EMIT
  2299 00:0C51: xx xx                        dw      OVER
  2300 00:0C53: xx xx                        dw      C_STORE
  2301 00:0C55: xx xx                        dw      ONE_PLUS
  2302 00:0C57: xx xx                        dw      OVER
  2303 00:0C59: xx xx                        dw      UMIN
  2304 00:0C5B: xx xx xx xx  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  2305 00:0C5F: xx xx        ACCEPT_4:       dw      DROP
  2306 00:0C61: xx xx                        dw      NIP
  2307 00:0C63: xx xx                        dw      SWAP
  2308 00:0C65: xx xx                        dw      MINUS
  2309 00:0C67: xx xx                        dw      EXIT
  2310                        
  2311                        ; DIGIT?
  2312                        ;
  2313                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  2314                        ;   DUP 140 > 107 AND -   30 -     but it works!
  2315                        ;   DUP BASE @ U< ;
  2316                        
  2317 00:0C69: xx xx 00 06                  HEADER  6,"DIGIT?",NORMAL
       00:0C6D: 44 49 47 49 
       00:0C71: 54 3F 
  2318 00:0C73: 20 xx xx     DIGIT_QUERY:    jsr     DO_COLON
  2319 00:0C76: xx xx                        dw      DUP
  2320 00:0C78: xx xx 39 00                  dw      DO_LITERAL,'9'
  2321 00:0C7C: xx xx                        dw      GREATER
  Sat May  7 2016 20:07                                                                                                    Page 47


  2322 00:0C7E: xx xx 00 01                  dw      DO_LITERAL,$100
  2323 00:0C82: xx xx                        dw      AND
  2324 00:0C84: xx xx                        dw      PLUS
  2325 00:0C86: xx xx                        dw      DUP
  2326 00:0C88: xx xx 40 01                  dw      DO_LITERAL,$140
  2327 00:0C8C: xx xx                        dw      GREATER
  2328 00:0C8E: xx xx 07 01                  dw      DO_LITERAL,$107
  2329 00:0C92: xx xx                        dw      AND
  2330 00:0C94: xx xx                        dw      MINUS
  2331 00:0C96: xx xx 30 00                  dw      DO_LITERAL,'0'
  2332 00:0C9A: xx xx                        dw      MINUS
  2333 00:0C9C: xx xx                        dw      DUP
  2334 00:0C9E: xx xx                        dw      BASE
  2335 00:0CA0: xx xx                        dw      FETCH
  2336 00:0CA2: xx xx                        dw      U_LESS
  2337 00:0CA4: xx xx                        dw      EXIT
  2338                        
  2339                        ; EVALUATE ( i*x c-addr u -- j*x )
  2340                        ;
  2341                        ; Save the current input source specification. Store minus-one (-1) in
  2342                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  2343                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  2344                        ; parse area is empty, restore the prior input source specification. Other
  2345                        ; stack effects are due to the words EVALUATEd.
  2346                        ;
  2347                        ;   >R >R SAVE-INPUT
  2348                        ;   -1 (SOURCE-ID) !
  2349                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  2350                        ;   INTERPRET
  2351                        ;   RESTORE-INPUT DROP
  2352                        
  2353 00:0CA6: xx xx 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:0CAA: 45 56 41 4C 
       00:0CAE: 55 41 54 45 
  2354 00:0CB2: 20 xx xx     EVALUATE:       jsr     DO_COLON
  2355 00:0CB5: xx xx                        dw      TO_R
  2356 00:0CB7: xx xx                        dw      TO_R
  2357 00:0CB9: xx xx                        dw      SAVE_INPUT
  2358 00:0CBB: xx xx                        dw      R_FROM
  2359 00:0CBD: xx xx                        dw      R_FROM
  2360 00:0CBF: xx xx                        dw      TRUE
  2361 00:0CC1: xx xx                        dw      SOURCEID
  2362 00:0CC3: xx xx                        dw      STORE
  2363 00:0CC5: xx xx                        dw      ZERO
  2364 00:0CC7: xx xx                        dw      TO_IN
  2365 00:0CC9: xx xx                        dw      STORE
  2366 00:0CCB: xx xx                        dw      LENGTH
  2367 00:0CCD: xx xx                        dw      STORE
  2368 00:0CCF: xx xx                        dw      BUFFER
  2369 00:0CD1: xx xx                        dw      STORE
  2370 00:0CD3: xx xx                        dw      INTERPRET
  2371 00:0CD5: xx xx                        dw      RESTORE_INPUT
  2372 00:0CD7: xx xx                        dw      DROP
  2373 00:0CD9: xx xx                        dw      EXIT
  2374                        
  2375                        ; INTERPRET ( -- )
  2376                        ;
  2377                        ;
  Sat May  7 2016 20:07                                                                                                    Page 48


  2378                        ;   BEGIN
  2379                        ;   BL WORD DUP C@ WHILE        -- textadr
  2380                        ;       FIND                    -- a 0/1/-1
  2381                        ;       ?DUP IF                 -- xt 1/-1
  2382                        ;           1+ STATE @ 0= OR    immed or interp?
  2383                        ;           IF EXECUTE ELSE , THEN
  2384                        ;       ELSE                    -- textadr
  2385                        ;           ?NUMBER
  2386                        ;           IF STATE @
  2387                        ;               IF POSTPONE LITERAL THEN     converted ok
  2388                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  2389                        ;           THEN
  2390                        ;       THEN
  2391                        ;   REPEAT DROP ;
  2392                        
  2393 00:0CDB: xx xx 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:0CDF: 49 4E 54 45 
       00:0CE3: 52 50 52 45 
       00:0CE7: 54 
  2394 00:0CE8: 20 xx xx     INTERPRET:      jsr     DO_COLON
  2395 00:0CEB: xx xx        INTERPRET_1:    dw      BL
  2396 00:0CED: xx xx                        dw      WORD
  2397 00:0CEF: xx xx                        dw      DUP
  2398 00:0CF1: xx xx                        dw      C_FETCH
  2399 00:0CF3: xx xx xx xx                  dw      QUERY_BRANCH,INTERPRET_7
  2400 00:0CF7: xx xx                        dw      FIND
  2401 00:0CF9: xx xx                        dw      QUERY_DUP
  2402 00:0CFB: xx xx xx xx                  dw      QUERY_BRANCH,INTERPRET_4
  2403 00:0CFF: xx xx                        dw      ONE_PLUS
  2404 00:0D01: xx xx                        dw      STATE
  2405 00:0D03: xx xx                        dw      FETCH
  2406 00:0D05: xx xx                        dw      ZERO_EQUAL
  2407 00:0D07: xx xx                        dw      OR
  2408 00:0D09: xx xx xx xx                  dw      QUERY_BRANCH,INTERPRET_2
  2409 00:0D0D: xx xx                        dw      EXECUTE
  2410 00:0D0F: xx xx xx xx                  dw      BRANCH,INTERPRET_3
  2411 00:0D13: xx xx        INTERPRET_2:    dw      COMMA
  2412 00:0D15: xx xx xx xx  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  2413 00:0D19: xx xx        INTERPRET_4:    dw      QUERY_NUMBER
  2414 00:0D1B: xx xx xx xx                  dw      QUERY_BRANCH,INTERPRET_5
  2415 00:0D1F: xx xx                        dw      STATE
  2416 00:0D21: xx xx                        dw      FETCH
  2417 00:0D23: xx xx xx xx                  dw      QUERY_BRANCH,INTERPRET_6
  2418 00:0D27: xx xx                        dw      LITERAL
  2419 00:0D29: xx xx xx xx                  dw      BRANCH,INTERPRET_6
  2420 00:0D2D: xx xx        INTERPRET_5:    dw      COUNT
  2421 00:0D2F: xx xx                        dw      TYPE
  2422 00:0D31: xx xx 3F 00                  dw      DO_LITERAL,$3f
  2423 00:0D35: xx xx                        dw      EMIT
  2424 00:0D37: xx xx                        dw      CR
  2425 00:0D39: xx xx                        dw      ABORT
  2426 00:0D3B: xx xx xx xx  INTERPRET_6     dw      BRANCH,INTERPRET_1
  2427 00:0D3F: xx xx        INTERPRET_7:    dw      DROP
  2428 00:0D41: xx xx                        dw      EXIT
  2429                        
  2430                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  2431                        ;
  2432                        ; Find the definition named in the counted string at c-addr. If the definition
  Sat May  7 2016 20:07                                                                                                    Page 49


  2433                        ; is not found, return c-addr and zero. If the definition is found, return its
  2434                        ; execution token xt. If the definition is immediate, also return one (1),
  2435                        ; otherwise also return minus-one (-1). For a given string, the values returned
  2436                        ; by FIND while compiling may differ from those returned while not compiling.
  2437                        ;
  2438                        ; In this implementation it is defined as:
  2439                        ;
  2440                        ;   LATEST @ BEGIN             -- a nfa
  2441                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  2442                        ;       S=                     -- a nfa f
  2443                        ;       DUP IF
  2444                        ;           DROP
  2445                        ;           NFA>LFA @ DUP      -- a link link
  2446                        ;       THEN
  2447                        ;   0= UNTIL                   -- a nfa  OR  a 0
  2448                        ;   DUP IF
  2449                        ;       NIP DUP NFA>CFA        -- nfa xt
  2450                        ;       SWAP IMMED?            -- xt iflag
  2451                        ;       0= 1 OR                -- xt 1/-1
  2452                        ;   THEN ;
  2453                        
  2454 00:0D43: xx xx 00 04                  HEADER  4,"FIND",NORMAL
       00:0D47: 46 49 4E 44 
  2455 00:0D4B: 20 xx xx     FIND:           jsr     DO_COLON
  2456 00:0D4E: xx xx                        dw      LATEST
  2457 00:0D50: xx xx                        dw      FETCH
  2458 00:0D52: xx xx        FIND1:          dw      TWO_DUP
  2459 00:0D54: xx xx                        dw      OVER
  2460 00:0D56: xx xx                        dw      C_FETCH
  2461 00:0D58: xx xx                        dw      CHAR_PLUS
  2462 00:0D5A: xx xx                        dw      S_EQUAL
  2463 00:0D5C: xx xx                        dw      DUP
  2464 00:0D5E: xx xx xx xx                  dw      QUERY_BRANCH,FIND2
  2465 00:0D62: xx xx                        dw      DROP
  2466 00:0D64: xx xx                        dw      NFA_TO_LFA
  2467 00:0D66: xx xx                        dw      FETCH
  2468 00:0D68: xx xx                        dw      DUP
  2469 00:0D6A: xx xx        FIND2:          dw      ZERO_EQUAL
  2470 00:0D6C: xx xx xx xx                  dw      QUERY_BRANCH,FIND1
  2471 00:0D70: xx xx                        dw      DUP
  2472 00:0D72: xx xx xx xx                  dw      QUERY_BRANCH,FIND3
  2473 00:0D76: xx xx                        dw      NIP
  2474 00:0D78: xx xx                        dw      DUP
  2475 00:0D7A: xx xx                        dw      NFA_TO_CFA
  2476 00:0D7C: xx xx                        dw      SWAP
  2477 00:0D7E: xx xx                        dw      IMMED_QUERY
  2478 00:0D80: xx xx                        dw      ZERO_EQUAL
  2479 00:0D82: xx xx 01 00                  dw      DO_LITERAL,1
  2480 00:0D86: xx xx                        dw      OR
  2481 00:0D88: xx xx        FIND3:          dw      EXIT
  2482                        
  2483                        ; IMMED? ( nfa -- f )
  2484                        
  2485 00:0D8A: 20 xx xx     IMMED_QUERY:    jsr     DO_COLON
  2486 00:0D8D: xx xx                        dw      ONE_MINUS
  2487 00:0D8F: xx xx                        dw      C_FETCH
  2488 00:0D91: xx xx                        dw      EXIT
  2489                        
  Sat May  7 2016 20:07                                                                                                    Page 50


  2490                        ; NFA>CFA ( nfa -- cfa )
  2491                        
  2492 00:0D93: 20 xx xx     NFA_TO_CFA:     jsr     DO_COLON
  2493 00:0D96: xx xx                        dw      COUNT
  2494 00:0D98: xx xx                        dw      PLUS
  2495 00:0D9A: xx xx                        dw      EXIT
  2496                        
  2497                        ; NFA>LFA ( nfa -- lfa )
  2498                        
  2499 00:0D9C: 20 xx xx     NFA_TO_LFA:     jsr     DO_COLON
  2500 00:0D9F: xx xx 03 00                  dw      DO_LITERAL,3
  2501 00:0DA3: xx xx                        dw      MINUS
  2502 00:0DA5: xx xx                        dw      EXIT
  2503                        
  2504                        ; REFILL ( -- flag )
  2505                        ;
  2506                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2507                        ; if successful.
  2508                        ;
  2509                        ; When the input source is the user input device, attempt to receive input into
  2510                        ; the terminal input buffer. If successful, make the result the input buffer,
  2511                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2512                        ; is considered successful. If there is no input available from the current
  2513                        ; input source, return false.
  2514                        ;
  2515                        ; When the input source is a string from EVALUATE, return false and perform no
  2516                        ; other action.
  2517                        ;
  2518                        ; In this implementation it is defined as:
  2519                        ;
  2520                        ;   SOURCE-ID 0= IF
  2521                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2522                        ;     LENGTH ! BUFFER !
  2523                        ;     0 >IN ! TRUE EXIT
  2524                        ;   THEN
  2525                        ;   FALSE
  2526                        
  2527 00:0DA7: xx xx 00 06                  HEADER  6,"REFILL",NORMAL
       00:0DAB: 52 45 46 49 
       00:0DAF: 4C 4C 
  2528 00:0DB1: 20 xx xx     REFILL:         jsr     DO_COLON
  2529 00:0DB4: xx xx                        dw      SOURCE_ID
  2530 00:0DB6: xx xx                        dw      ZERO_EQUAL
  2531 00:0DB8: xx xx xx xx                  dw      QUERY_BRANCH,REFILL_1
  2532 00:0DBC: xx xx                        dw      TIB
  2533 00:0DBE: xx xx                        dw      DUP
  2534 00:0DC0: xx xx                        dw      HASH_TIB
  2535 00:0DC2: xx xx                        dw      FETCH
  2536 00:0DC4: xx xx                        dw      ACCEPT
  2537 00:0DC6: xx xx                        dw      SPACE
  2538 00:0DC8: xx xx                        dw      LENGTH
  2539 00:0DCA: xx xx                        dw      STORE
  2540 00:0DCC: xx xx                        dw      BUFFER
  2541 00:0DCE: xx xx                        dw      STORE
  2542 00:0DD0: xx xx                        dw      ZERO
  2543 00:0DD2: xx xx                        dw      TO_IN
  2544 00:0DD4: xx xx                        dw      STORE
  2545 00:0DD6: xx xx                        dw      TRUE
  Sat May  7 2016 20:07                                                                                                    Page 51


  2546 00:0DD8: xx xx                        dw      EXIT
  2547 00:0DDA: xx xx        REFILL_1:       dw      FALSE
  2548 00:0DDC: xx xx                        dw      EXIT
  2549                        
  2550                        ; RESTORE-INPUT ( xn ... x1 n -- flag )
  2551                        ;
  2552                        ; Attempt to restore the input source specification to the state described by
  2553                        ; x1 through xn. flag is true if the input source specification cannot be so
  2554                        ; restored.
  2555                        ;
  2556                        ; An ambiguous condition exists if the input source represented by the
  2557                        ; arguments is not the same as the current input source.
  2558                        ;
  2559                        ; In this implementation it is defined as:
  2560                        ;
  2561                        ;   >IN ! (LENGTH) ! BUFFER !
  2562                        ;   SOURCEID !
  2563                        ;   TRUE
  2564                        
  2565 00:0DDE: xx xx 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:0DE2: 52 45 53 54 
       00:0DE6: 4F 52 45 2D 
       00:0DEA: 49 4E 50 55 
       00:0DEE: 54 
  2566 00:0DEF: 20 xx xx     RESTORE_INPUT   jsr     DO_COLON
  2567 00:0DF2: xx xx                        dw      TO_IN
  2568 00:0DF4: xx xx                        dw      STORE
  2569 00:0DF6: xx xx                        dw      LENGTH
  2570 00:0DF8: xx xx                        dw      STORE
  2571 00:0DFA: xx xx                        dw      BUFFER
  2572 00:0DFC: xx xx                        dw      STORE
  2573 00:0DFE: xx xx                        dw      SOURCEID
  2574 00:0E00: xx xx                        dw      STORE
  2575 00:0E02: xx xx                        dw      TRUE
  2576 00:0E04: xx xx                        dw      EXIT
  2577                        
  2578                        ; S= ( c-addr1 caddr2 u -- n)
  2579                        ;
  2580                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2581                        
  2582                        S_EQUAL:
  2583 00:0E06: 5A                           phy
  2584 00:0E07: A6 01                        ldx     <1                      ; Fetch maximum length
  2585 00:0E09: F0 14                        beq     S_EQUAL_3
  2586 00:0E0B: A0 00 00                     ldy     #0
  2587 00:0E0E: E2 20                        short_a
  2588                        S_EQUAL_1:
  2589 00:0E10: B1 05                        lda     (5),y                   ; Compare bytes
  2590 00:0E12: D1 03                        cmp     (3),y
  2591 00:0E14: D0 06                        bne     S_EQUAL_2
  2592 00:0E16: C8                           iny
  2593 00:0E17: CA                           dex                             ; End of strings?
  2594 00:0E18: D0 F6                        bne     S_EQUAL_1               ; No
  2595 00:0E1A: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2596                        S_EQUAL_2:
  2597 00:0E1C: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2598                        S_EQUAL_3:
  2599 00:0E1F: C2 20                        long_a
  Sat May  7 2016 20:07                                                                                                    Page 52


  2600 00:0E21: 7B                           tdc                             ; Clean up the stack
  2601 00:0E22: 1A                           inc     a
  2602 00:0E23: 1A                           inc     a
  2603 00:0E24: 1A                           inc     a
  2604 00:0E25: 1A                           inc     a
  2605 00:0E26: 5B                           tcd
  2606 00:0E27: 86 01                        stx     <1                      ; Save the flag
  2607 00:0E29: 7A                           ply
  2608 00:0E2A: BB C8 C8 7C                  CONTINUE
       00:0E2E: 00 00 
  2609                        
  2610                        ; SAVE-INPUT ( -- xn ... x1 n )
  2611                        ;
  2612                        ; x1 through xn describe the current state of the input source specification
  2613                        ; for later use by RESTORE-INPUT.
  2614                        
  2615 00:0E30: xx xx 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:0E34: 53 41 56 45 
       00:0E38: 2D 49 4E 50 
       00:0E3C: 55 54 
  2616 00:0E3E: 20 xx xx     SAVE_INPUT:     jsr     DO_COLON
  2617 00:0E41: xx xx                        dw      SOURCEID
  2618 00:0E43: xx xx                        dw      FETCH
  2619 00:0E45: xx xx                        dw      BUFFER
  2620 00:0E47: xx xx                        dw      FETCH
  2621 00:0E49: xx xx                        dw      LENGTH
  2622 00:0E4B: xx xx                        dw      FETCH
  2623 00:0E4D: xx xx                        dw      TO_IN
  2624 00:0E4F: xx xx                        dw      FETCH
  2625 00:0E51: xx xx                        dw      EXIT
  2626                        
  2627                        ; SCAN ( c-addr n c == c-addr' n' )
  2628                        
  2629                        SCAN:
  2630                        SCAN_1:
  2631 00:0E53: A5 03                        lda     <3                      ; Any data left to scan?
  2632 00:0E55: F0 10                        beq     SCAN_2                  ; No.
  2633 00:0E57: A5 01                        lda     <1                      ; Fetch and compare with scan
  2634 00:0E59: E2 20                        short_a
  2635 00:0E5B: D2 05                        cmp     (5)
  2636 00:0E5D: C2 20                        long_a
  2637 00:0E5F: F0 06                        beq     SCAN_2
  2638 00:0E61: E6 05                        inc     <5
  2639 00:0E63: C6 03                        dec     <3
  2640 00:0E65: 80 EC                        bra     SCAN_1
  2641                        SCAN_2:
  2642 00:0E67: 4C xx xx                     jmp     DROP                    ; Drop the character
  2643                        
  2644                        ; SKIP ( c-addr n c == c-addr' n' )
  2645                        
  2646                        SKIP:
  2647 00:0E6A: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  2648 00:0E6C: F0 10                        beq     SKIP_2                  ; No.
  2649 00:0E6E: A5 01                        lda     <1                      ; Fetch and compare with skip
  2650 00:0E70: E2 20                        short_a
  2651 00:0E72: D2 05                        cmp     (5)
  2652 00:0E74: C2 20                        long_a
  2653 00:0E76: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  Sat May  7 2016 20:07                                                                                                    Page 53


  2654 00:0E78: E6 05                        inc     <5                      ; Bump data address
  2655 00:0E7A: C6 03                        dec     <3                      ; and update length
  2656 00:0E7C: 80 EC                        bra     SKIP_1                  ; And repeat
  2657                        SKIP_2:
  2658 00:0E7E: 4C xx xx                     jmp     DROP                    ; Drop the character
  2659                        
  2660                        ; SOURCE ( -- c-addr u )
  2661                        ;
  2662                        ; c-addr is the address of, and u is the number of characters in, the input
  2663                        ; buffer.
  2664                        ;
  2665                        ; In this implementation it is defined as
  2666                        ;
  2667                        ;   BUFFER @ LENGTH @
  2668                        
  2669 00:0E81: xx xx 00 06                  HEADER  6,"SOURCE",NORMAL
       00:0E85: 53 4F 55 52 
       00:0E89: 43 45 
  2670 00:0E8B: 20 xx xx     SOURCE:         jsr     DO_COLON
  2671 00:0E8E: xx xx                        dw      BUFFER
  2672 00:0E90: xx xx                        dw      FETCH
  2673 00:0E92: xx xx                        dw      LENGTH
  2674 00:0E94: xx xx                        dw      FETCH
  2675 00:0E96: xx xx                        dw      EXIT
  2676                        
  2677                        ; SOURCE-ID ( -- 0 | -1 )
  2678                        ;
  2679                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2680                        ; device.
  2681                        
  2682 00:0E98: xx xx 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:0E9C: 53 4F 55 52 
       00:0EA0: 43 45 2D 49 
       00:0EA4: 44 
  2683 00:0EA5: 20 xx xx     SOURCE_ID:      jsr     DO_COLON
  2684 00:0EA8: xx xx                        dw      SOURCEID
  2685 00:0EAA: xx xx                        dw      FETCH
  2686 00:0EAC: xx xx                        dw      EXIT
  2687                        
  2688                        ; WORD ( char <chars>ccc<char> -- c-addr )
  2689                        ;
  2690                        ; Skip leading delimiters. Parse characters ccc delimited by char. An
  2691                        ; ambiguous condition exists if the length of the parsed string is greater
  2692                        ; than the implementation-defined length of a counted string.
  2693                        ;
  2694                        ; c-addr is the address of a transient region containing the parsed word as
  2695                        ; a counted string. If the parse area was empty or contained no characters
  2696                        ; other than the delimiter, the resulting string has a zero length. A space,
  2697                        ; not included in the length, follows the string. A program may replace
  2698                        ; characters within the string.
  2699                        ;
  2700                        ; In this implementation it is defined as:
  2701                        ;
  2702                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2703                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2704                        ;   OVER >R  ROT SCAN           -- adr" n"
  2705                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2706                        ;   R> R> ROT -   >IN +!        update >IN offset
  Sat May  7 2016 20:07                                                                                                    Page 54


  2707                        ;   TUCK -                      -- adr' N
  2708                        ;   HERE >counted               --
  2709                        ;   HERE                        -- a
  2710                        ;   BL OVER COUNT + C! ;    append trailing blank
  2711                        
  2712 00:0EAE: xx xx 00 04                  HEADER  4,"WORD",NORMAL
       00:0EB2: 57 4F 52 44 
  2713 00:0EB6: 20 xx xx     WORD:           jsr     DO_COLON
  2714 00:0EB9: xx xx                        dw      DUP
  2715 00:0EBB: xx xx                        dw      SOURCE
  2716 00:0EBD: xx xx                        dw      TO_IN
  2717 00:0EBF: xx xx                        dw      FETCH
  2718 00:0EC1: xx xx                        dw      SLASH_STRING
  2719 00:0EC3: xx xx                        dw      DUP
  2720 00:0EC5: xx xx                        dw      TO_R
  2721 00:0EC7: xx xx                        dw      ROT
  2722 00:0EC9: xx xx                        dw      SKIP
  2723 00:0ECB: xx xx                        dw      OVER
  2724 00:0ECD: xx xx                        dw      TO_R
  2725 00:0ECF: xx xx                        dw      ROT
  2726 00:0ED1: xx xx                        dw      SCAN
  2727 00:0ED3: xx xx                        dw      DUP
  2728 00:0ED5: xx xx xx xx                  dw      QUERY_BRANCH,WORD_1
  2729 00:0ED9: xx xx                        dw      CHAR_MINUS
  2730 00:0EDB: xx xx        WORD_1:         dw      R_FROM
  2731 00:0EDD: xx xx                        dw      R_FROM
  2732 00:0EDF: xx xx                        dw      ROT
  2733 00:0EE1: xx xx                        dw      MINUS
  2734 00:0EE3: xx xx                        dw      TO_IN
  2735 00:0EE5: xx xx                        dw      PLUS_STORE
  2736 00:0EE7: xx xx                        dw      TUCK
  2737 00:0EE9: xx xx                        dw      MINUS
  2738 00:0EEB: xx xx                        dw      HERE
  2739 00:0EED: xx xx                        dw      TO_COUNTED
  2740 00:0EEF: xx xx                        dw      HERE
  2741 00:0EF1: xx xx                        dw      BL
  2742 00:0EF3: xx xx                        dw      OVER
  2743 00:0EF5: xx xx                        dw      COUNT
  2744 00:0EF7: xx xx                        dw      PLUS
  2745 00:0EF9: xx xx                        dw      C_STORE
  2746 00:0EFB: xx xx                        dw      EXIT
  2747                        
  2748                        ;===============================================================================
  2749                        ; String Words
  2750                        ;-------------------------------------------------------------------------------
  2751                        
  2752                        ; -TRAILING ( c-addr u1 -- c-addr u2 )
  2753                        ;
  2754                        ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
  2755                        ; the end of the character string specified by c-addr u1. If u1 is zero or the
  2756                        ; entire string consists of spaces, u2 is zero.
  2757                        
  2758 00:0EFD: xx xx 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:0F01: 2D 54 52 41 
       00:0F05: 49 4C 49 4E 
       00:0F09: 47 
  2759                        DASH_TRAILING:
  2760 00:0F0A: 5A                           phy                             ; Save IP
  Sat May  7 2016 20:07                                                                                                    Page 55


  2761 00:0F0B: A4 01                        ldy     <1                      ; Is u1 > 0?
  2762 00:0F0D: F0 0F                        beq     DASH_TRAIL_3            ; No
  2763 00:0F0F: E2 20                        short_a
  2764 00:0F11: 88                           dey                             ; Convert to offset
  2765 00:0F12: B1 03        DASH_TRAIL_1:   lda     (3),y                   ; Space character at end?
  2766 00:0F14: C9 20                        cmp     #' '
  2767 00:0F16: D0 03                        bne     DASH_TRAIL_2            ; No
  2768 00:0F18: 88                           dey                             ; More characters to check?
  2769 00:0F19: 10 F7                        bpl     DASH_TRAIL_1            ; Yes
  2770 00:0F1B: C2 20        DASH_TRAIL_2:   long_a
  2771 00:0F1D: C8                           iny                             ; Convert to length
  2772 00:0F1E: 84 01        DASH_TRAIL_3:   sty     <1                      ; Update
  2773 00:0F20: 7A                           ply                             ; Restore IP
  2774 00:0F21: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0F25: 00 00 
  2775                        
  2776                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2777                        ;
  2778                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2779                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2780                        ; characters and is u1 minus n characters long.
  2781                        ;
  2782                        ; In this implementation it is defined as:
  2783                        ;
  2784                        ;   ROT OVER + ROT ROT -
  2785                        
  2786 00:0F27: xx xx 00 07                  HEADER  7,"/STRING",NORMAL
       00:0F2B: 2F 53 54 52 
       00:0F2F: 49 4E 47 
  2787 00:0F32: 20 xx xx     SLASH_STRING:   jsr     DO_COLON
  2788 00:0F35: xx xx                        dw      ROT
  2789 00:0F37: xx xx                        dw      OVER
  2790 00:0F39: xx xx                        dw      PLUS
  2791 00:0F3B: xx xx                        dw      ROT
  2792 00:0F3D: xx xx                        dw      ROT
  2793 00:0F3F: xx xx                        dw      MINUS
  2794 00:0F41: xx xx                        dw      EXIT
  2795                        
  2796                        ; BLANK ( c-addr u -- )
  2797                        ;
  2798                        ; If u is greater than zero, store the character value for space in u
  2799                        ; consecutive character positions beginning at c-addr.
  2800                        ;
  2801                        ; In this implementation it is defined as
  2802                        ;
  2803                        ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
  2804                        
  2805 00:0F43: xx xx 00 05                  HEADER  5,"BLANK",NORMAL
       00:0F47: 42 4C 41 4E 
       00:0F4B: 4B 
  2806 00:0F4C: 20 xx xx     BLANK:          jsr     DO_COLON
  2807 00:0F4F: xx xx                        dw      QUERY_DUP
  2808 00:0F51: xx xx xx xx                  dw      QUERY_BRANCH,BLANK_2
  2809 00:0F55: xx xx                        dw      OVER
  2810 00:0F57: xx xx                        dw      PLUS
  2811 00:0F59: xx xx                        dw      SWAP
  2812 00:0F5B: xx xx                        dw      DO_DO
  2813 00:0F5D: xx xx        BLANK_1:        dw      BL
  Sat May  7 2016 20:07                                                                                                    Page 56


  2814 00:0F5F: xx xx                        dw      I
  2815 00:0F61: xx xx                        dw      C_STORE
  2816 00:0F63: xx xx xx xx                  dw      DO_LOOP,BLANK_1
  2817 00:0F67: xx xx                        dw      EXIT
  2818 00:0F69: xx xx        BLANK_2:        dw      DROP
  2819 00:0F6B: xx xx                        dw      EXIT
  2820                        
  2821                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2822                        ;
  2823                        ; If u is greater than zero, copy u consecutive characters from the data space
  2824                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2825                        ; character from lower addresses to higher addresses.
  2826                        
  2827 00:0F6D: xx xx 00 05                  HEADER  5,"CMOVE",NORMAL
       00:0F71: 43 4D 4F 56 
       00:0F75: 45 
  2828                        CMOVE:
  2829 00:0F76: 5A                           phy
  2830 00:0F77: A6 01                        ldx     <1                      ; Any characters to move?
  2831 00:0F79: F0 0F                        beq     CMOVE_2                 ; No
  2832 00:0F7B: A0 00 00                     ldy     #0
  2833 00:0F7E: E2 20                        short_a
  2834                        CMOVE_1:                                        ; Transfer a byte
  2835 00:0F80: B1 05                        lda     (5),y
  2836 00:0F82: 91 03                        sta     (3),y
  2837 00:0F84: C8                           iny
  2838 00:0F85: CA                           dex                             ; Decrement count
  2839 00:0F86: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2840 00:0F88: C2 20                        long_a
  2841                        CMOVE_2:
  2842 00:0F8A: 7B                           tdc                             ; Clean up the stack
  2843 00:0F8B: 18                           clc
  2844 00:0F8C: 69 06 00                     adc     #6
  2845 00:0F8F: 5B                           tcd
  2846 00:0F90: 7A                           ply
  2847 00:0F91: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0F95: 00 00 
  2848                        
  2849                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2850                        ;
  2851                        ; If u is greater than zero, copy u consecutive characters from the data space
  2852                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2853                        ; character from higher addresses to lower addresses.
  2854                        
  2855 00:0F97: xx xx 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:0F9B: 43 4D 4F 56 
       00:0F9F: 45 3E 
  2856                        CMOVE_GREATER:
  2857 00:0FA1: 5A                           phy
  2858 00:0FA2: A6 01                        ldx     <1                      ; Any characters to move?
  2859 00:0FA4: F0 0E                        beq     CMOVE_GT_2              ; No.
  2860 00:0FA6: A4 01                        ldy     <1
  2861 00:0FA8: E2 20                        short_a
  2862                        CMOVE_GT_1:
  2863 00:0FAA: 88                           dey                             ; Transfer a byte
  2864 00:0FAB: B1 05                        lda     (5),y
  2865 00:0FAD: 91 03                        sta     (3),y
  2866 00:0FAF: CA                           dex                             ; Decrement length
  Sat May  7 2016 20:07                                                                                                    Page 57


  2867 00:0FB0: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2868 00:0FB2: C2 20                        long_a
  2869                        CMOVE_GT_2:
  2870 00:0FB4: 7B                           tdc                             ; Clean up the stack
  2871 00:0FB5: 18                           clc
  2872 00:0FB6: 69 06 00                     adc     #6
  2873 00:0FB9: 5B                           tcd
  2874 00:0FBA: 7A                           ply
  2875 00:0FBB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0FBF: 00 00 
  2876                        
  2877                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2878                        ;
  2879                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2880                        ; u2. The strings are compared, beginning at the given addresses, character by
  2881                        ; character, up to the length of the shorter string or until a difference is
  2882                        ; found. If the two strings are identical, n is zero. If the two strings are
  2883                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2884                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2885                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2886                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2887                        ; numeric value than the corresponding character in the string specified by
  2888                        ; c-addr2 u2 and one (1) otherwise.
  2889                        
  2890 00:0FC1: xx xx 00 07                  HEADER  7,"COMPARE",NORMAL
       00:0FC5: 43 4F 4D 50 
       00:0FC9: 41 52 45 
  2891                        COMPARE:
  2892 00:0FCC: A5 01                        lda     <1                      ; Both string lengths zero?
  2893 00:0FCE: 05 05                        ora     <5
  2894 00:0FD0: F0 26                        beq     COMPARE_X               ; Yes, must be equal
  2895                        
  2896 00:0FD2: A5 01                        lda     <1                      ; Second string length zero?
  2897 00:0FD4: F0 1A                        beq     COMPARE_P               ; Yes, must be shorter
  2898 00:0FD6: A5 05                        lda     <5                      ; First string length zero?
  2899 00:0FD8: F0 1B                        beq     COMPARE_N               ; Yes, must be shorter
  2900 00:0FDA: E2 20                        short_a
  2901 00:0FDC: B2 07                        lda     (7)                     ; Compare next characters
  2902 00:0FDE: D2 03                        cmp     (3)
  2903 00:0FE0: C2 20                        long_a
  2904 00:0FE2: 90 11                        bcc     COMPARE_N
  2905 00:0FE4: D0 0A                        bne     COMPARE_P
  2906                        
  2907 00:0FE6: E6 03                        inc     <3                      ; Bump string pointers
  2908 00:0FE8: E6 07                        inc     <7
  2909 00:0FEA: C6 01                        dec     <1                      ; And reduce lengths
  2910 00:0FEC: C6 05                        dec     <5
  2911 00:0FEE: 80 DC                        bra     COMPARE
  2912                        
  2913 00:0FF0: A9 01 00     COMPARE_P:      lda     #1
  2914 00:0FF3: 80 03                        bra     COMPARE_X
  2915 00:0FF5: A9 FF FF     COMPARE_N:      lda     #-1
  2916                        
  2917 00:0FF8: 85 07        COMPARE_X:      sta     <7                      ; Save the result
  2918 00:0FFA: 7B                           tdc
  2919 00:0FFB: 18                           clc
  2920 00:0FFC: 69 06 00                     adc     #6
  2921 00:0FFF: 5B                           tcd
  Sat May  7 2016 20:07                                                                                                    Page 58


  2922 00:1000: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1004: 00 00 
  2923                        
  2924                        ; COUNT ( c-addr1 -- c-addr2 u )
  2925                        ;
  2926                        ; Return the character string specification for the counted string stored at
  2927                        ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
  2928                        ; the contents of the character at c-addr1, which is the length in characters
  2929                        ; of the string at c-addr2.
  2930                        ;
  2931                        ; In this implementation it is defined as
  2932                        ;
  2933                        ;   DUP CHAR+ SWAP C@
  2934                        
  2935 00:1006: xx xx 00 05                  HEADER  5,"COUNT",NORMAL
       00:100A: 43 4F 55 4E 
       00:100E: 54 
  2936 00:100F: 20 xx xx     COUNT:          jsr     DO_COLON
  2937 00:1012: xx xx                        dw      DUP
  2938 00:1014: xx xx                        dw      CHAR_PLUS
  2939 00:1016: xx xx                        dw      SWAP
  2940 00:1018: xx xx                        dw      C_FETCH
  2941 00:101A: xx xx                        dw      EXIT
  2942                        
  2943                        ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
  2944                        ;
  2945                        ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
  2946                        ; u2. If flag is true, a match was found at c-addr3 with u3 characters
  2947                        ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
  2948                        ; is u1.
  2949                        
  2950 00:101C: xx xx 00 06                  HEADER  6,"SEARCH",NORMAL
       00:1020: 53 45 41 52 
       00:1024: 43 48 
  2951 00:1026: 20 xx xx     SEARCH:         jsr     DO_COLON
  2952                        ; TODO
  2953 00:1029: BB C8 C8 7C                  CONTINUE
       00:102D: 00 00 
  2954                        
  2955                        ;===============================================================================
  2956                        ; Compiling Words
  2957                        ;-------------------------------------------------------------------------------
  2958                        
  2959                        ; ( ( -- )
  2960                        ;
  2961                        ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
  2962                        ;
  2963                        ; The number of characters in ccc may be zero to the number of characters in the
  2964                        ; parse area.
  2965                        ;
  2966                        ; In this implementation it is defined as:
  2967                        ;
  2968                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2969                        
  2970 00:102F: xx xx 80 01                  HEADER  1,"(",IMMEDIATE
       00:1033: 28 
  2971 00:1034: 20 xx xx                     jsr     DO_COLON
  2972 00:1037: xx xx 29 00                  dw      DO_LITERAL,')'
  Sat May  7 2016 20:07                                                                                                    Page 59


  2973 00:103B: xx xx                        dw      WORD
  2974 00:103D: xx xx                        dw      DROP
  2975 00:103F: xx xx                        dw      EXIT
  2976                        
  2977                        ; .(
  2978                        
  2979 00:1041: xx xx 80 02                  HEADER  2,".(",IMMEDIATE
       00:1045: 2E 28 
  2980 00:1047: 20 xx xx     DOT_PAREN:      jsr     DO_COLON
  2981 00:104A: xx xx 29 00                  dw      DO_LITERAL,')'
  2982 00:104E: xx xx                        dw      WORD
  2983 00:1050: xx xx                        dw      COUNT
  2984 00:1052: xx xx                        dw      TYPE
  2985 00:1054: xx xx                        dw      EXIT
  2986                        
  2987                        ; ." ( -- )
  2988                        
  2989 00:1056: xx xx 80                     LINK    IMMEDIATE
  2990 00:1059: 02 2E 22                     db      2,".",'"'
  2991 00:105C: 20 xx xx     DOT_QUOTE:      jsr     DO_COLON
  2992 00:105F: xx xx                        dw      S_QUOTE
  2993 00:1061: xx xx xx xx                  dw      DO_LITERAL,TYPE
  2994 00:1065: xx xx                        dw      COMMA
  2995 00:1067: xx xx                        dw      EXIT
  2996                        
  2997                        
  2998                        ; +LOOP ( -- )
  2999                        
  3000 00:1069: xx xx 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:106D: 2B 4C 4F 4F 
       00:1071: 50 
  3001 00:1072: 20 xx xx     PLUS_LOOP:      jsr     DO_COLON
  3002 00:1075: xx xx xx xx                  dw      DO_LITERAL,DO_PLUS_LOOP
  3003 00:1079: xx xx                        dw      COMMA
  3004 00:107B: xx xx                        dw      COMMA
  3005 00:107D: xx xx                        dw      QUERY_DUP
  3006 00:107F: xx xx xx xx                  dw      QUERY_BRANCH,PLUS_LOOP_1
  3007 00:1083: xx xx                        dw      HERE
  3008 00:1085: xx xx                        dw      SWAP
  3009 00:1087: xx xx                        dw      STORE
  3010 00:1089: xx xx        PLUS_LOOP_1:    dw      EXIT
  3011                        
  3012                        DO_PLUS_LOOP:
  3013 00:108B: A6 01                        ldx     <1                      ; Fetch increment
  3014 00:108D: 7B                           tdc                             ; And drop
  3015 00:108E: 1A                           inc     a
  3016 00:108F: 1A                           inc     a
  3017 00:1090: 5B                           tcd
  3018 00:1091: 18                           clc                             ; Add to loop counter
  3019 00:1092: 8A                           txa
  3020 00:1093: 63 01                        adc     1,s
  3021 00:1095: 83 01                        sta     1,s
  3022 00:1097: C3 03                        cmp     3,s                     ; Reached limit?
  3023 00:1099: B0 0A                        bcs     DO_PLOOP_END            ; Yes
  3024 00:109B: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3025 00:109E: A8                           tay
  3026 00:109F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:10A3: 00 00 
  Sat May  7 2016 20:07                                                                                                    Page 60


  3027                        
  3028 00:10A5: C8           DO_PLOOP_END:   iny                             ; Skip over address
  3029 00:10A6: C8                           iny
  3030 00:10A7: 68                           pla                             ; Drop loop variables
  3031 00:10A8: 68                           pla
  3032 00:10A9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:10AD: 00 00 
  3033                        
  3034                        ; : ( -- )
  3035                        
  3036 00:10AF: xx xx 00 01                  HEADER  1,":",NORMAL
       00:10B3: 3A 
  3037 00:10B4: 20 xx xx     COLON:          jsr     DO_COLON
  3038 00:10B7: xx xx                        dw      CREATE
  3039 00:10B9: xx xx xx xx                  dw      DO_LITERAL,DO_COLON
  3040 00:10BD: xx xx                        dw      BUILD
  3041 00:10BF: xx xx                        dw      RIGHT_BRACKET
  3042 00:10C1: xx xx                        dw      EXIT
  3043                        
  3044                        DO_COLON:
  3045 00:10C3: FA                           plx                             ; Pull new word IP-1
  3046 00:10C4: 5A                           phy                             ; Save the old IP
  3047 00:10C5: E8                           inx                             ; Work out new IP
  3048 00:10C6: 9B                           txy
  3049 00:10C7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:10CB: 00 00 
  3050                        
  3051                        ; :NONAME ( -- xt )
  3052                        
  3053 00:10CD: xx xx 00 07                  HEADER  7,":NONAME",NORMAL
       00:10D1: 3A 4E 4F 4E 
       00:10D5: 41 4D 45 
  3054 00:10D8: 20 xx xx     NONAME:         jsr     DO_COLON
  3055 00:10DB: xx xx                        dw      HERE
  3056 00:10DD: xx xx xx xx                  dw      DO_LITERAL,DO_COLON
  3057 00:10E1: xx xx                        dw      BUILD
  3058 00:10E3: xx xx                        dw      RIGHT_BRACKET
  3059 00:10E5: xx xx                        dw      EXIT
  3060                        
  3061                        ; ; ( -- )
  3062                        
  3063 00:10E7: xx xx 80                     LINK    IMMEDIATE
  3064 00:10EA: 01 3B                        db      1,";"
  3065 00:10EC: 20 xx xx     SEMICOLON:      jsr     DO_COLON
  3066 00:10EF: xx xx xx xx                  dw      DO_LITERAL,EXIT
  3067 00:10F3: xx xx                        dw      COMMA
  3068 00:10F5: xx xx                        dw      LEFT_BRACKET
  3069 00:10F7: xx xx                        dw      EXIT
  3070                        
  3071                        ; ?DO ( -- )
  3072                        
  3073 00:10F9: xx xx 80 03                  HEADER  3,"?DO",IMMEDIATE
       00:10FD: 3F 44 4F 
  3074 00:1100: 20 xx xx     QUERY_DO:       jsr     DO_COLON
  3075 00:1103: xx xx xx xx                  dw      DO_LITERAL,QUERY_DO_DO
  3076 00:1107: xx xx                        dw      COMMA
  3077 00:1109: xx xx                        dw      HERE
  3078 00:110B: xx xx                        dw      ZERO
  Sat May  7 2016 20:07                                                                                                    Page 61


  3079 00:110D: xx xx                        dw      COMMA
  3080 00:110F: xx xx                        dw      HERE
  3081 00:1111: xx xx                        dw      EXIT
  3082                        
  3083                        QUERY_DO_DO:
  3084 00:1113: A5 01                        lda     <1                      ; Are the start and limit
  3085 00:1115: 45 03                        eor     <3                      ; .. the same?
  3086 00:1117: F0 05                        beq     QUERY_DO_DO_1
  3087 00:1119: C8                           iny                             ; No, Skip over jump address
  3088 00:111A: C8                           iny
  3089 00:111B: 4C xx xx                     jmp     DO_DO                   ; And start a normal loop
  3090                        
  3091 00:111E: 7B           QUERY_DO_DO_1:  tdc                             ; Drop the loop parameters
  3092 00:111F: 1A                           inc     a
  3093 00:1120: 1A                           inc     a
  3094 00:1121: 1A                           inc     a
  3095 00:1122: 1A                           inc     a
  3096 00:1123: 5B                           tcd
  3097 00:1124: 4C xx xx                     jmp     BRANCH                  ; And skip over loop
  3098                        
  3099                        ; 2CONSTANT ( x <spaces>name -- )
  3100                        ;
  3101                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3102                        ; definition for name with the execution semantics defined below.
  3103                        
  3104 00:1127: xx xx 00 09                  HEADER  9,"2CONSTANT",NORMAL
       00:112B: 32 43 4F 4E 
       00:112F: 53 54 41 4E 
       00:1133: 54 
  3105 00:1134: 20 xx xx     TWO_CONSTANT:   jsr     DO_COLON
  3106 00:1137: xx xx                        dw      CREATE
  3107 00:1139: xx xx xx xx                  dw      DO_LITERAL,DO_TWO_CONSTANT
  3108 00:113D: xx xx                        dw      BUILD
  3109 00:113F: xx xx                        dw      COMMA
  3110 00:1141: xx xx                        dw      COMMA
  3111 00:1143: xx xx                        dw      EXIT; AGAIN ( -- )
  3112                        
  3113                        DO_TWO_CONSTANT:
  3114 00:1145: FA                           plx                             ; Get return address
  3115 00:1146: 7B                           tdc                             ; Create space on stack
  3116 00:1147: 3A                           dec     a
  3117 00:1148: 3A                           dec     a
  3118 00:1149: 3A                           dec     a
  3119 00:114A: 3A                           dec     a
  3120 00:114B: 5B                           tcd
  3121 00:114C: BD 01 00                     lda     !1,x                    ; Transfer the value
  3122 00:114F: 85 01                        sta     <1
  3123 00:1151: BD 03 00                     lda     !3,x
  3124 00:1154: 85 03                        sta     <3
  3125 00:1156: BB C8 C8 7C                  CONTINUE                        ; Done
       00:115A: 00 00 
  3126                        
  3127                        ; 2LITERAL
  3128                        
  3129 00:115C: xx xx 80 08                  HEADER  8,"2LITERAL",IMMEDIATE
       00:1160: 32 4C 49 54 
       00:1164: 45 52 41 4C 
  3130 00:1168: 20 xx xx     TWO_LITERAL:    jsr     DO_COLON
  Sat May  7 2016 20:07                                                                                                    Page 62


  3131 00:116B: xx xx xx xx                  dw      DO_LITERAL,DO_TWO_LITERAL
  3132 00:116F: xx xx                        dw      COMMA
  3133 00:1171: xx xx                        dw      COMMA
  3134 00:1173: xx xx                        dw      COMMA
  3135 00:1175: xx xx                        dw      EXIT
  3136                        
  3137                        DO_TWO_LITERAL:
  3138 00:1177: 7B                           tdc                             ; Make room on stack
  3139 00:1178: 3A                           dec     a
  3140 00:1179: 3A                           dec     a
  3141 00:117A: 3A                           dec     a
  3142 00:117B: 3A                           dec     a
  3143 00:117C: 5B                           tcd
  3144 00:117D: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3145 00:1180: 85 01                        sta     <1
  3146 00:1182: B9 02 00                     lda     !2,y
  3147 00:1185: 85 03                        sta     <3
  3148 00:1187: C8                           iny                             ; Bump IP
  3149 00:1188: C8                           iny
  3150 00:1189: C8                           iny
  3151 00:118A: C8                           iny
  3152 00:118B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:118F: 00 00 
  3153                        
  3154                        ; 2VARIABLE
  3155                        
  3156 00:1191: xx xx 80 09                  HEADER  9,"2VARIABLE",IMMEDIATE
       00:1195: 32 56 41 52 
       00:1199: 49 41 42 4C 
       00:119D: 45 
  3157 00:119E: 20 xx xx     TWO_VARIABLE:   jsr     DO_COLON
  3158 00:11A1: xx xx                        dw      CREATE
  3159 00:11A3: xx xx xx xx                  dw      DO_LITERAL,DO_VARIABLE
  3160 00:11A7: xx xx                        dw      BUILD
  3161 00:11A9: xx xx 02 00                  dw      DO_LITERAL,2
  3162 00:11AD: xx xx                        dw      CELLS
  3163 00:11AF: xx xx                        dw      ALLOT
  3164 00:11B1: xx xx                        dw      EXIT
  3165                        
  3166                        ; ABORT" ( -- )
  3167                        
  3168 00:11B3: xx xx 80                     LINK    IMMEDIATE
  3169 00:11B6: 06 41 42 4F                  db      6,"ABORT",'"'
       00:11BA: 52 54 22 
  3170 00:11BD: 20 xx xx     ABORT_QUOTE:    jsr     DO_COLON
  3171 00:11C0: xx xx                        dw      S_QUOTE
  3172 00:11C2: xx xx xx xx                  dw      DO_LITERAL,QUERY_ABORT
  3173 00:11C6: xx xx                        dw      COMMA
  3174 00:11C8: xx xx                        dw      EXIT
  3175                        
  3176                        ; AGAIN ( -- )
  3177 00:11CA: xx xx 80 05                  HEADER  5,"AGAIN",IMMEDIATE
       00:11CE: 41 47 41 49 
       00:11D2: 4E 
  3178 00:11D3: 20 xx xx     AGAIN:          jsr     DO_COLON
  3179 00:11D6: xx xx xx xx                  dw      DO_LITERAL,BRANCH
  3180 00:11DA: xx xx                        dw      COMMA
  3181 00:11DC: xx xx                        dw      COMMA
  Sat May  7 2016 20:07                                                                                                    Page 63


  3182 00:11DE: xx xx                        dw      EXIT
  3183                        
  3184                        ; BEGIN ( -- )
  3185                        
  3186 00:11E0: xx xx 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:11E4: 42 45 47 49 
       00:11E8: 4E 
  3187 00:11E9: 20 xx xx     BEGIN:          jsr     DO_COLON
  3188 00:11EC: xx xx                        dw      HERE
  3189 00:11EE: xx xx                        dw      EXIT
  3190                        
  3191                        ; CONSTANT ( x <spaces>name -- )
  3192                        ;
  3193                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3194                        ; definition for name with the execution semantics defined below.
  3195                        
  3196 00:11F0: xx xx 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:11F4: 43 4F 4E 53 
       00:11F8: 54 41 4E 54 
  3197 00:11FC: 20 xx xx     CONSTANT:       jsr     DO_COLON
  3198 00:11FF: xx xx                        dw      CREATE
  3199 00:1201: xx xx xx xx                  dw      DO_LITERAL,DO_CONSTANT
  3200 00:1205: xx xx                        dw      BUILD
  3201 00:1207: xx xx                        dw      COMMA
  3202 00:1209: xx xx                        dw      EXIT
  3203                        
  3204                        DO_CONSTANT:
  3205 00:120B: FA                           plx                             ; Get return address
  3206 00:120C: 7B                           tdc                             ; Create space on stack
  3207 00:120D: 3A                           dec     a
  3208 00:120E: 3A                           dec     a
  3209 00:120F: 5B                           tcd
  3210 00:1210: BD 01 00                     lda     !1,x                    ; Transfer the value
  3211 00:1213: 85 01                        sta     <1
  3212 00:1215: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1219: 00 00 
  3213                        
  3214                        ; DO ( -- )
  3215                        
  3216 00:121B: xx xx 80 02                  HEADER  2,"DO",IMMEDIATE
       00:121F: 44 4F 
  3217 00:1221: 20 xx xx     DO:             jsr     DO_COLON
  3218 00:1224: xx xx xx xx                  dw      DO_LITERAL,DO_DO
  3219 00:1228: xx xx                        dw      COMMA
  3220 00:122A: xx xx                        dw      ZERO
  3221 00:122C: xx xx                        dw      HERE
  3222 00:122E: xx xx                        dw      EXIT
  3223                        
  3224                        DO_DO:
  3225 00:1230: A5 03                        lda     <3
  3226 00:1232: 48                           pha
  3227 00:1233: A5 01                        lda     <1
  3228 00:1235: 48                           pha
  3229 00:1236: 7B                           tdc
  3230 00:1237: 1A                           inc     a
  3231 00:1238: 1A                           inc     a
  3232 00:1239: 1A                           inc     a
  3233 00:123A: 1A                           inc     a
  Sat May  7 2016 20:07                                                                                                    Page 64


  3234 00:123B: 5B                           tcd
  3235 00:123C: BB C8 C8 7C                  CONTINUE
       00:1240: 00 00 
  3236                        
  3237                        ; ELSE ( -- )
  3238                        
  3239 00:1242: xx xx 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:1246: 45 4C 53 45 
  3240 00:124A: 20 xx xx     ELSE:           jsr     DO_COLON
  3241 00:124D: xx xx xx xx                  dw      DO_LITERAL,BRANCH
  3242 00:1251: xx xx                        dw      COMMA
  3243 00:1253: xx xx                        dw      HERE
  3244 00:1255: xx xx                        dw      ZERO
  3245 00:1257: xx xx                        dw      COMMA
  3246 00:1259: xx xx                        dw      HERE
  3247 00:125B: xx xx                        dw      SWAP
  3248 00:125D: xx xx                        dw      STORE
  3249 00:125F: xx xx                        dw      EXIT
  3250                        
  3251                        BRANCH:
  3252 00:1261: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  3253 00:1264: A8                           tay
  3254 00:1265: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1269: 00 00 
  3255                        
  3256                        ; IF ( -- )
  3257                        
  3258 00:126B: xx xx 80 02                  HEADER  2,"IF",IMMEDIATE
       00:126F: 49 46 
  3259 00:1271: 20 xx xx     IF:             jsr     DO_COLON
  3260 00:1274: xx xx xx xx                  dw      DO_LITERAL,QUERY_BRANCH
  3261 00:1278: xx xx                        dw      COMMA
  3262 00:127A: xx xx                        dw      HERE
  3263 00:127C: xx xx                        dw      ZERO
  3264 00:127E: xx xx                        dw      COMMA
  3265 00:1280: xx xx                        dw      EXIT
  3266                        
  3267                        QUERY_BRANCH:
  3268 00:1282: A6 01                        ldx     <1                      ; Pull the top of stack value
  3269 00:1284: 7B                           tdc
  3270 00:1285: 1A                           inc     a                       ; Drop top item
  3271 00:1286: 1A                           inc     a
  3272 00:1287: 5B                           tcd
  3273 00:1288: 8A                           txa
  3274 00:1289: F0 D6                        beq     BRANCH                  ; Branch if top was zero
  3275 00:128B: C8                           iny                             ; Otherwise skip address
  3276 00:128C: C8                           iny
  3277 00:128D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1291: 00 00 
  3278                        
  3279                        ; IMMEDIATE ( -- )
  3280                        
  3281 00:1293: xx xx 80 09                  HEADER  9,"IMMEDIATE",IMMEDIATE
       00:1297: 49 4D 4D 45 
       00:129B: 44 49 41 54 
       00:129F: 45 
  3282 00:12A0: 20 xx xx                     jsr     DO_COLON
  3283 00:12A3: xx xx 80 00                  dw      DO_LITERAL,IMMEDIATE
  Sat May  7 2016 20:07                                                                                                    Page 65


  3284 00:12A7: xx xx                        dw      LATEST
  3285 00:12A9: xx xx                        dw      FETCH
  3286 00:12AB: xx xx                        dw      ONE_MINUS
  3287 00:12AD: xx xx                        dw      C_STORE
  3288 00:12AF: xx xx                        dw      EXIT
  3289                        
  3290                        ; LITERAL ( x -- )
  3291                        ;
  3292                        ; Append the run-time semantics given below to the current definition.
  3293                        
  3294 00:12B1: xx xx 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:12B5: 4C 49 54 45 
       00:12B9: 52 41 4C 
  3295 00:12BC: 20 xx xx     LITERAL:        jsr     DO_COLON
  3296 00:12BF: xx xx xx xx                  dw      DO_LITERAL,DO_LITERAL
  3297 00:12C3: xx xx                        dw      COMMA
  3298 00:12C5: xx xx                        dw      COMMA
  3299 00:12C7: xx xx                        dw      EXIT
  3300                        
  3301                        DO_LITERAL:
  3302 00:12C9: 7B                           tdc                             ; Make room on stack
  3303 00:12CA: 3A                           dec     a
  3304 00:12CB: 3A                           dec     a
  3305 00:12CC: 5B                           tcd
  3306 00:12CD: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3307 00:12D0: 85 01                        sta     <1
  3308 00:12D2: C8                           iny
  3309 00:12D3: C8                           iny
  3310 00:12D4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:12D8: 00 00 
  3311                        
  3312                        ; LOOP
  3313                        
  3314 00:12DA: xx xx 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:12DE: 4C 4F 4F 50 
  3315 00:12E2: 20 xx xx     LOOP:           jsr     DO_COLON
  3316 00:12E5: xx xx xx xx                  dw      DO_LITERAL,DO_LOOP
  3317 00:12E9: xx xx                        dw      COMMA
  3318 00:12EB: xx xx                        dw      COMMA
  3319 00:12ED: xx xx                        dw      QUERY_DUP
  3320 00:12EF: xx xx xx xx                  dw      QUERY_BRANCH,LOOP_1
  3321 00:12F3: xx xx                        dw      HERE
  3322 00:12F5: xx xx                        dw      SWAP
  3323 00:12F7: xx xx                        dw      STORE
  3324 00:12F9: xx xx        LOOP_1:         dw      EXIT
  3325                        
  3326                        ; (LOOP)
  3327                        
  3328                        ;               HEADER  6,"(LOOP)",NORMAL
  3329                        DO_LOOP
  3330 00:12FB: A3 01                        lda     1,s                     ; Add one to loop counter
  3331 00:12FD: 1A                           inc     a
  3332 00:12FE: 83 01                        sta     1,s
  3333 00:1300: C3 03                        cmp     3,s                     ; Reached limit?
  3334 00:1302: B0 0A                        bcs     DO_LOOP_END             ; Yes
  3335 00:1304: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3336 00:1307: A8                           tay
  3337 00:1308: BB C8 C8 7C                  CONTINUE                        ; Done
  Sat May  7 2016 20:07                                                                                                    Page 66


       00:130C: 00 00 
  3338                        
  3339 00:130E: C8           DO_LOOP_END:    iny                             ; Skip over address
  3340 00:130F: C8                           iny
  3341 00:1310: 68                           pla                             ; Drop loop variables
  3342 00:1311: 68                           pla
  3343 00:1312: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1316: 00 00 
  3344                        
  3345                        ; POSTPONE
  3346                        
  3347                        ;   BL WORD FIND
  3348                        ;   DUP 0= ABORT" ?"
  3349                        ;   0< IF   -- xt       non immed: add code to current
  3350                        ;                       def'n to compile xt later.
  3351                        ;       ['] LIT ,XT  ,  add "LIT,xt,COMMAXT"
  3352                        ;       ['] ,XT ,XT     to current definition
  3353                        ;   ELSE  ,XT      immed: compile into cur. def'n
  3354                        ;   THEN ; IMMEDIATE
  3355                        
  3356 00:1318: xx xx 80 08                  HEADER  8,"POSTPONE",IMMEDIATE
       00:131C: 50 4F 53 54 
       00:1320: 50 4F 4E 45 
  3357 00:1324: 20 xx xx     POSTPONE:       jsr     DO_COLON
  3358 00:1327: xx xx                        dw      BL
  3359 00:1329: xx xx                        dw      WORD
  3360 00:132B: xx xx                        dw      FIND
  3361 00:132D: xx xx                        dw      DUP
  3362 00:132F: xx xx                        dw      ZERO_EQUAL
  3363 00:1331: xx xx                        dw      DO_S_QUOTE
  3364 00:1333: 01 3F                        db      1,"?"
  3365 00:1335: xx xx                        dw      QUERY_ABORT
  3366 00:1337: xx xx                        dw      ZERO_LESS
  3367 00:1339: xx xx xx xx                  dw      QUERY_BRANCH,POSTPONE_1
  3368 00:133D: xx xx xx xx                  dw      DO_LITERAL,DO_LITERAL
  3369 00:1341: xx xx                        dw      COMMA
  3370 00:1343: xx xx                        dw      COMMA
  3371 00:1345: xx xx xx xx                  dw      BRANCH,POSTPONE_2
  3372 00:1349: xx xx        POSTPONE_1:     dw      COMMA
  3373 00:134B: xx xx        POSTPONE_2:     dw      EXIT
  3374                        
  3375                        ; RECURSE ( -- )
  3376                        
  3377 00:134D: xx xx 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:1351: 52 45 43 55 
       00:1355: 52 53 45 
  3378 00:1358: 20 xx xx     RECURSE:        jsr     DO_COLON
  3379 00:135B: xx xx                        dw      LATEST
  3380 00:135D: xx xx                        dw      FETCH
  3381 00:135F: xx xx                        dw      NFA_TO_CFA
  3382 00:1361: xx xx                        dw      COMMA
  3383 00:1363: xx xx                        dw      EXIT
  3384                        
  3385                        ; S"
  3386                        
  3387 00:1365: xx xx 80                     LINK    IMMEDIATE
  3388 00:1368: 02 53 22                     db      2,"S",'"'
  3389 00:136B: 20 xx xx     S_QUOTE:        jsr     DO_COLON
  Sat May  7 2016 20:07                                                                                                    Page 67


  3390 00:136E: xx xx xx xx                  dw      DO_LITERAL,DO_S_QUOTE
  3391 00:1372: xx xx                        dw      COMMA
  3392 00:1374: xx xx 22 00                  dw      DO_LITERAL,'"'
  3393 00:1378: xx xx                        dw      WORD
  3394 00:137A: xx xx                        dw      C_FETCH
  3395 00:137C: xx xx                        dw      ONE_PLUS
  3396 00:137E: xx xx                        dw      ALIGNED
  3397 00:1380: xx xx                        dw      ALLOT
  3398 00:1382: xx xx                        dw      EXIT
  3399                        
  3400                        ; (S") ( -- c-addr u )
  3401                        
  3402                        DO_S_QUOTE:
  3403 00:1384: 20 xx xx                     jsr     DO_COLON
  3404 00:1387: xx xx                        dw      R_FROM
  3405 00:1389: xx xx                        dw      COUNT
  3406 00:138B: xx xx                        dw      TWO_DUP
  3407 00:138D: xx xx                        dw      PLUS
  3408 00:138F: xx xx                        dw      ALIGNED
  3409 00:1391: xx xx                        dw      TO_R
  3410 00:1393: xx xx                        dw      EXIT
  3411                        
  3412                        ; THEN ( -- )
  3413                        
  3414 00:1395: xx xx 80 04                  HEADER  4,"THEN",IMMEDIATE
       00:1399: 54 48 45 4E 
  3415 00:139D: 20 xx xx     THEN:           jsr     DO_COLON
  3416 00:13A0: xx xx                        dw      HERE
  3417 00:13A2: xx xx                        dw      SWAP
  3418 00:13A4: xx xx                        dw      STORE
  3419 00:13A6: xx xx                        dw      EXIT
  3420                        
  3421                        ; UNTIL ( -- )
  3422                        
  3423 00:13A8: xx xx 80 05                  HEADER  5,"UNTIL",IMMEDIATE
       00:13AC: 55 4E 54 49 
       00:13B0: 4C 
  3424 00:13B1: 20 xx xx     UNTIL:          jsr     DO_COLON
  3425 00:13B4: xx xx xx xx                  dw      DO_LITERAL,QUERY_BRANCH
  3426 00:13B8: xx xx                        dw      COMMA
  3427 00:13BA: xx xx                        dw      COMMA
  3428 00:13BC: xx xx                        dw      EXIT
  3429                        
  3430                        ; USER
  3431                        
  3432 00:13BE: xx xx 00 04                  HEADER  4,"USER",NORMAL
       00:13C2: 55 53 45 52 
  3433 00:13C6: 20 xx xx     USER:           jsr     DO_COLON
  3434 00:13C9: xx xx                        dw      CREATE
  3435 00:13CB: xx xx xx xx                  dw      DO_LITERAL,DO_USER
  3436 00:13CF: xx xx                        dw      BUILD
  3437 00:13D1: xx xx                        dw      COMMA
  3438 00:13D3: xx xx                        dw      EXIT
  3439                        
  3440 00:13D5: xx xx 00 06                  HEADER  6,"(USER)",NORMAL
       00:13D9: 28 55 53 45 
       00:13DD: 52 29 
  3441                        DO_USER:
  Sat May  7 2016 20:07                                                                                                    Page 68


  3442 00:13DF: 7B                           tdc
  3443 00:13E0: 3A                           dec     a                       ; Push on data stack
  3444 00:13E1: 3A                           dec     a
  3445 00:13E2: 5B                           tcd
  3446 00:13E3: FA                           plx
  3447 00:13E4: 18                           clc
  3448 00:13E5: BD 01 00                     lda     !1,x
  3449 00:13E8: 69 00 00                     adc     #USER_AREA
  3450 00:13EB: 85 01                        sta     <1
  3451 00:13ED: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13F1: 00 00 
  3452                        
  3453                        ; VARIABLE ( <spaces>name -- )
  3454                        ;
  3455                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3456                        ; definition for name with the execution semantics defined below. Reserve one
  3457                        ; cell of data space at an aligned address.
  3458                        
  3459 00:13F3: xx xx 00                     LINK    NORMAL
  3460 00:13F6: 08 56 41 52                  db      8,"VARIABLE"
       00:13FA: 49 41 42 4C 
       00:13FE: 45 
  3461 00:13FF: 20 xx xx     VARIABLE:       jsr     DO_COLON
  3462 00:1402: xx xx                        dw      CREATE
  3463 00:1404: xx xx xx xx                  dw      DO_LITERAL,DO_VARIABLE
  3464 00:1408: xx xx                        dw      BUILD
  3465 00:140A: xx xx 01 00                  dw      DO_LITERAL,1
  3466 00:140E: xx xx                        dw      CELLS
  3467 00:1410: xx xx                        dw      ALLOT
  3468 00:1412: xx xx                        dw      EXIT
  3469                        
  3470                        DO_VARIABLE:
  3471 00:1414: 7B                           tdc
  3472 00:1415: 3A                           dec     a
  3473 00:1416: 3A                           dec     a
  3474 00:1417: 5B                           tcd
  3475 00:1418: 68                           pla
  3476 00:1419: 1A                           inc     a
  3477 00:141A: 85 01                        sta     <1
  3478 00:141C: BB C8 C8 7C                  CONTINUE
       00:1420: 00 00 
  3479                        
  3480                        ; WORDS ( -- )
  3481                        ;
  3482                        ;   LATEST @ BEGIN
  3483                        ;       DUP COUNT TYPE SPACE
  3484                        ;       NFA>LFA @
  3485                        ;   DUP 0= UNTIL
  3486                        ;   DROP ;
  3487                        
  3488 00:1422: xx xx 00 05                  HEADER  5,"WORDS",NORMAL
       00:1426: 57 4F 52 44 
       00:142A: 53 
  3489 00:142B: 20 xx xx                     jsr     DO_COLON
  3490 00:142E: xx xx                        dw      LATEST
  3491 00:1430: xx xx                        dw      FETCH
  3492 00:1432: xx xx        WORDS_1:        dw      DUP
  3493 00:1434: xx xx                        dw      COUNT
  Sat May  7 2016 20:07                                                                                                    Page 69


  3494 00:1436: xx xx                        dw      TYPE
  3495 00:1438: xx xx                        dw      SPACE
  3496 00:143A: xx xx                        dw      NFA_TO_LFA
  3497 00:143C: xx xx                        dw      FETCH
  3498 00:143E: xx xx                        dw      DUP
  3499 00:1440: xx xx                        dw      ZERO_EQUAL
  3500 00:1442: xx xx xx xx                  dw      QUERY_BRANCH,WORDS_1
  3501 00:1446: xx xx                        dw      DROP
  3502 00:1448: xx xx                        dw      EXIT
  3503                        
  3504                        ; [
  3505                        ;
  3506                        ; In this implementation it is defined as
  3507                        ;
  3508                        ;   0 STATE !
  3509                        
  3510 00:144A: xx xx 80 01                  HEADER  1,"[",IMMEDIATE
       00:144E: 5B 
  3511 00:144F: 20 xx xx     LEFT_BRACKET:   jsr     DO_COLON
  3512 00:1452: xx xx                        dw      ZERO
  3513 00:1454: xx xx                        dw      STATE
  3514 00:1456: xx xx                        dw      STORE
  3515 00:1458: xx xx                        dw      EXIT
  3516                        
  3517                        ; \ ( -- )
  3518                        ;
  3519                        ; Parse and discard the remainder of the parse area. \ is an immediate word.
  3520                        ;
  3521                        ; In this implementation it is defined as
  3522                        ;
  3523                        ;   1 WORD DROP
  3524                        
  3525 00:145A: xx xx 80 01                  HEADER  1,"\",IMMEDIATE
       00:145E: 5C 
  3526 00:145F: 20 xx xx     BACKSLASH:      jsr     DO_COLON
  3527 00:1462: xx xx 01 00                  dw      DO_LITERAL,1
  3528 00:1466: xx xx                        dw      WORD
  3529 00:1468: xx xx                        dw      DROP
  3530 00:146A: xx xx                        dw      EXIT
  3531                        
  3532                        ; ]
  3533                        ;
  3534                        ; In this implementation it is defined as
  3535                        ;
  3536                        ;   -1 STATE !
  3537                        
  3538 00:146C: xx xx 00 01                  HEADER  1,"]",NORMAL
       00:1470: 5D 
  3539 00:1471: 20 xx xx     RIGHT_BRACKET:  jsr     DO_COLON
  3540 00:1474: xx xx FF FF                  dw      DO_LITERAL,-1
  3541 00:1478: xx xx                        dw      STATE
  3542 00:147A: xx xx                        dw      STORE
  3543 00:147C: xx xx                        dw      EXIT
  3544                        
  3545                        ;===============================================================================
  3546                        ; I/O Operations
  3547                        ;-------------------------------------------------------------------------------
  3548                        
  Sat May  7 2016 20:07                                                                                                    Page 70


  3549                        ; CR ( -- )
  3550                        ;
  3551                        ; Cause subsequent output to appear at the beginning of the next line.
  3552                        ;
  3553                        ; In this implementation it is defined as
  3554                        ;
  3555                        ;   13 EMIT 10 EMIT
  3556                        
  3557 00:147E: xx xx 00 02                  HEADER  2,"CR",NORMAL
       00:1482: 43 52 
  3558 00:1484: 20 xx xx     CR:             jsr     DO_COLON
  3559 00:1487: xx xx 0D 00                  dw      DO_LITERAL,13
  3560 00:148B: xx xx                        dw      EMIT
  3561 00:148D: xx xx 0A 00                  dw      DO_LITERAL,10
  3562 00:1491: xx xx                        dw      EMIT
  3563 00:1493: xx xx                        dw      EXIT
  3564                        
  3565                        ; EMIT ( x -- )
  3566                        ;
  3567                        ; If x is a graphic character in the implementation-defined character set,
  3568                        ; display x. The effect of EMIT for all other values of x is implementation
  3569                        ; -defined.
  3570                        
  3571 00:1495: xx xx 00 04                  HEADER  4,"EMIT",NORMAL
       00:1499: 45 4D 49 54 
  3572                                        extern  UartTx
  3573                        EMIT:
  3574 00:149D: A5 01                        lda     <1                      ; Fetch character from stack
  3575 00:149F: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  3576 00:14A2: 7B                           tdc
  3577 00:14A3: 1A                           inc     a                       ; Drop the character
  3578 00:14A4: 1A                           inc     a
  3579 00:14A5: 5B                           tcd
  3580 00:14A6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14AA: 00 00 
  3581                        
  3582                        ; KEY ( -- char )
  3583                        ;
  3584                        ; Receive one character char, a member of the implementation-defined character
  3585                        ; set. Keyboard events that do not correspond to such characters are discarded
  3586                        ; until a valid character is received, and those events are subsequently
  3587                        ; unavailable.
  3588                        ;
  3589                        ; All standard characters can be received. Characters received by KEY are not
  3590                        ; displayed.
  3591                        
  3592 00:14AC: xx xx 00 03                  HEADER  3,"KEY",NORMAL
       00:14B0: 4B 45 59 
  3593                                        extern  UartRx
  3594                        KEY:
  3595 00:14B3: 20 xx xx                     jsr     UartRx                  ; Receive a character
  3596 00:14B6: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  3597 00:14B9: AA                           tax
  3598 00:14BA: 7B                           tdc
  3599 00:14BB: 3A                           dec     a                       ; And push to stack
  3600 00:14BC: 3A                           dec     a
  3601 00:14BD: 5B                           tcd
  3602 00:14BE: 86 01                        stx     <1
  Sat May  7 2016 20:07                                                                                                    Page 71


  3603 00:14C0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14C4: 00 00 
  3604                        
  3605                        ; SPACE ( -- )
  3606                        ;
  3607                        ; Display one space.
  3608                        ;
  3609                        ; In this implementation it is defined as
  3610                        ;
  3611                        ;   BL EMIT
  3612                        
  3613 00:14C6: xx xx 00 05                  HEADER  5,"SPACE",NORMAL
       00:14CA: 53 50 41 43 
       00:14CE: 45 
  3614 00:14CF: 20 xx xx     SPACE:          jsr     DO_COLON
  3615 00:14D2: xx xx                        dw      BL
  3616 00:14D4: xx xx                        dw      EMIT
  3617 00:14D6: xx xx                        dw      EXIT
  3618                        
  3619                        ; SPACES ( n -- )
  3620                        ;
  3621                        ; If n is greater than zero, display n spaces.
  3622                        ;
  3623                        ; In this implementation it is defined as
  3624                        ;
  3625                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  3626                        
  3627 00:14D8: xx xx 00 06                  HEADER  6,"SPACES",NORMAL
       00:14DC: 53 50 41 43 
       00:14E0: 45 53 
  3628 00:14E2: 20 xx xx     SPACES:         jsr     DO_COLON
  3629 00:14E5: xx xx        SPACES_1:       dw      DUP
  3630 00:14E7: xx xx                        dw      ZERO_GREATER
  3631 00:14E9: xx xx xx xx                  dw      QUERY_BRANCH,SPACES_2
  3632 00:14ED: xx xx                        dw      SPACE
  3633 00:14EF: xx xx                        dw      ONE_MINUS
  3634 00:14F1: xx xx xx xx                  dw      BRANCH,SPACES_1
  3635 00:14F5: xx xx        SPACES_2:       dw      DROP
  3636 00:14F7: xx xx                        dw      EXIT
  3637                        
  3638                        ; TYPE ( c-addr u -- )
  3639                        ;
  3640                        ; If u is greater than zero, display the character string specified by c-addr
  3641                        ; and u.
  3642                        ;
  3643                        ; In this implementation it is defined as
  3644                        ;
  3645                        ;   ?DUP IF
  3646                        ;     OVER + SWAP DO I C@ EMIT LOOP
  3647                        ;   ELSE DROP THEN
  3648                        
  3649 00:14F9: xx xx 00 04                  HEADER  4,"TYPE",NORMAL
       00:14FD: 54 59 50 45 
  3650 00:1501: 20 xx xx     TYPE:           jsr     DO_COLON
  3651 00:1504: xx xx                        dw      QUERY_DUP
  3652 00:1506: xx xx xx xx                  dw      QUERY_BRANCH,TYPE_2
  3653 00:150A: xx xx                        dw      OVER
  3654 00:150C: xx xx                        dw      PLUS
  Sat May  7 2016 20:07                                                                                                    Page 72


  3655 00:150E: xx xx                        dw      SWAP
  3656 00:1510: xx xx                        dw      DO_DO
  3657 00:1512: xx xx        TYPE_1:         dw      I
  3658 00:1514: xx xx                        dw      C_FETCH
  3659 00:1516: xx xx                        dw      EMIT
  3660 00:1518: xx xx xx xx                  dw      DO_LOOP,TYPE_1
  3661 00:151C: xx xx xx xx                  dw      BRANCH,TYPE_3
  3662 00:1520: xx xx        TYPE_2          dw      DROP
  3663 00:1522: xx xx        TYPE_3          dw      EXIT
  3664                        
  3665                        ;===============================================================================
  3666                        ; Formatted Output
  3667                        ;-------------------------------------------------------------------------------
  3668                        
  3669                        ; # ( ud1 -- ud2 )
  3670                        ;
  3671                        ; Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
  3672                        ; (n is the least-significant digit of ud1.) Convert n to external form and add
  3673                        ; the resulting character to the beginning of the pictured numeric output string.
  3674                        ; An ambiguous condition exists if # executes outside of a <# #> delimited
  3675                        ; number conversion.
  3676                        ;
  3677                        ;       BASE @ >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ROT DUP 9 > 7 AND + 30 + HOLD
  3678                        
  3679 00:1524: xx xx 00 01                  HEADER  1,"#",NORMAL
       00:1528: 23 
  3680 00:1529: 20 xx xx     HASH:           jsr     DO_COLON
  3681 00:152C: xx xx                        dw      BASE
  3682 00:152E: xx xx                        dw      FETCH
  3683 00:1530: xx xx                        dw      TO_R
  3684 00:1532: xx xx                        dw      ZERO
  3685 00:1534: xx xx                        dw      R_FETCH
  3686 00:1536: xx xx                        dw      UM_SLASH_MOD
  3687 00:1538: xx xx                        dw      ROT
  3688 00:153A: xx xx                        dw      ROT
  3689 00:153C: xx xx                        dw      R_FROM
  3690 00:153E: xx xx                        dw      UM_SLASH_MOD
  3691 00:1540: xx xx                        dw      ROT
  3692 00:1542: xx xx                        dw      ROT
  3693 00:1544: xx xx                        dw      DUP
  3694 00:1546: xx xx 09 00                  dw      DO_LITERAL,9
  3695 00:154A: xx xx                        dw      GREATER
  3696 00:154C: xx xx 07 00                  dw      DO_LITERAL,7
  3697 00:1550: xx xx                        dw      AND
  3698 00:1552: xx xx                        dw      PLUS
  3699 00:1554: xx xx 30 00                  dw      DO_LITERAL,'0'
  3700 00:1558: xx xx                        dw      PLUS
  3701 00:155A: xx xx                        dw      HOLD
  3702 00:155C: xx xx                        dw      EXIT
  3703                        
  3704                        ; #> ( xd -- c-addr u )
  3705                        ;
  3706                        ; Drop xd. Make the pictured numeric output string available as a character
  3707                        ; string. c-addr and u specify the resulting character string. A program may
  3708                        ; replace characters within the string.
  3709                        ;
  3710                        ;       2DROP HP @ PAD OVER -
  3711                        
  Sat May  7 2016 20:07                                                                                                    Page 73


  3712 00:155E: xx xx 00 02                  HEADER  2,"#>",NORMAL
       00:1562: 23 3E 
  3713 00:1564: 20 xx xx     HASH_GREATER:   jsr     DO_COLON
  3714 00:1567: xx xx                        dw      TWO_DROP
  3715 00:1569: xx xx                        dw      HP
  3716 00:156B: xx xx                        dw      FETCH
  3717 00:156D: xx xx                        dw      PAD
  3718 00:156F: xx xx                        dw      OVER
  3719 00:1571: xx xx                        dw      MINUS
  3720 00:1573: xx xx                        dw      EXIT
  3721                        
  3722                        ; #S ( ud1 -- ud2 )
  3723                        ;
  3724                        ; Convert one digit of ud1 according to the rule for #. Continue conversion
  3725                        ; until the quotient is zero. ud2 is zero. An ambiguous condition exists if #S
  3726                        ; executes outside of a <# #> delimited number conversion.
  3727                        ;
  3728                        ;       BEGIN # 2DUP OR 0= UNTIL
  3729                        
  3730 00:1575: xx xx 00 02                  HEADER  2,"#S",NORMAL
       00:1579: 23 53 
  3731 00:157B: 20 xx xx     HASH_S:         jsr     DO_COLON
  3732 00:157E: xx xx        HASH_S_1:       dw      HASH
  3733 00:1580: xx xx                        dw      TWO_DUP
  3734 00:1582: xx xx                        dw      OR
  3735 00:1584: xx xx                        dw      ZERO_EQUAL
  3736 00:1586: xx xx xx xx                  dw      QUERY_BRANCH,HASH_S_1
  3737 00:158A: xx xx                        dw      EXIT
  3738                        
  3739                        ; . ( n -- )
  3740                        ;
  3741                        ; Display n in free field format.
  3742                        ;
  3743                        ;       <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE
  3744                        
  3745 00:158C: xx xx 00 01                  HEADER  1,".",NORMAL
       00:1590: 2E 
  3746 00:1591: 20 xx xx     DOT:            jsr     DO_COLON
  3747 00:1594: xx xx                        dw      LESS_HASH
  3748 00:1596: xx xx                        dw      DUP
  3749 00:1598: xx xx                        dw      ABS
  3750 00:159A: xx xx                        dw      ZERO
  3751 00:159C: xx xx                        dw      HASH_S
  3752 00:159E: xx xx                        dw      ROT
  3753 00:15A0: xx xx                        dw      SIGN
  3754 00:15A2: xx xx                        dw      HASH_GREATER
  3755 00:15A4: xx xx                        dw      TYPE
  3756 00:15A6: xx xx                        dw      SPACE
  3757 00:15A8: xx xx                        dw      EXIT
  3758                        
  3759                        ; <# ( -- )
  3760                        ;
  3761                        ; Initialize the pictured numeric output conversion process.
  3762                        ;
  3763                        ;       PAD HP !
  3764                        
  3765 00:15AA: xx xx 00 02                  HEADER  2,"<#",NORMAL
       00:15AE: 3C 23 
  Sat May  7 2016 20:07                                                                                                    Page 74


  3766 00:15B0: 20 xx xx     LESS_HASH:      jsr     DO_COLON
  3767 00:15B3: xx xx                        dw      PAD
  3768 00:15B5: xx xx                        dw      HP
  3769 00:15B7: xx xx                        dw      STORE
  3770 00:15B9: xx xx                        dw      EXIT
  3771                        
  3772                        ; HOLD ( char -- )
  3773                        
  3774                        ; Add char to the beginning of the pictured numeric output string. An
  3775                        ; ambiguous condition exists if HOLD executes outside of a <# #> delimited
  3776                        ; number conversion.
  3777                        ;
  3778                        ;       -1 HP +!  HP @ C!
  3779                        
  3780 00:15BB: xx xx 00 04                  HEADER  4,"HOLD",NORMAL
       00:15BF: 48 4F 4C 44 
  3781 00:15C3: 20 xx xx     HOLD:           jsr     DO_COLON
  3782 00:15C6: xx xx FF FF                  dw      DO_LITERAL,-1
  3783 00:15CA: xx xx                        dw      HP
  3784 00:15CC: xx xx                        dw      PLUS_STORE
  3785 00:15CE: xx xx                        dw      HP
  3786 00:15D0: xx xx                        dw      FETCH
  3787 00:15D2: xx xx                        dw      C_STORE
  3788 00:15D4: xx xx                        dw      EXIT
  3789                        
  3790                        ; PAD ( -- c-addr )
  3791                        ;
  3792                        ; c-addr is the address of a transient region that can be used to hold data
  3793                        ; for intermediate processing.
  3794                        
  3795 00:15D6: xx xx 00 03                  HEADER  3,"PAD",NORMAL
       00:15DA: 50 41 44 
  3796 00:15DD: 20 xx xx     PAD:            jsr     DO_CONSTANT
  3797 00:15E0: C6 00                        dw      PAD_END
  3798                        
  3799                        ; SIGN ( n -- )
  3800                        ;
  3801                        ; If n is negative, add a minus sign to the beginning of the pictured numeric
  3802                        ; output string. An ambiguous condition exists if SIGN executes outside of a
  3803                        ; <# #> delimited number conversion.
  3804                        ;
  3805                        ;       [ HEX ] 0< IF 2D HOLD THEN
  3806                        
  3807 00:15E2: xx xx 00 04                  HEADER  4,"SIGN",NORMAL
       00:15E6: 53 49 47 4E 
  3808 00:15EA: 20 xx xx     SIGN:           jsr     DO_COLON
  3809 00:15ED: xx xx                        dw      ZERO_LESS
  3810 00:15EF: xx xx xx xx                  dw      QUERY_BRANCH,SIGN_1
  3811 00:15F3: xx xx 2D 00                  dw      DO_LITERAL,'-'
  3812 00:15F7: xx xx                        dw      HOLD
  3813 00:15F9: xx xx        SIGN_1:         dw      EXIT
  3814                        
  3815                        ; U. ( u -- )
  3816                        ;
  3817                        ; Display u in free field format.
  3818                        ;
  3819                        ;  <# 0 #S #> TYPE SPACE
  3820                        
  Sat May  7 2016 20:07                                                                                                    Page 75


  3821 00:15FB: xx xx 00 02                  HEADER  2,"U.",NORMAL
       00:15FF: 55 2E 
  3822 00:1601: 20 xx xx     U_DOT:          jsr     DO_COLON
  3823 00:1604: xx xx                        dw      LESS_HASH
  3824 00:1606: xx xx                        dw      ZERO
  3825 00:1608: xx xx                        dw      HASH_S
  3826 00:160A: xx xx                        dw      HASH_GREATER
  3827 00:160C: xx xx                        dw      TYPE
  3828 00:160E: xx xx                        dw      SPACE
  3829 00:1610: xx xx                        dw      EXIT
  3830                        
  3831                        ;===============================================================================
  3832                        ; Programming Tools
  3833                        ;-------------------------------------------------------------------------------
  3834                        
  3835                        ; .NYBBLE ( n -- )
  3836                        ;
  3837                        ; Print the least significant nybble of the top value on the stack in hex.
  3838                        
  3839                        ;               HEADER  7,".NYBBLE",NORMAL
  3840                        DOT_NYBBLE:
  3841 00:1612: A5 01                        lda     <1
  3842 00:1614: 29 0F 00                     and     #$000f
  3843 00:1617: 09 30 00                     ora     #$0030
  3844 00:161A: C9 3A 00                     cmp     #$003a
  3845 00:161D: 90 03                        bcc     $+5
  3846 00:161F: 69 06 00                     adc     #$0006
  3847 00:1622: 20 xx xx                     jsr     UartTx
  3848 00:1625: 4C xx xx                     jmp     DROP
  3849                        
  3850                        ; .BYTE ( n -- )
  3851                        ;
  3852                        ; Print least significant byte of top value on the stack in hex followed by
  3853                        ; a space.
  3854                        
  3855 00:1628: xx xx 00 05                  HEADER  5,".BYTE",NORMAL
       00:162C: 2E 42 59 54 
       00:1630: 45 
  3856 00:1631: 20 xx xx     DOT_BYTE:       jsr     DO_COLON
  3857 00:1634: xx xx                        dw      DUP
  3858 00:1636: xx xx 04 00                  dw      DO_LITERAL,4
  3859 00:163A: xx xx                        dw      RSHIFT
  3860 00:163C: xx xx                        dw      DOT_NYBBLE
  3861 00:163E: xx xx                        dw      DOT_NYBBLE
  3862 00:1640: xx xx                        dw      SPACE
  3863 00:1642: xx xx                        dw      EXIT
  3864                        
  3865                        ; .WORD ( n -- )
  3866                        ;
  3867                        ; Print the top value on the stack in hex followed by a space.
  3868                        
  3869 00:1644: xx xx 00 05                  HEADER  5,".WORD",NORMAL
       00:1648: 2E 57 4F 52 
       00:164C: 44 
  3870 00:164D: 20 xx xx     DOT_WORD:       jsr     DO_COLON
  3871 00:1650: xx xx                        dw      DUP
  3872 00:1652: xx xx 0C 00                  dw      DO_LITERAL,12
  3873 00:1656: xx xx                        dw      RSHIFT
  Sat May  7 2016 20:07                                                                                                    Page 76


  3874 00:1658: xx xx                        dw      DOT_NYBBLE
  3875 00:165A: xx xx                        dw      DUP
  3876 00:165C: xx xx 08 00                  dw      DO_LITERAL,8
  3877 00:1660: xx xx                        dw      RSHIFT
  3878 00:1662: xx xx                        dw      DOT_NYBBLE
  3879 00:1664: xx xx                        dw      DUP
  3880 00:1666: xx xx 04 00                  dw      DO_LITERAL,4
  3881 00:166A: xx xx                        dw      RSHIFT
  3882 00:166C: xx xx                        dw      DOT_NYBBLE
  3883 00:166E: xx xx                        dw      DOT_NYBBLE
  3884 00:1670: xx xx                        dw      SPACE
  3885 00:1672: xx xx                        dw      EXIT
  3886                        
  3887                        ; .DP
  3888                        
  3889 00:1674: xx xx 00 03                  HEADER  3,".DP",NORMAL
       00:1678: 2E 44 50 
  3890 00:167B: 20 xx xx                     jsr     DO_COLON
  3891 00:167E: xx xx                        dw      AT_DP
  3892 00:1680: xx xx                        dw      DOT_WORD
  3893 00:1682: xx xx                        dw      EXIT
  3894                        
  3895 00:1684: xx xx 00 03                  HEADER  3,".RP",NORMAL
       00:1688: 2E 52 50 
  3896 00:168B: 20 xx xx                     jsr     DO_COLON
  3897 00:168E: xx xx                        dw      AT_RP
  3898 00:1690: xx xx                        dw      DOT_WORD
  3899 00:1692: xx xx                        dw      EXIT
  3900                        
  3901                        ; .S ( -- )
  3902                        ;
  3903                        ; Copy and display the values currently on the data stack. The format of the
  3904                        ; display is implementation-dependent.
  3905                        
  3906 00:1694: xx xx 00 02                  HEADER  2,".S",NORMAL
       00:1698: 2E 53 
  3907 00:169A: 20 xx xx                     jsr     DO_COLON
  3908 00:169D: xx xx 7B 00                  dw      DO_LITERAL,'{'
  3909 00:16A1: xx xx                        dw      EMIT
  3910 00:16A3: xx xx                        dw      SPACE
  3911 00:16A5: xx xx                        dw      AT_DP
  3912 00:16A7: xx xx                        dw      ONE_PLUS
  3913 00:16A9: xx xx 80 01                  dw      DO_LITERAL,DSTACK_END
  3914 00:16AD: xx xx                        dw      SWAP
  3915 00:16AF: xx xx xx xx                  dw      QUERY_DO_DO,DOT_S_2
  3916 00:16B3: xx xx        DOT_S_1:        dw      I
  3917 00:16B5: xx xx                        dw      FETCH
  3918 00:16B7: xx xx                        dw      DOT_WORD
  3919 00:16B9: xx xx 02 00                  dw      DO_LITERAL,2
  3920 00:16BD: xx xx                        dw      DO_PLUS_LOOP
  3921 00:16BF: xx xx                        dw      DOT_S_1
  3922 00:16C1: xx xx 7D 00  DOT_S_2:        dw      DO_LITERAL,'}'
  3923 00:16C5: xx xx                        dw      EMIT
  3924 00:16C7: xx xx                        dw      SPACE
  3925 00:16C9: xx xx                        dw      EXIT
  3926                        
  3927                        ; ? ( a-addr -- )
  3928                        ;
  Sat May  7 2016 20:07                                                                                                    Page 77


  3929                        ; Display the value stored at a-addr.
  3930                        
  3931 00:16CB: xx xx 00 01                  HEADER  1,"?",NORMAL
       00:16CF: 3F 
  3932 00:16D0: 20 xx xx                     jsr     DO_COLON
  3933 00:16D3: xx xx                        dw      FETCH
  3934 00:16D5: xx xx                        dw      DOT_WORD
  3935 00:16D7: xx xx                        dw      EXIT
  3936                        
  3937 00:16D9: xx xx 00 03                  HEADER  3,"@DP",NORMAL
       00:16DD: 40 44 50 
  3938                        AT_DP:
  3939 00:16E0: 0B                           phd
  3940 00:16E1: 7B                           tdc
  3941 00:16E2: 3A                           dec     a
  3942 00:16E3: 3A                           dec     a
  3943 00:16E4: 5B                           tcd
  3944 00:16E5: 68                           pla
  3945 00:16E6: 85 01                        sta     <1
  3946 00:16E8: BB C8 C8 7C                  CONTINUE
       00:16EC: 00 00 
  3947                        
  3948 00:16EE: xx xx 00 03                  HEADER  3,"@RP",NORMAL
       00:16F2: 40 52 50 
  3949                        AT_RP:
  3950 00:16F5: 7B                           tdc
  3951 00:16F6: 3A                           dec     a
  3952 00:16F7: 3A                           dec     a
  3953 00:16F8: 5B                           tcd
  3954 00:16F9: BA                           tsx
  3955 00:16FA: 86 01                        stx     <1
  3956 00:16FC: BB C8 C8 7C                  CONTINUE
       00:1700: 00 00 
  3957                        
  3958                        
  3959                        ;-------------------------------------------------------------------------------
  3960                        
  3961                                        include "device.asm"
     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _ ____   __  ____
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )___ \ / /_| ___|
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/  __) | '_ \___ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |    / __/| (_) |__) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|   |_____|\___/____/
     7                        ;
     8                        ; Device Specific Words for the W65C265SXB
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
  Sat May  7 2016 20:07                                                                                                    Page 78


    21                        ;
    22                        ;------------------------------------------------------------------------------
    23                        
    24                        		include	"w65c265.inc"
     1                        ;===============================================================================
     2                        ; __        ____  ____   ____ ____   __  ____
     3                        ; \ \      / / /_| ___| / ___|___ \ / /_| ___|
     4                        ;  \ \ /\ / / '_ \___ \| |     __) | '_ \___ \
     5                        ;   \ V  V /| (_) |__) | |___ / __/| (_) |__) |
     6                        ;    \_/\_/  \___/____/ \____|_____|\___/____/
     7                        ;
     8                        ; Western Design Center W65C265 device definitions
     9                        ;-------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C265 microcontroller.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;===============================================================================
    33                        ; Hardware Registers
    34                        ;-------------------------------------------------------------------------------
    35                        
    36                        ;00DF00-1F CS0 Port Replacement & Expansion uninitialized
    37                        
    38             0000DF00   PD0             equ     $00DF00         ; Port 0 Data Register
    39             0000DF01   PD1             equ     $00DF01         ; Port 1 Data Register
    40             0000DF02   PD2             equ     $00DF02         ; Port 2 Data Register
    41             0000DF03   PD3             equ     $00DF03         ; Port 3 Data Register
    42             0000DF04   PDD0            equ     $00DF04         ; Port 0 Data Direction Register
    43             0000DF05   PDD1            equ     $00DF05         ; Port 1 Data Direction Register
    44             0000DF06   PDD2            equ     $00DF06         ; Port 2 Data Direction Register
    45             0000DF07   PDD3            equ     $00DF07         ; Port 3 Data Direction Register
    46                        
    47             0000DF20   PD4             equ     $00DF20         ; Port 4 Data Register
    48             0000DF21   PD5             equ     $00DF21         ; Port 5 Data Register
    49             0000DF22   PD6             equ     $00DF22         ; Port 6 Data Register
    50             0000DF23   PD7             equ     $00DF23         ; Port 7 Data Register
    51             0000DF24   PDD4            equ     $00DF24         ; Port 4 Data Direction Register
    52             0000DF25   PDD5            equ     $00DF25         ; Port 5 Data Direction Register
    53             0000DF26   PDD6            equ     $00DF26         ; Port 6 Data Direction Register
    54             0000DF27   PCS7            equ     $00DF27         ; Port 7 Chip Select
  Sat May  7 2016 20:07                                                                                                    Page 79


    55                        
    56                        ;00DF28-3F --- Reserved uninitialized
    57                        
    58             0000DF40   BCR             equ     $00DF40         ; Bus Control Register
    59             0000DF41   SSCR            equ     $00DF41         ; System Speed Control Register
    60             0000DF42   TCR             equ     $00DF42         ; Timer Control Register
    61             0000DF43   TER             equ     $00DF43         ; Timer Enable Register
    62             0000DF44   TIFR            equ     $00DF44         ; Timer Interrupt Flag Register
    63             0000DF45   EIFR            equ     $00DF45         ; Edge Interrupt Flag Register
    64             0000DF46   TIER            equ     $00DF46         ; Timer Interrupt Enable Register
    65             0000DF47   EIER            equ     $00DF47         ; Edge Interrupt Enable Register
    66             0000DF48   UIFR            equ     $00DF48         ; UART Interrupt Flag Register
    67             0000DF49   UIER            equ     $00DF49         ; UART Interrupt Enable Register
    68                        
    69             0000DF50   T0LL            equ     $00DF50         ; Timer 0 Latch Low
    70             0000DF51   T0LH            equ     $00DF51         ; Timer 0 Latch High
    71             0000DF52   T1LL            equ     $00DF52         ; Timer 1 Latch Low
    72             0000DF53   T1LH            equ     $00DF53         ; Timer 1 Latch High
    73             0000DF54   T2LL            equ     $00DF54         ; Timer 2 Latch Low
    74             0000DF55   T2LH            equ     $00DF55         ; Timer 2 Latch High
    75             0000DF56   T3LL            equ     $00DF56         ; Timer 3 Latch Low
    76             0000DF57   T3LH            equ     $00DF57         ; Timer 3 Latch High
    77             0000DF58   T4LL            equ     $00DF58         ; Timer 4 Latch Low
    78             0000DF59   T4LH            equ     $00DF59         ; Timer 4 Latch High
    79             0000DF5A   T5LL            equ     $00DF5A         ; Timer 5 Latch Low
    80             0000DF5B   T5LH            equ     $00DF5B         ; Timer 5 Latch High
    81             0000DF5C   T6LL            equ     $00DF5C         ; Timer 6 Latch Low
    82             0000DF5D   T6LH            equ     $00DF5D         ; Timer 6 Latch High
    83             0000DF5E   T7LL            equ     $00DF5E         ; Timer 7 Latch Low
    84             0000DF5F   T7LH            equ     $00DF5F         ; Timer 7 Latch High
    85             0000DF60   T0CL            equ     $00DF60         ; Timer 0 Counter Low
    86             0000DF61   T0CH            equ     $00DF61         ; Timer 0 Counter High
    87             0000DF62   T1CL            equ     $00DF62         ; Timer 1 Counter Low
    88             0000DF63   T1CH            equ     $00DF63         ; Timer 1 Counter High
    89             0000DF64   T2CL            equ     $00DF64         ; Timer 2 Counter Low
    90             0000DF65   T2CH            equ     $00DF65         ; Timer 2 Counter High
    91             0000DF66   T3CL            equ     $00DF66         ; Timer 3 Counter Low
    92             0000DF67   T3CH            equ     $00DF67         ; Timer 3 Counter High
    93             0000DF68   T4CL            equ     $00DF68         ; Timer 4 Counter Low
    94             0000DF69   T4CH            equ     $00DF69         ; Timer 4 Counter High
    95             0000DF6A   T5CL            equ     $00DF6A         ; Timer 5 Counter Low
    96             0000DF6B   T5CH            equ     $00DF6B         ; Timer 5 Counter High
    97             0000DF6C   T6CL            equ     $00DF6C         ; Timer 6 Counter Low
    98             0000DF6D   T6CH            equ     $00DF6D         ; Timer 6 Counter High
    99             0000DF6E   T7CL            equ     $00DF6E         ; Timer 7 Counter Low
   100             0000DF6F   T7CH            equ     $00DF6F         ; Timer 7 Counter High
   101                        
   102                        ;00DFC0-FF CS1 COProcessor Expansion uninitialized
   103                        
   104             0000DF70   ACSR0           equ     $00DF70         ; UART 0 Control/Status Register
   105             0000DF71   ARTD0           equ     $00DF71         ; UART 0 Data Register
   106             0000DF72   ACSR1           equ     $00DF72         ; UART 1 Control/Status Register
   107             0000DF73   ARTD1           equ     $00DF73         ; UART 1 Data Register
   108             0000DF74   ACSR2           equ     $00DF74         ; UART 2 Control/Status Register
   109             0000DF75   ARTD2           equ     $00DF75         ; UART 2 Data Register
   110             0000DF76   ACSR3           equ     $00DF76         ; UART 3 Control/Status Register
   111             0000DF77   ARTD3           equ     $00DF77         ; UART 3 Data Register
   112             0000DF78   PIBFR           equ     $00DF78         ; Parallel Interface Flag Register
  Sat May  7 2016 20:07                                                                                                    Page 80


   113             0000DF79   PIBER           equ     $00DF79         ; Parallel Interface Enable Register
   114             0000DF7A   PIR2            equ     $00DF7A         ; Parallel Interface Register 2
   115             0000DF7B   PIR3            equ     $00DF7B         ; Parallel Interface Register 3
   116             0000DF7C   PIR4            equ     $00DF7C         ; Parallel Interface Register 4
   117             0000DF7D   PIR5            equ     $00DF7D         ; Parallel Interface Register 5
   118             0000DF7E   PIR6            equ     $00DF7E         ; Parallel Interface Register 6
   119             0000DF7F   PIR7            equ     $00DF7F         ; Parallel Interface Register 7
   120                        
   121                        ;00DF80-BF RAM RAM Registers uninitialized
    25                        
    26                        ; (TITLE) - ( -- )
    27                        ;
    28                        
    29                        ;               HEADER  7,"(TITLE)",NORMAL
    30 00:1702: 20 xx xx     DO_TITLE:       jsr     DO_COLON
    31 00:1705: xx xx                        dw      DO_S_QUOTE
    32 00:1707: 1C 57 36 35                  db      28,"W65C265SXB ANS-Forth [16.05]"
       00:170B: 43 32 36 35 
       00:170F: 53 58 42 20 
       00:1713: 41 4E 53 2D 
       00:1717: 46 6F 72 74 
       00:171B: 68 20 5B 31 
       00:171F: 36 2E 30 35 
       00:1723: 5D 
    33 00:1724: xx xx                        dw      EXIT
    34                        
    35                        ; BYE ( -- )
    36                        ;
    37                        ; Return control to the host operating system, if any.
    38                        
    39 00:1726: xx xx 00 03                  HEADER  3,"BYE",NORMAL
       00:172A: 42 59 45 
    40                        BYE:
    41 00:172D: 78                           sei			; Restore control to the Mensch Monitor
    42 00:172E: D8                           cld
    43 00:172F: 38 FB                        emulate
    44 00:1731: A9 80        		lda	#1<<7		; Ename the WDC ROM
    45 00:1733: 1C 40 DF     		trb	BCR
    46 00:1736: 6C FC FF                     jmp     ($fffc)         ; Reset the processor
    47                        
    48                        ; UNUSED ( -- u )
    49                        ;
    50                        ; u is the amount of space remaining in the region addressed by HERE , in
    51                        ; address units.
    52                        
    53 00:1739: xx xx 00 06                  HEADER  6,"UNUSED",NORMAL
       00:173D: 55 4E 55 53 
       00:1741: 45 44 
    54 00:1743: 20 xx xx     UNUSED:         jsr     DO_COLON
    55 00:1746: xx xx 00 80                  dw      DO_LITERAL,$8000
    56 00:174A: xx xx                        dw      HERE
    57 00:174C: xx xx                        dw      MINUS
    58 00:174E: xx xx                        dw      EXIT
    59                        
    60                        ;-------------------------------------------------------------------------------
  3962                                        
  3963                        ;-------------------------------------------------------------------------------
  3964                        
  Sat May  7 2016 20:07                                                                                                    Page 81


  3965 00:1750: xx xx                        TRAILER
  3966                                        
  3967                        		end


      Lines assembled: 5874
      Errors: 0
