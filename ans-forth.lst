  Tue May  3 2016 22:26                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;===============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;-------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The DP register is used for the Forth data stack is values can be accessed
    27                        ; using the direct-page addressing modes. The code uses the same offsets as
    28                        ; would be used with the stack relative instructions (i.e <1, <3, etc.).
    29                        ;
    30                        ; The Y register holds the forth instruction pointer leaving X free for general
    31                        ; use in words. Some words push Y if they need an extra register.
    32                        ;
    33                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    34                        ; CamelForth implementations.
    35                        ;
    36                        ;-------------------------------------------------------------------------------
    37                        
    38                                        pw      132
    39                                        inclist on
    40                                        maclist off
    41                        
    42                                        chip    65816
    43                                        longi   off
    44                                        longa   off
    45                        
    46                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
  Tue May  3 2016 22:26                                                                                                    Page 2


     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
  Tue May  3 2016 22:26                                                                                                    Page 3


    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    47                        
    48                        ;===============================================================================
    49                        ; Macros
    50                        ;-------------------------------------------------------------------------------
    51                        
    52                        ; The LINK macro deposits the link section of a word header automatically
    53                        ; linking the new word to the last.
    54                        
    55             00000000   WORDZ           set     0                       ; Word counter
    56             00000000   WORD0           equ     0                       ; Null address for first word
    57                        
    58                        LINK            macro   TYPE
  Tue May  3 2016 22:26                                                                                                    Page 4


    59                                        dw      WORD@<WORDZ>            ; Link
    60                                        db      TYPE                    ; Type
    61                        WORDZ           set     WORDZ+1
    62                        WORD@<WORDZ>:
    63                                        endm
    64                        
    65                        ; Deposits a word header containing the name which is linked back to the
    66                        ; previous word.
    67                        ;
    68                        ; The WDC assembler does not handle string parameters to macros very well,
    69                        ; stopping at the first comma or space in them, so some headers must be
    70                        ; manually constructed.
    71                        
    72             00000000   NORMAL          equ     $00
    73             00000080   IMMEDIATE       equ     $80
    74                        
    75                        HEADER          macro   LEN,NAME,TYPE
    76                                        LINK    TYPE
    77                                        db      LEN,NAME
    78                                        endm
    79                        
    80                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    81                        ; word pointer.
    82                        
    83                        CONTINUE        macro
    84                                        tyx                             ; Copy IP to X
    85                                        iny
    86                                        iny
    87                                        jmp     (0,x)                   ; Then execute word
    88                                        endm
    89                        
    90                        TRAILER         macro
    91                        LAST_WORD       equ     WORD@<WORDZ>
    92                                        endm
    93                        
    94                        ;===============================================================================
    95                        ; Definitions
    96                        ;-------------------------------------------------------------------------------
    97                        
    98             00000016   USER_SIZE       equ     22
    99             00000080   DSTACK_SIZE     equ     128
   100             00000080   RSTACK_SIZE     equ     128
   101                        
   102             00000000   TO_IN_OFFSET    equ     0
   103             00000002   BASE_OFFSET     equ     2
   104             00000004   BLK_OFFSET      equ     4
   105             00000006   DP_OFFSET       equ     6
   106             00000008   LATEST_OFFSET   equ     8
   107             0000000A   SCR_OFFSET      equ     10
   108             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   109             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   110             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   111             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   112             00000014   HP_OFFSET       equ     20
   113                        
   114             00000080   TIB_SIZE        equ     128
   115             00000030   PAD_SIZE        equ     48
   116                        
  Tue May  3 2016 22:26                                                                                                    Page 5


   117                        ;===============================================================================
   118                        ; Data Areas
   119                        ;-------------------------------------------------------------------------------
   120                        
   121                                        page0
   122                                        org     $00
   123                        
   124 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   125                        
   126                        
   127             00000100   DSTACK_START    equ     $0100
   128             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   129                        
   130             00000180   RSTACK_START    equ     $0180
   131             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   132                        
   133                        
   134                                        data
   135                                        org     $0200
   136                        
   137 00:0200:              TIB_AREA:       ds      TIB_SIZE                ; Terminal Input Buffer
   138 00:0280:                              ds      PAD_SIZE                ; Pad area
   139                        PAD_AREA:       ds      0
   140                        
   141                        ;===============================================================================
   142                        ; Forth Entry Point
   143                        ;-------------------------------------------------------------------------------
   144                        
   145                        FORTH           section OFFSET $0400
   146                        
   147                                        public  Start
   148                        Start:
   149 00:0400: 18 FB                        native                          ; Go to native mode
   150 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   151 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   152 00:0407: 1B                           tcs
   153 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   154 00:040B: 5B                           tcd
   155                        
   156 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   157 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   158                        
   159                        COLD:
   160 00:0415: 25 05                        dw      DECIMAL
   161 00:0417: CE 04                        dw      ZERO
   162 00:0419: 70 04                        dw      BLK
   163 00:041B: 4B 05                        dw      STORE
   164 00:041D: F8 04                        dw      FALSE
   165 00:041F: B8 04                        dw      STATE
   166 00:0421: 4B 05                        dw      STORE
   167 00:0423: C7 16 49 1B                  dw      DO_LITERAL,NEXT_WORD
   168 00:0427: 80 04                        dw      DP
   169 00:0429: 4B 05                        dw      STORE
   170 00:042B: C7 16 35 1B                  dw      DO_LITERAL,LAST_WORD
   171 00:042F: 94 04                        dw      LATEST
   172 00:0431: 4B 05                        dw      STORE
   173 00:0433: 82 18                        dw      CR
  Tue May  3 2016 22:26                                                                                                    Page 6


   174 00:0435: 82 18                        dw      CR
   175 00:0437: 00 1B                        dw      DO_TITLE
   176 00:0439: FF 18                        dw      TYPE
   177 00:043B: 82 18                        dw      CR
   178 00:043D: 82 18                        dw      CR
   179 00:043F: 83 0E                        dw      ABORT
   180                        
   181                        ;===============================================================================
   182                        ; System/User Variables
   183                        ;-------------------------------------------------------------------------------
   184                        
   185                        ; #TIB ( -- a-addr )
   186                        ;
   187                        ; a-addr is the address of a cell containing the number of characters in the
   188                        ; terminal input buffer.
   189                        
   190 00:0441: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0445: 23 54 49 42 
   191 00:0449: 20 09 16     HASH_TIB:       jsr     DO_CONSTANT
   192 00:044C: 4E 04                        dw      $+2
   193 00:044E: 7E 00                        dw      TIB_SIZE-2
   194                        
   195                        ; >IN ( -- a-addr )
   196                        ;
   197                        ; a-addr is the address of a cell containing the offset in characters from the
   198                        ; start of the input buffer to the start of the parse area.
   199                        
   200 00:0450: 44 04 00 03                  HEADER  3,">IN",NORMAL
       00:0454: 3E 49 4E 
   201 00:0457: 20 DD 17     TO_IN:          jsr     DO_USER
   202 00:045A: 00 00                        dw      TO_IN_OFFSET
   203                        
   204                        ; BASE ( -- a-addr )
   205                        ;
   206                        ; a-addr is the address of a cell containing the current number-conversion
   207                        ; radix {{2...36}}.
   208                        
   209 00:045C: 53 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0460: 42 41 53 45 
   210 00:0464: 20 DD 17     BASE:           jsr     DO_USER
   211 00:0467: 02 00                        dw      BASE_OFFSET
   212                        
   213                        ; BLK ( -- a-addr )
   214                        ;
   215                        ; a-addr is the address of a cell containing zero or the number of the mass-
   216                        ; storage block being interpreted. If BLK contains zero, the input source is
   217                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   218                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   219                        
   220 00:0469: 5F 04 00 03                  HEADER  3,"BLK",NORMAL
       00:046D: 42 4C 4B 
   221 00:0470: 20 DD 17     BLK:            jsr     DO_USER
   222 00:0473: 04 00                        dw      BLK_OFFSET
   223                        
   224                        ; (BUFFER)
   225                        
   226 00:0475: 20 DD 17     BUFFER:         jsr     DO_USER
   227 00:0478: 10 00                        dw      BUFFER_OFFSET
  Tue May  3 2016 22:26                                                                                                    Page 7


   228                        
   229                        ; DP ( -- a-addr )
   230                        ;
   231                        ; Dictionary Pointer
   232                        
   233 00:047A: 6C 04 00 02                  HEADER  2,"DP",NORMAL
       00:047E: 44 50 
   234 00:0480: 20 DD 17     DP:             jsr     DO_USER
   235 00:0483: 06 00                        dw      DP_OFFSET
   236                        
   237                        ; HP ( -- a-addr )
   238                        ;
   239                        ; Hold Pointer
   240                        
   241 00:0485: 20 DD 17     HP:             jsr     DO_USER
   242 00:0488: 14 00                        dw      HP_OFFSET
   243                        
   244                        ; LATEST ( -- a-addr )
   245                        
   246 00:048A: 7D 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:048E: 4C 41 54 45 
       00:0492: 53 54 
   247 00:0494: 20 DD 17     LATEST:         jsr     DO_USER
   248 00:0497: 08 00                        dw      LATEST_OFFSET
   249                        
   250                        ; (LENGTH)
   251                        
   252 00:0499: 20 DD 17     LENGTH:         jsr     DO_USER
   253 00:049C: 12 00                        dw      LENGTH_OFFSET
   254                        
   255                        ; SCR ( -- a-addr )
   256                        ;
   257                        ; a-addr is the address of a cell containing the block number of the block most
   258                        ; recently LISTed.
   259                        
   260 00:049E: 8D 04 00 03                  HEADER  3,"SCR",NORMAL
       00:04A2: 53 43 52 
   261 00:04A5: 20 DD 17     SCR:            jsr     DO_USER
   262 00:04A8: 0A 00                        dw      SCR_OFFSET
   263                        
   264                        ; (SOURCE-ID)
   265                        
   266 00:04AA: 20 DD 17     SOURCEID:       jsr     DO_USER
   267 00:04AD: 0C 00                        dw      SOURCEID_OFFSET
   268                        
   269                        ; STATE ( -- a-addr )
   270                        ;
   271                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   272                        ; is true when in compilation state, false otherwise. The true value in STATE
   273                        ; is non-zero, but is otherwise implementation-defined.
   274                        
   275 00:04AF: A1 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04B3: 53 54 41 54 
       00:04B7: 45 
   276 00:04B8: 20 DD 17     STATE:          jsr     DO_USER
   277 00:04BB: 0E 00                        dw      STATE_OFFSET
   278                        
   279                        ; TIB ( -- c-addr )
  Tue May  3 2016 22:26                                                                                                    Page 8


   280                        ;
   281                        ; c-addr is the address of the terminal input buffer.
   282                        
   283 00:04BD: B2 04 00 03                  HEADER  3,"TIB",NORMAL
       00:04C1: 54 49 42 
   284 00:04C4: 20 09 16     TIB:            jsr     DO_CONSTANT
   285 00:04C7: 00 02                        dw      TIB_AREA
   286                        
   287                        ;===============================================================================
   288                        ; Constants
   289                        ;-------------------------------------------------------------------------------
   290                        
   291                        ; 0 ( -- 0 )
   292                        ;
   293                        ; Push the constant value zero on the stack
   294                        
   295 00:04C9: C0 04 00 01                  HEADER  1,"0",NORMAL
       00:04CD: 30 
   296                        ZERO:
   297 00:04CE: 7B                           tdc
   298 00:04CF: 3A                           dec     a                       ; Make space on the stack
   299 00:04D0: 3A                           dec     a
   300 00:04D1: 5B                           tcd
   301 00:04D2: 64 01                        stz     <1                      ; And create a zero value
   302 00:04D4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04D8: 00 00 
   303                        
   304                        ; BL ( -- char )
   305                        ;
   306                        ; char is the character value for a space.
   307                        
   308 00:04DA: CC 04 00 02                  HEADER  2,"BL",NORMAL
       00:04DE: 42 4C 
   309                        BL:
   310 00:04E0: 7B                           tdc
   311 00:04E1: 3A                           dec     a                       ; Make space on the stack
   312 00:04E2: 3A                           dec     a
   313 00:04E3: 5B                           tcd
   314 00:04E4: A9 20 00                     lda     #' '                    ; And save a space value
   315 00:04E7: 85 01                        sta     <1
   316 00:04E9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04ED: 00 00 
   317                        
   318                        ; FALSE ( -- false )
   319                        ;
   320                        ; Return a false flag.
   321                        
   322 00:04EF: DD 04 00 05                  HEADER  5,"FALSE",NORMAL
       00:04F3: 46 41 4C 53 
       00:04F7: 45 
   323                        FALSE:
   324 00:04F8: 7B                           tdc
   325 00:04F9: 3A                           dec     a                       ; Make space on the stack
   326 00:04FA: 3A                           dec     a
   327 00:04FB: 5B                           tcd
   328 00:04FC: 64 01                        stz     <1                      ; And create a false value
   329 00:04FE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0502: 00 00 
  Tue May  3 2016 22:26                                                                                                    Page 9


   330                        
   331                        ; TRUE ( -- true )
   332                        ;
   333                        ; Return a true flag, a single-cell value with all bits set.
   334                        
   335 00:0504: F2 04 00 04                  HEADER  4,"TRUE",NORMAL
       00:0508: 54 52 55 45 
   336                        TRUE:
   337 00:050C: 7B                           tdc
   338 00:050D: 3A                           dec     a                       ; Make space on the stack
   339 00:050E: 3A                           dec     a
   340 00:050F: 5B                           tcd
   341 00:0510: 64 01                        stz     <1                      ; And create a true value
   342 00:0512: C6 01                        dec     <1
   343 00:0514: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0518: 00 00 
   344                        
   345                        ;===============================================================================
   346                        ; Radix
   347                        ;-------------------------------------------------------------------------------
   348                        
   349                        ; DECIMAL ( -- )
   350                        ;
   351                        ; Set the numeric conversion radix to ten (decimal).
   352                        
   353 00:051A: 07 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:051E: 44 45 43 49 
       00:0522: 4D 41 4C 
   354 00:0525: 20 C1 14     DECIMAL:        jsr     DO_COLON
   355 00:0528: C7 16 0A 00                  dw      DO_LITERAL,10
   356 00:052C: 64 04                        dw      BASE
   357 00:052E: 4B 05                        dw      STORE
   358 00:0530: E6 0E                        dw      EXIT
   359                        
   360                        ; HEX ( -- )
   361                        ;
   362                        ; Set contents of BASE to sixteen.
   363                        
   364 00:0532: 1D 05 00 03                  HEADER  3,"HEX",NORMAL
       00:0536: 48 45 58 
   365 00:0539: 20 C1 14     HEX:            jsr     DO_COLON
   366 00:053C: C7 16 10 00                  dw      DO_LITERAL,16
   367 00:0540: 64 04                        dw      BASE
   368 00:0542: 4B 05                        dw      STORE
   369 00:0544: E6 0E                        dw      EXIT
   370                        
   371                        ;===============================================================================
   372                        ; Memory Operations
   373                        ;-------------------------------------------------------------------------------
   374                        
   375                        ; ! ( x a-addr -- )
   376                        ;
   377                        ; Store x at a-addr.
   378                        
   379 00:0546: 35 05 00 01                  HEADER  1,"!",NORMAL
       00:054A: 21 
   380                        STORE:
   381 00:054B: A5 03                        lda     <3                      ; Fetch data value
  Tue May  3 2016 22:26                                                                                                    Page 10


   382 00:054D: 92 01                        sta     (1)                     ; .. and store
   383 00:054F: 7B                           tdc                             ; Clean up data stack
   384 00:0550: 1A                           inc     a
   385 00:0551: 1A                           inc     a
   386 00:0552: 1A                           inc     a
   387 00:0553: 1A                           inc     a
   388 00:0554: 5B                           tcd
   389 00:0555: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0559: 00 00 
   390                        
   391                        ; +! ( n|u a-addr -- )
   392                        ;
   393                        ; Add n|u to the single-cell number at a-addr.
   394                        
   395 00:055B: 49 05 00 02                  HEADER  2,"+!",NORMAL
       00:055F: 2B 21 
   396                        PLUS_STORE:
   397 00:0561: 18                           clc
   398 00:0562: A5 03                        lda     <3                      ; Fetch data value
   399 00:0564: 72 01                        adc     (1)
   400 00:0566: 92 01                        sta     (1)
   401 00:0568: 7B                           tdc                             ; Clean up data stack
   402 00:0569: 1A                           inc     a
   403 00:056A: 1A                           inc     a
   404 00:056B: 1A                           inc     a
   405 00:056C: 1A                           inc     a
   406 00:056D: 5B                           tcd
   407 00:056E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0572: 00 00 
   408                        
   409                        ; , ( x -- )
   410                        ;
   411                        ; Reserve one cell of data space and store x in the cell. If the data-space
   412                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   413                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   414                        ; is not aligned prior to execution of ,.
   415                        ;
   416                        ; In this implementation is its defined as:
   417                        ;
   418                        ;   HERE ! 1 CELLS ALLOT
   419                        
   420 00:0574: 5E 05 00                     LINK    NORMAL
   421 00:0577: 01 2C                        db      1,","
   422 00:0579: 20 C1 14     COMMA:          jsr     DO_COLON
   423 00:057C: 24 06                        dw      HERE
   424 00:057E: 4B 05                        dw      STORE
   425 00:0580: C7 16 01 00                  dw      DO_LITERAL,1
   426 00:0584: 69 06                        dw      CELLS
   427 00:0586: CC 05                        dw      ALLOT
   428 00:0588: E6 0E                        dw      EXIT
   429                        
   430                        ; 2! ( x1 x2 a-addr -- )
   431                        ;
   432                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   433                        ; consecutive cell.
   434                        ;
   435                        ; In this implementation is its defined as:
   436                        ;
  Tue May  3 2016 22:26                                                                                                    Page 11


   437                        ;   SWAP OVER ! CELL+ !.
   438                        
   439 00:058A: 77 05 00 02                  HEADER  2,"2!",NORMAL
       00:058E: 32 21 
   440 00:0590: 20 C1 14     TWO_STORE:      jsr     DO_COLON
   441 00:0593: 0C 08                        dw      SWAP
   442 00:0595: A8 07                        dw      OVER
   443 00:0597: 4B 05                        dw      STORE
   444 00:0599: 56 06                        dw      CELL_PLUS
   445 00:059B: 4B 05                        dw      STORE
   446 00:059D: E6 0E                        dw      EXIT
   447                        
   448                        ; 2@ ( a-addr -- x1 x2 )
   449                        ;
   450                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   451                        ; the next consecutive cell.
   452                        ;
   453                        ; In this implementation is its defined as:
   454                        ;
   455                        ;   DUP CELL+ @ SWAP @
   456                        
   457 00:059F: 8D 05 00 02                  HEADER  2,"2@",NORMAL
       00:05A3: 32 40 
   458 00:05A5: 20 C1 14     TWO_FETCH:      jsr     DO_COLON
   459 00:05A8: 85 07                        dw      DUP
   460 00:05AA: 56 06                        dw      CELL_PLUS
   461 00:05AC: B9 05                        dw      FETCH
   462 00:05AE: 0C 08                        dw      SWAP
   463 00:05B0: B9 05                        dw      FETCH
   464 00:05B2: E6 0E                        dw      EXIT
   465                        
   466                        ; @ ( a-addr -- x )
   467                        ;
   468                        ; x is the value stored at a-addr.
   469                        
   470 00:05B4: A2 05 00 01                  HEADER  1,"@",NORMAL
       00:05B8: 40 
   471                        FETCH:
   472 00:05B9: B2 01                        lda     (1)                     ; Fetch from memory
   473 00:05BB: 85 01                        sta     <1                      ; .. and replace top value
   474 00:05BD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05C1: 00 00 
   475                        
   476                        ; ALLOT ( n -- )
   477                        ;
   478                        ; If n is greater than zero, reserve n address units of data space. If n is
   479                        ; less than zero, release |n| address units of data space. If n is zero, leave
   480                        ; the data-space pointer unchanged.
   481                        ;
   482                        ; In this implementation its is defined as:
   483                        ;
   484                        ;   DP +!
   485                        
   486 00:05C3: B7 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:05C7: 41 4C 4C 4F 
       00:05CB: 54 
   487 00:05CC: 20 C1 14     ALLOT:          jsr     DO_COLON
   488 00:05CF: 80 04                        dw      DP
  Tue May  3 2016 22:26                                                                                                    Page 12


   489 00:05D1: 61 05                        dw      PLUS_STORE
   490 00:05D3: E6 0E                        dw      EXIT
   491                        
   492                        ; C! ( char c-addr -- )
   493                        ;
   494                        ; Store char at c-addr. When character size is smaller than cell size, only the
   495                        ; number of low-order bits corresponding to character size are transferred.
   496                        
   497 00:05D5: C6 05 00 02                  HEADER  2,"C!",NORMAL
       00:05D9: 43 21 
   498                        C_STORE:
   499 00:05DB: A5 03                        lda     <3                      ; Fetch the data value
   500 00:05DD: E2 20                        short_a
   501 00:05DF: 92 01                        sta     (1)                     ; And store it
   502 00:05E1: C2 20                        long_a
   503 00:05E3: 7B                           tdc                             ; Clean up the stack
   504 00:05E4: 1A                           inc     a
   505 00:05E5: 1A                           inc     a
   506 00:05E6: 1A                           inc     a
   507 00:05E7: 1A                           inc     a
   508 00:05E8: 5B                           tcd
   509 00:05E9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05ED: 00 00 
   510                        
   511                        ; C, ( char -- )
   512                        ;
   513                        ; Reserve space for one character in the data space and store char in the
   514                        ; space. If the data-space pointer is character aligned when C, begins
   515                        ; execution, it will remain character aligned when C, finishes execution.
   516                        ; An ambiguous condition exists if the data-space pointer is not character-
   517                        ; aligned prior to execution of C,
   518                        ;
   519                        ;   HERE C! 1 CHARS ALLOT
   520                        
   521 00:05EF: D8 05 00                     LINK    NORMAL
   522 00:05F2: 02 43 2C                     db      2,"C,"
   523 00:05F5: 20 C1 14     C_COMMA:        jsr     DO_COLON
   524 00:05F8: 24 06                        dw      HERE
   525 00:05FA: DB 05                        dw      C_STORE
   526 00:05FC: C7 16 01 00                  dw      DO_LITERAL,1
   527 00:0600: 9C 06                        dw      CHARS
   528 00:0602: CC 05                        dw      ALLOT
   529 00:0604: E6 0E                        dw      EXIT
   530                        
   531                        ; C@ ( c-addr -- char )
   532                        ;
   533                        ; Fetch the character stored at c-addr. When the cell size is greater than
   534                        ; character size, the unused high-order bits are all zeroes.
   535                        
   536 00:0606: F2 05 00 02                  HEADER  2,"C@",NORMAL
       00:060A: 43 40 
   537                        C_FETCH:
   538 00:060C: E2 20                        short_a
   539 00:060E: B2 01                        lda     (1)                     ; Fetch the data byte
   540 00:0610: 85 01                        sta     <1                      ; .. and replace stack value
   541 00:0612: 64 02                        stz     <2
   542 00:0614: C2 20                        long_a
   543 00:0616: BB C8 C8 7C                  CONTINUE                        ; Done
  Tue May  3 2016 22:26                                                                                                    Page 13


       00:061A: 00 00 
   544                        
   545                        ; HERE ( -- addr )
   546                        ;
   547                        ; addr is the data-space pointer.
   548                        
   549 00:061C: 09 06 00 04                  HEADER  4,"HERE",NORMAL
       00:0620: 48 45 52 45 
   550 00:0624: 20 C1 14     HERE:           jsr     DO_COLON
   551 00:0627: 80 04                        dw      DP
   552 00:0629: B9 05                        dw      FETCH
   553 00:062B: E6 0E                        dw      EXIT
   554                        
   555                        ;===============================================================================
   556                        ; Alignment
   557                        ;-------------------------------------------------------------------------------
   558                        
   559                        ; ALIGN ( -- )
   560                        ;
   561                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   562                        
   563 00:062D: 1F 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:0631: 41 4C 49 47 
       00:0635: 4E 
   564                        ALIGN:
   565 00:0636: BB C8 C8 7C                  CONTINUE                        ; Done
       00:063A: 00 00 
   566                        
   567                        ; ALIGNED ( addr -- a-addr )
   568                        ;
   569                        ; a-addr is the first aligned address greater than or equal to addr.
   570                        
   571 00:063C: 30 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:0640: 41 4C 49 47 
       00:0644: 4E 45 44 
   572                        ALIGNED:
   573 00:0647: BB C8 C8 7C                  CONTINUE                        ; Done
       00:064B: 00 00 
   574                        
   575                        ; CELL+ ( a-addr1 -- a-addr2 )
   576                        ;
   577                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   578                        
   579 00:064D: 3F 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:0651: 43 45 4C 4C 
       00:0655: 2B 
   580                        CELL_PLUS:
   581 00:0656: E6 01                        inc     <1                      ; Bump the address by two
   582 00:0658: E6 01                        inc     <1
   583 00:065A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:065E: 00 00 
   584                        
   585                        ; CELLS ( n1 -- n2 )
   586                        ;
   587                        ; n2 is the size in address units of n1 cells.
   588                        
   589 00:0660: 50 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:0664: 43 45 4C 4C 
  Tue May  3 2016 22:26                                                                                                    Page 14


       00:0668: 53 
   590                        CELLS:
   591 00:0669: 06 01                        asl     <1                      ; Two bytes per cell
   592 00:066B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:066F: 00 00 
   593                        
   594                        ; CHAR+ ( c-addr1 -- c-addr2 )
   595                        ;
   596                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   597                        
   598 00:0671: 63 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0675: 43 48 41 52 
       00:0679: 2B 
   599                        CHAR_PLUS:
   600 00:067A: E6 01                        inc     <1                      ; Bump the address by one
   601 00:067C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0680: 00 00 
   602                        
   603                        ; CHAR- ( c-addr1 -- c-addr2 )
   604                        ;
   605                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   606                        
   607 00:0682: 74 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:0686: 43 48 41 52 
       00:068A: 2D 
   608                        CHAR_MINUS:
   609 00:068B: C6 01                        dec     <1
   610 00:068D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0691: 00 00 
   611                        
   612                        ; CHARS ( n1 -- n2 )
   613                        ;
   614                        ; n2 is the size in address units of n1 characters.
   615                        
   616 00:0693: 85 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:0697: 43 48 41 52 
       00:069B: 53 
   617                        CHARS:
   618 00:069C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06A0: 00 00 
   619                        
   620                        ;===============================================================================
   621                        ; Stack Operations
   622                        ;-------------------------------------------------------------------------------
   623                        
   624                        ; 2DROP ( x1 x2 -- )
   625                        ;
   626                        ; Drop cell pair x1 x2 from the stack.
   627                        
   628 00:06A2: 96 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06A6: 32 44 52 4F 
       00:06AA: 50 
   629                        TWO_DROP:
   630 00:06AB: 7B                           tdc                             ; Removed two words from stack
   631 00:06AC: 1A                           inc     a
   632 00:06AD: 1A                           inc     a
   633 00:06AE: 1A                           inc     a
   634 00:06AF: 1A                           inc     a
  Tue May  3 2016 22:26                                                                                                    Page 15


   635 00:06B0: 5B                           tcd
   636 00:06B1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B5: 00 00 
   637                        
   638                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   639                        ;
   640                        ; Duplicate cell pair x1 x2.
   641                        
   642 00:06B7: A5 06 00 04                  HEADER  4,"2DUP",NORMAL
       00:06BB: 32 44 55 50 
   643                        TWO_DUP:
   644 00:06BF: 7B                           tdc                             ; Make space for new value
   645 00:06C0: 3A                           dec     a
   646 00:06C1: 3A                           dec     a
   647 00:06C2: 3A                           dec     a
   648 00:06C3: 3A                           dec     a
   649 00:06C4: 5B                           tcd
   650 00:06C5: A5 05                        lda     <5                      ; Copy top two values
   651 00:06C7: 85 01                        sta     <1
   652 00:06C9: A5 07                        lda     <7
   653 00:06CB: 85 03                        sta     <3
   654 00:06CD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06D1: 00 00 
   655                        
   656                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   657                        ;
   658                        ; Copy cell pair x1 x2 to the top of the stack.
   659                        
   660 00:06D3: BA 06 00 05                  HEADER  5,"2OVER",NORMAL
       00:06D7: 32 4F 56 45 
       00:06DB: 52 
   661                        TWO_OVER:
   662 00:06DC: 7B                           tdc                             ; Make space for new value
   663 00:06DD: 3A                           dec     a
   664 00:06DE: 3A                           dec     a
   665 00:06DF: 3A                           dec     a
   666 00:06E0: 3A                           dec     a
   667 00:06E1: 5B                           tcd
   668 00:06E2: A5 09                        lda     <9                      ; Ciopy top two values
   669 00:06E4: 85 01                        sta     <1
   670 00:06E6: A5 0B                        lda     <11
   671 00:06E8: 85 03                        sta     <3
   672 00:06EA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06EE: 00 00 
   673                        
   674                        ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
   675                        ;
   676                        ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
   677                        ; the top of the stack.
   678                        
   679 00:06F0: D6 06 00 04                  HEADER  4,"2ROT",NORMAL
       00:06F4: 32 52 4F 54 
   680 00:06F8: 20 C1 14     TWO_ROT:        jsr     DO_COLON
   681 00:06FB: A5 0B                        lda     <11                     ; Save x1
   682 00:06FD: 48                           pha
   683 00:06FE: A5 09                        lda     <9                      ; Save x2
   684 00:0700: 48                           pha
   685 00:0701: A5 07                        lda     <7                      ; Move x3
  Tue May  3 2016 22:26                                                                                                    Page 16


   686 00:0703: 85 0B                        sta     <11
   687 00:0705: A5 05                        lda     <5                      ; Move x4
   688 00:0707: 85 09                        sta     <9
   689 00:0709: A5 03                        lda     <3                      ; Move x5
   690 00:070B: 85 07                        sta     <7
   691 00:070D: A5 01                        lda     <1                      ; Move x6
   692 00:070F: 85 05                        sta     <5
   693 00:0711: 68                           pla                             ; Restore x2
   694 00:0712: 85 01                        sta     <1
   695 00:0714: 68                           pla                             ; Restore x1
   696 00:0715: 85 03                        sta     <3
   697 00:0717: BB C8 C8 7C                  CONTINUE                        ; Done
       00:071B: 00 00 
   698                        
   699                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   700                        ;
   701                        ; Exchange the top two cell pairs.
   702                        
   703 00:071D: F3 06 00 05                  HEADER  5,"2SWAP",NORMAL
       00:0721: 32 53 57 41 
       00:0725: 50 
   704                        TWO_SWAP:
   705 00:0726: A5 03                        lda     <3                      ; Save x3
   706 00:0728: 48                           pha
   707 00:0729: A5 01                        lda     <1                      ; Save x4
   708 00:072B: 48                           pha
   709 00:072C: A5 07                        lda     <7                      ; Move x1
   710 00:072E: 85 03                        sta     <3
   711 00:0730: A5 05                        lda     <5                      ; Move x2
   712 00:0732: 85 01                        sta     <1
   713 00:0734: 68                           pla                             ; Move x4
   714 00:0735: 85 05                        sta     <5
   715 00:0737: 68                           pla                             ; Move x3
   716 00:0738: 85 07                        sta     <7
   717 00:073A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:073E: 00 00 
   718                        
   719                        ; ?DUP ( x -- 0 | x x )
   720                        ;
   721                        ; Duplicate x if it is non-zero.
   722                        
   723 00:0740: 20 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:0744: 3F 44 55 50 
   724                        QUERY_DUP:
   725 00:0748: A5 01                        lda     <1                      ; Fetch top value
   726 00:074A: D0 39                        bne     DUP                     ; Non-zero value?
   727 00:074C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0750: 00 00 
   728                        
   729                        ; DEPTH ( -- +n )
   730                        ;
   731                        ; +n is the number of single-cell values contained in the data stack before +n
   732                        ; was placed on the stack.
   733                        
   734 00:0752: 43 07 00 05                  HEADER  5,"DEPTH",NORMAL
       00:0756: 44 45 50 54 
       00:075A: 48 
   735 00:075B: 20 C1 14     DEPTH:          jsr     DO_COLON
  Tue May  3 2016 22:26                                                                                                    Page 17


   736 00:075E: DE 1A                        dw      AT_DP
   737 00:0760: C7 16 7F 01                  dw      DO_LITERAL,DSTACK_END-1
   738 00:0764: 0C 08                        dw      SWAP
   739 00:0766: 2E 09                        dw      MINUS
   740 00:0768: 9A 09                        dw      TWO_SLASH
   741 00:076A: E6 0E                        dw      EXIT
   742                        
   743                        ; DROP ( x -- )
   744                        ;
   745                        ; Remove x from the stack.
   746                        
   747 00:076C: 55 07 00 04                  HEADER  4,"DROP",NORMAL
       00:0770: 44 52 4F 50 
   748                        DROP:
   749 00:0774: 7B                           tdc                             ; Drop the top value
   750 00:0775: 1A                           inc     a
   751 00:0776: 1A                           inc     a
   752 00:0777: 5B                           tcd
   753 00:0778: BB C8 C8 7C                  CONTINUE                        ; Done
       00:077C: 00 00 
   754                        
   755                        ; DUP ( x -- x x )
   756                        ;
   757                        ; Duplicate x.
   758                        
   759 00:077E: 6F 07 00 03                  HEADER  3,"DUP",NORMAL
       00:0782: 44 55 50 
   760                        DUP:
   761 00:0785: 7B                           tdc
   762 00:0786: 3A                           dec     a
   763 00:0787: 3A                           dec     a
   764 00:0788: 5B                           tcd
   765 00:0789: A5 03                        lda     <3                      ; Fetch top value
   766 00:078B: 85 01                        sta     <1                      ; And make a copy
   767 00:078D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0791: 00 00 
   768                        
   769                        ; NIP ( x1 x2 -- x2 )
   770                        ;
   771                        ; Drop the first item below the top of stack.
   772                        
   773 00:0793: 81 07 00 03                  HEADER  3,"NIP",NORMAL
       00:0797: 4E 49 50 
   774                        NIP:
   775 00:079A: A5 01                        lda     <1                      ; Copy x2 over x1
   776 00:079C: 85 03                        sta     <3
   777 00:079E: 80 D4                        bra     DROP
   778                        
   779                        ; OVER ( x1 x2 -- x1 x2 x1 )
   780                        ;
   781                        ; Place a copy of x1 on top of the stack.
   782                        
   783 00:07A0: 96 07 00 04                  HEADER  4,"OVER",NORMAL
       00:07A4: 4F 56 45 52 
   784                        OVER:
   785 00:07A8: 7B                           tdc
   786 00:07A9: 3A                           dec     a
   787 00:07AA: 3A                           dec     a
  Tue May  3 2016 22:26                                                                                                    Page 18


   788 00:07AB: 5B                           tcd
   789 00:07AC: A5 05                        lda     <5                      ; Fetch second value
   790 00:07AE: 85 01                        sta     <1                      ; And make a copy
   791 00:07B0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07B4: 00 00 
   792                        
   793                        ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
   794                        ;
   795                        ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
   796                        ; if there are less than u+2 items on the stack before PICK is executed.
   797                        
   798 00:07B6: A3 07 00 04                  HEADER  4,"PICK",NORMAL
       00:07BA: 50 49 43 4B 
   799                        PICK:
   800 00:07BE: A5 01                        lda     <1                      ; Fetch the index
   801 00:07C0: 0A                           asl     a
   802 00:07C1: AA                           tax
   803 00:07C2: B5 03                        lda     <3,x                    ; Load the target value
   804 00:07C4: 85 01                        sta     <1                      ; .. and save
   805 00:07C6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07CA: 00 00 
   806                        
   807                        ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   808                        ;
   809                        ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
   810                        ; exists if there are less than u+2 items on the stack before ROLL is executed.
   811                        
   812 00:07CC: B9 07 00 04                  HEADER  4,"ROLL",NORMAL
       00:07D0: 52 4F 4C 4C 
   813                        ROLL:
   814 00:07D4: 06 01                        asl     <1                      ; Convert count to index
   815 00:07D6: A6 01                        ldx     <1
   816 00:07D8: F0 0E                        beq     ROLL_2                  ; Zero? Nothing to do
   817 00:07DA: B5 03                        lda     <3,x                    ; Save the final value
   818 00:07DC: 48                           pha
   819 00:07DD: B5 01        ROLL_1:         lda     <1,x                    ; Move x-1 to x
   820 00:07DF: 95 03                        sta     <3,x
   821 00:07E1: CA                           dex                             ; And repeat
   822 00:07E2: CA                           dex
   823 00:07E3: D0 F8                        bne     ROLL_1
   824 00:07E5: 68                           pla                             ; Recover the new top value
   825 00:07E6: 85 03                        sta     <3
   826 00:07E8: 4C 74 07     ROLL_2:         jmp     DROP                    ; Drop the count
   827                        
   828                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   829                        ;
   830                        ; Rotate the top three stack entries.
   831                        
   832 00:07EB: CF 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07EF: 52 4F 54 
   833                        ROT:
   834 00:07F2: A6 05                        ldx     <5                      ; Save x1
   835 00:07F4: A5 03                        lda     <3                      ; Move x2
   836 00:07F6: 85 05                        sta     <5
   837 00:07F8: A5 01                        lda     <1                      ; Move x3
   838 00:07FA: 85 03                        sta     <3
   839 00:07FC: 86 01                        stx     <1                      ; Restore x1
   840 00:07FE: BB C8 C8 7C                  CONTINUE
  Tue May  3 2016 22:26                                                                                                    Page 19


       00:0802: 00 00 
   841                        
   842                        ; SWAP ( x1 x2 -- x2 x1 )
   843                        ;
   844                        ; Exchange the top two stack items.
   845                        
   846 00:0804: EE 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:0808: 53 57 41 50 
   847                        SWAP:
   848 00:080C: A5 01                        lda     <1                      ; Switch top two words
   849 00:080E: A6 03                        ldx     <3
   850 00:0810: 85 03                        sta     <3
   851 00:0812: 86 01                        stx     <1
   852 00:0814: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0818: 00 00 
   853                        
   854                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   855                        ;
   856                        ; Copy the first (top) stack item below the second stack item.
   857                        
   858 00:081A: 07 08 00 04                  HEADER  4,"TUCK",NORMAL
       00:081E: 54 55 43 4B 
   859 00:0822: 20 C1 14     TUCK:           jsr     DO_COLON
   860 00:0825: 0C 08                        dw      SWAP
   861 00:0827: A8 07                        dw      OVER
   862 00:0829: E6 0E                        dw      EXIT
   863                        
   864                        ;===============================================================================
   865                        ; Return Stack Operations
   866                        ;-------------------------------------------------------------------------------
   867                        
   868                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   869                        ;
   870                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   871                        ; SWAP >R >R.
   872                        
   873 00:082B: 1D 08 00 03                  HEADER  3,"2>R",NORMAL
       00:082F: 32 3E 52 
   874                        TWO_TO_R:
   875 00:0832: A5 03                        lda     <3                      ; Transfer x1
   876 00:0834: 48                           pha
   877 00:0835: A5 01                        lda     <1                      ; Transfer x2
   878 00:0837: 48                           pha
   879 00:0838: 7B                           tdc
   880 00:0839: 1A                           inc     a                       ; Clean up data stack
   881 00:083A: 1A                           inc     a
   882 00:083B: 1A                           inc     a
   883 00:083C: 1A                           inc     a
   884 00:083D: 5B                           tcd
   885 00:083E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0842: 00 00 
   886                        
   887                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   888                        ;
   889                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   890                        ; R> SWAP.
   891                        
   892 00:0844: 2E 08 00 03                  HEADER  3,"2R>",NORMAL
  Tue May  3 2016 22:26                                                                                                    Page 20


       00:0848: 32 52 3E 
   893                        TWO_R_FROM:
   894 00:084B: 7B                           tdc
   895 00:084C: 3A                           dec     a                       ; Make space for values
   896 00:084D: 3A                           dec     a
   897 00:084E: 3A                           dec     a
   898 00:084F: 3A                           dec     a
   899 00:0850: 5B                           tcd
   900 00:0851: 68                           pla                             ; Transfer x2
   901 00:0852: 85 01                        sta     <1
   902 00:0854: 68                           pla                             ; Transfer x1
   903 00:0855: 85 03                        sta     <3
   904 00:0857: BB C8 C8 7C                  CONTINUE                        ; Done
       00:085B: 00 00 
   905                        
   906                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   907                        ;
   908                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   909                        ; 2DUP >R >R SWAP.
   910                        
   911 00:085D: 47 08 00 03                  HEADER  3,"2R@",NORMAL
       00:0861: 32 52 40 
   912                        TWO_R_FETCH:
   913 00:0864: 7B                           tdc
   914 00:0865: 3A                           dec     a                       ; Make space for values
   915 00:0866: 3A                           dec     a
   916 00:0867: 3A                           dec     a
   917 00:0868: 3A                           dec     a
   918 00:0869: 5B                           tcd
   919 00:086A: A3 01                        lda     1,s                     ; Transfer x2
   920 00:086C: 85 01                        sta     <1
   921 00:086E: A3 03                        lda     3,s                     ; Transfer x1
   922 00:0870: 85 03                        sta     <3
   923 00:0872: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0876: 00 00 
   924                        
   925                        ; >R ( x -- ) ( R: -- x )
   926                        ;
   927                        ; Move x to the return stack.
   928                        
   929 00:0878: 60 08 00 02                  HEADER  2,">R",NORMAL
       00:087C: 3E 52 
   930                        TO_R:
   931 00:087E: A5 01                        lda     <1                      ; Transfer top value
   932 00:0880: 48                           pha                             ; .. to return stack
   933 00:0881: 7B                           tdc
   934 00:0882: 1A                           inc     a
   935 00:0883: 1A                           inc     a
   936 00:0884: 5B                           tcd
   937 00:0885: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0889: 00 00 
   938                        
   939                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   940                        ;
   941                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   942                        ; exists if the loop control parameters are unavailable.
   943                        
   944 00:088B: 7B 08 00 01                  HEADER  1,"I",NORMAL
  Tue May  3 2016 22:26                                                                                                    Page 21


       00:088F: 49 
   945                        I:
   946 00:0890: 7B                           tdc
   947 00:0891: 3A                           dec     a
   948 00:0892: 3A                           dec     a
   949 00:0893: 5B                           tcd
   950 00:0894: A3 01                        lda     1,s
   951 00:0896: 85 01                        sta     <1
   952 00:0898: BB C8 C8 7C                  CONTINUE
       00:089C: 00 00 
   953                        
   954                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   955                        ;
   956                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   957                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   958                        ; unavailable.
   959                        
   960 00:089E: 8E 08 00 01                  HEADER  1,"J",NORMAL
       00:08A2: 4A 
   961                        J:
   962 00:08A3: 7B                           tdc
   963 00:08A4: 3A                           dec     a
   964 00:08A5: 3A                           dec     a
   965 00:08A6: 5B                           tcd
   966 00:08A7: A3 05                        lda     5,s
   967 00:08A9: 85 01                        sta     <1
   968 00:08AB: BB C8 C8 7C                  CONTINUE
       00:08AF: 00 00 
   969                        
   970                        ; R> ( -- x ) ( R: x -- )
   971                        ;
   972                        ; Move x from the return stack to the data stack.
   973                        
   974 00:08B1: A1 08 00 02                  HEADER  2,"R>",NORMAL
       00:08B5: 52 3E 
   975                        R_FROM:
   976 00:08B7: 7B                           tdc
   977 00:08B8: 3A                           dec     a
   978 00:08B9: 3A                           dec     a
   979 00:08BA: 5B                           tcd
   980 00:08BB: 68                           pla                             ; Fetch return stack value
   981 00:08BC: 85 01                        sta     <1
   982 00:08BE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08C2: 00 00 
   983                        
   984                        ; R@ ( -- x ) ( R: x -- x )
   985                        ;
   986                        ; Copy x from the return stack to the data stack.
   987                        
   988 00:08C4: B4 08 00 02                  HEADER  2,"R@",NORMAL
       00:08C8: 52 40 
   989                        R_FETCH:
   990 00:08CA: 7B                           tdc
   991 00:08CB: 3A                           dec     a
   992 00:08CC: 3A                           dec     a
   993 00:08CD: 5B                           tcd
   994 00:08CE: A3 01                        lda     1,s
   995 00:08D0: 85 01                        sta     <1
  Tue May  3 2016 22:26                                                                                                    Page 22


   996 00:08D2: BB C8 C8 7C                  CONTINUE
       00:08D6: 00 00 
   997                        
   998                        ;===============================================================================
   999                        ; Single Precision Arithmetic
  1000                        ;-------------------------------------------------------------------------------
  1001                        
  1002                        ; * ( n1|u1 n2|u2 -- n3|u3 )
  1003                        ;
  1004                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
  1005                        ;
  1006                        ; In this implementation it is defined as:
  1007                        ;
  1008                        ;   M* DROP
  1009                        
  1010 00:08D8: C7 08 00 01                  HEADER  1,"*",NORMAL
       00:08DC: 2A 
  1011 00:08DD: 20 C1 14     STAR:           jsr     DO_COLON
  1012 00:08E0: DB 0B                        dw      M_STAR
  1013 00:08E2: 74 07                        dw      DROP
  1014 00:08E4: E6 0E                        dw      EXIT
  1015                        
  1016                        ; */ ( n1 n2 n3 -- n4 )
  1017                        ;
  1018                        ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
  1019                        ; by n3 giving the single-cell quotient n4. An ambiguous condition exists if
  1020                        ; n3 is zero or if the quotient n4 lies outside the range of a signed number.
  1021                        ; If d and n3 differ in sign, the implementation-defined result returned will
  1022                        ; be the same as that returned by either the phrase >R M* R> FM/MOD SWAP DROP
  1023                        ; or the phrase >R M* R> SM/REM SWAP DROP.
  1024                        ;
  1025                        ; In this implementation it is defined as:
  1026                        ;
  1027                        ;   >R M* R> FM/MOD SWAP DROP
  1028                        
  1029 00:08E6: DB 08 00 02                  HEADER  2,"*/",NORMAL
       00:08EA: 2A 2F 
  1030 00:08EC: 20 C1 14     STAR_SLASH:     jsr     DO_COLON
  1031 00:08EF: 7E 08                        dw      TO_R
  1032 00:08F1: DB 0B                        dw      M_STAR
  1033 00:08F3: B7 08                        dw      R_FROM
  1034 00:08F5: D0 09                        dw      FM_SLASH_MOD
  1035 00:08F7: 0C 08                        dw      SWAP
  1036 00:08F9: 74 07                        dw      DROP
  1037 00:08FB: E6 0E                        dw      EXIT
  1038                        
  1039                        ; */MOD ( n1 n2 n3 -- n4 n5 )
  1040                        ;
  1041                        ; Multiply n1 by n2 producing the intermediate double-cell result d. Divide d
  1042                        ; by n3 producing the single-cell remainder n4 and the single-cell quotient n5.
  1043                        ; An ambiguous condition exists if n3 is zero, or if the quotient n5 lies
  1044                        ; outside the range of a single-cell signed integer. If d and n3 differ in
  1045                        ; sign, the implementation-defined result returned will be the same as that
  1046                        ; returned by either the phrase >R M* R> FM/MOD or the phrase >R M* R> SM/REM.
  1047                        ;
  1048                        ; In this implementation it is defined as:
  1049                        ;
  1050                        ;   >R M* R> FM/MOD
  Tue May  3 2016 22:26                                                                                                    Page 23


  1051                        
  1052 00:08FD: E9 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:0901: 2A 2F 4D 4F 
       00:0905: 44 
  1053 00:0906: 20 C1 14     STAR_SLASH_MOD: jsr     DO_COLON
  1054 00:0909: 7E 08                        dw      TO_R
  1055 00:090B: DB 0B                        dw      M_STAR
  1056 00:090D: B7 08                        dw      R_FROM
  1057 00:090F: D0 09                        dw      FM_SLASH_MOD
  1058 00:0911: E6 0E                        dw      EXIT
  1059                        
  1060                        ; + ( n1|u1 n2|u2 -- n3|u3 )
  1061                        ;
  1062                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
  1063                        
  1064 00:0913: 00 09 00 01                  HEADER  1,"+",NORMAL
       00:0917: 2B 
  1065                        PLUS:
  1066 00:0918: 18                           clc                             ; Add top two values
  1067 00:0919: A5 03                        lda     <3
  1068 00:091B: 65 01                        adc     <1
  1069 00:091D: 85 03                        sta     <3                      ; Save result
  1070 00:091F: 7B                           tdc
  1071 00:0920: 1A                           inc     a                       ; Clean up data stack
  1072 00:0921: 1A                           inc     a
  1073 00:0922: 5B                           tcd
  1074 00:0923: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0927: 00 00 
  1075                        
  1076                        ; - ( n1|u1 n2|u2 -- n3|u3 )
  1077                        ;
  1078                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
  1079                        
  1080 00:0929: 16 09 00 01                  HEADER  1,"-",NORMAL
       00:092D: 2D 
  1081                        MINUS:
  1082 00:092E: 38                           sec                             ; Subtract top two values
  1083 00:092F: A5 03                        lda     <3
  1084 00:0931: E5 01                        sbc     <1
  1085 00:0933: 85 03                        sta     <3                      ; Save result
  1086 00:0935: 7B                           tdc
  1087 00:0936: 1A                           inc     a                       ; Clean up data stack
  1088 00:0937: 1A                           inc     a
  1089 00:0938: 5B                           tcd
  1090 00:0939: BB C8 C8 7C                  CONTINUE                        ; Done
       00:093D: 00 00 
  1091                        
  1092                        ; / ( n1 n2 -- n3 )
  1093                        ;
  1094                        ; Divide n1 by n2, giving the single-cell quotient n3. An ambiguous condition
  1095                        ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
  1096                        ; result returned will be the same as that returned by either the phrase >R S>D
  1097                        ; R> FM/MOD SWAP DROP or the phrase >R S>D R> SM/REM SWAP DROP.
  1098                        ;
  1099                        ; In this implementatio it is defined as:
  1100                        ;
  1101                        ;   >R S>D R> FM/MOD SWAP DROP
  1102                        
  Tue May  3 2016 22:26                                                                                                    Page 24


  1103 00:093F: 2C 09 00 01                  HEADER  1,"/",NORMAL
       00:0943: 2F 
  1104 00:0944: 20 C1 14     SLASH:          jsr     DO_COLON
  1105 00:0947: 7E 08                        dw      TO_R
  1106 00:0949: 16 0C                        dw      S_TO_D
  1107 00:094B: B7 08                        dw      R_FROM
  1108 00:094D: D0 09                        dw      FM_SLASH_MOD
  1109 00:094F: 0C 08                        dw      SWAP
  1110 00:0951: 74 07                        dw      DROP
  1111 00:0953: E6 0E                        dw      EXIT
  1112                        
  1113                        ; /MOD ( n1 n2 -- n3 n4 )
  1114                        ;
  1115                        ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
  1116                        ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
  1117                        ; in sign, the implementation-defined result returned will be the same as that
  1118                        ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
  1119                        ;
  1120                        ; In this implementation it is defined as:
  1121                        ;
  1122                        ;   >R S>D R> FM/MOD
  1123                        
  1124 00:0955: 42 09 00 04                  HEADER  4,"/MOD",NORMAL
       00:0959: 2F 4D 4F 44 
  1125 00:095D: 20 C1 14     SLASH_MOD:      jsr     DO_COLON
  1126 00:0960: 7E 08                        dw      TO_R
  1127 00:0962: 16 0C                        dw      S_TO_D
  1128 00:0964: B7 08                        dw      R_FROM
  1129 00:0966: D0 09                        dw      FM_SLASH_MOD
  1130 00:0968: E6 0E                        dw      EXIT
  1131                        
  1132                        ; 1+ ( n1|u1 -- n2|u2 )
  1133                        ;
  1134                        ; Add one (1) to n1|u1 giving the sum n2|u2.
  1135                        
  1136 00:096A: 58 09 00 02                  HEADER  2,"1+",NORMAL
       00:096E: 31 2B 
  1137                        ONE_PLUS:
  1138 00:0970: E6 01                        inc     <1                      ; Increment top of stack
  1139 00:0972: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0976: 00 00 
  1140                        
  1141                        ; 1- ( n1|u1 -- n2|u2 )
  1142                        ;
  1143                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
  1144                        
  1145 00:0978: 6D 09 00 02                  HEADER  2,"1-",NORMAL
       00:097C: 31 2D 
  1146                        ONE_MINUS:
  1147 00:097E: C6 01                        dec     <1                      ; Decrement top of stack
  1148 00:0980: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0984: 00 00 
  1149                        
  1150                        ; 2* ( x1 -- x2 )
  1151                        ;
  1152                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1153                        ; filling the vacated least-significant bit with zero.
  1154                        
  Tue May  3 2016 22:26                                                                                                    Page 25


  1155 00:0986: 7B 09 00 02                  HEADER  2,"2*",NORMAL
       00:098A: 32 2A 
  1156                        TWO_STAR:
  1157 00:098C: 06 01                        asl     <1                      ; Multiply top value by two
  1158 00:098E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0992: 00 00 
  1159                        
  1160                        ; 2/ ( x1 -- x2 )
  1161                        ;
  1162                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1163                        ; leaving the most-significant bit unchanged.
  1164                        
  1165 00:0994: 89 09 00 02                  HEADER  2,"2/",NORMAL
       00:0998: 32 2F 
  1166                        TWO_SLASH:
  1167 00:099A: A5 01                        lda     <1                      ; Load the top value
  1168 00:099C: 2A                           rol     a                       ; Extract the top bit
  1169 00:099D: 66 01                        ror     <1                      ; And shift back into value
  1170 00:099F: BB C8 C8 7C                  CONTINUE
       00:09A3: 00 00 
  1171                        
  1172                        ; ?NEGATE ( x sign -- x/-x)
  1173                        ;
  1174                        ; If the sign value is negative then negate the value of x to match.
  1175                        ;
  1176                        ; In this implementation it is defined as:
  1177                        ;
  1178                        ;   0< IF NEGATE THEN
  1179                        
  1180 00:09A5: 20 C1 14     QUERY_NEGATE:   jsr     DO_COLON
  1181 00:09A8: DD 0C                        dw      ZERO_LESS
  1182 00:09AA: 80 16 B0 09                  dw      QUERY_BRANCH,QUERY_NEGATE_1
  1183 00:09AE: 5F 0A                        dw      NEGATE
  1184 00:09B0: E6 0E        QUERY_NEGATE_1: dw      EXIT
  1185                        
  1186                        ; ABS ( n -- u )
  1187                        ;
  1188                        ; u is the absolute value of n.
  1189                        
  1190 00:09B2: 97 09 00 03                  HEADER  3,"ABS",NORMAL
       00:09B6: 41 42 53 
  1191                        ABS:
  1192 00:09B9: A5 01                        lda     <1
  1193 00:09BB: 10 03                        bpl     ABS_1
  1194 00:09BD: 4C 5F 0A                     jmp     NEGATE
  1195 00:09C0: BB C8 C8 7C  ABS_1:          CONTINUE                        ; Done
       00:09C4: 00 00 
  1196                        
  1197                        ; FM/MOD ( n1 n2 -- n3 n4 )
  1198                        ;
  1199                        ; Divide n1 by n2, giving the single-cell remainder n3 and the single-cell
  1200                        ; quotient n4. An ambiguous condition exists if n2 is zero. If n1 and n2 differ
  1201                        ; in sign, the implementation-defined result returned will be the same as that
  1202                        ; returned by either the phrase >R S>D R> FM/MOD or the phrase >R S>D R> SM/REM.
  1203                        ;
  1204                        ; In this implementation it is defined as:
  1205                        ;
  1206                        ;   DUP >R                      divisor
  Tue May  3 2016 22:26                                                                                                    Page 26


  1207                        ;   2DUP XOR >R                 sign of quotient
  1208                        ;   >R                          divisor
  1209                        ;   DABS R@ ABS UM/MOD
  1210                        ;   SWAP R> ?NEGATE SWAP        apply sign to remainder
  1211                        ;   R> 0< IF                    if quotient negative,
  1212                        ;       NEGATE
  1213                        ;       OVER IF                 if remainder nonzero,
  1214                        ;       R@ ROT - SWAP 1-        adjust rem,quot
  1215                        ;       THEN
  1216                        ;   THEN  R> DROP ;
  1217                        
  1218 00:09C6: B5 09 00 06                  HEADER  6,"FM/MOD",NORMAL
       00:09CA: 46 4D 2F 4D 
       00:09CE: 4F 44 
  1219 00:09D0: 20 C1 14     FM_SLASH_MOD:   jsr     DO_COLON
  1220 00:09D3: 85 07                        dw      DUP
  1221 00:09D5: 7E 08                        dw      TO_R
  1222 00:09D7: BF 06                        dw      TWO_DUP
  1223 00:09D9: 59 0E                        dw      XOR
  1224 00:09DB: 7E 08                        dw      TO_R
  1225 00:09DD: 7E 08                        dw      TO_R
  1226 00:09DF: 5F 0B                        dw      DABS
  1227 00:09E1: CA 08                        dw      R_FETCH
  1228 00:09E3: B9 09                        dw      ABS
  1229 00:09E5: A8 0C                        dw      UM_SLASH_MOD
  1230 00:09E7: 0C 08                        dw      SWAP
  1231 00:09E9: B7 08                        dw      R_FROM
  1232 00:09EB: A5 09                        dw      QUERY_NEGATE
  1233 00:09ED: 0C 08                        dw      SWAP
  1234 00:09EF: B7 08                        dw      R_FROM
  1235 00:09F1: DD 0C                        dw      ZERO_LESS
  1236 00:09F3: 80 16 09 0A                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1237 00:09F7: 5F 0A                        dw      NEGATE
  1238 00:09F9: A8 07                        dw      OVER
  1239 00:09FB: 80 16 09 0A                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1240 00:09FF: CA 08                        dw      R_FETCH
  1241 00:0A01: F2 07                        dw      ROT
  1242 00:0A03: 2E 09                        dw      MINUS
  1243 00:0A05: 0C 08                        dw      SWAP
  1244 00:0A07: 7E 09                        dw      ONE_MINUS
  1245 00:0A09: B7 08        FM_SLASH_MOD_1: dw      R_FROM
  1246 00:0A0B: 74 07                        dw      DROP
  1247 00:0A0D: E6 0E                        dw      EXIT
  1248                        
  1249                        ; MAX ( n1 n2 -- n3 )
  1250                        ;
  1251                        ; n3 is the greater of n1 and n2.
  1252                        
  1253 00:0A0F: C9 09 00 03                  HEADER  3,"MAX",NORMAL
       00:0A13: 4D 41 58 
  1254 00:0A16: 20 C1 14     MAX:            jsr     DO_COLON
  1255 00:0A19: BF 06                        dw      TWO_DUP
  1256 00:0A1B: 2F 0D                        dw      LESS
  1257 00:0A1D: 80 16 23 0A                  dw      QUERY_BRANCH,MAX_1
  1258 00:0A21: 0C 08                        dw      SWAP
  1259 00:0A23: 74 07        MAX_1:          dw      DROP
  1260 00:0A25: E6 0E                        dw      EXIT
  1261                        
  Tue May  3 2016 22:26                                                                                                    Page 27


  1262                        ; MIN ( n1 n2 -- n3 )
  1263                        ;
  1264                        ; n3 is the lesser of n1 and n2.
  1265                        
  1266 00:0A27: 12 0A 00 03                  HEADER  3,"MIN",NORMAL
       00:0A2B: 4D 49 4E 
  1267 00:0A2E: 20 C1 14     MIN:            jsr     DO_COLON
  1268 00:0A31: BF 06                        dw      TWO_DUP
  1269 00:0A33: 70 0D                        dw      GREATER
  1270 00:0A35: 80 16 3B 0A                  dw      QUERY_BRANCH,MIN_1
  1271 00:0A39: 0C 08                        dw      SWAP
  1272 00:0A3B: 74 07        MIN_1:          dw      DROP
  1273 00:0A3D: E6 0E                        dw      EXIT
  1274                        
  1275                        ; MOD ( n1 n2 -- n3 )
  1276                        ;
  1277                        ; Divide n1 by n2, giving the single-cell remainder n3. An ambiguous condition
  1278                        ; exists if n2 is zero. If n1 and n2 differ in sign, the implementation-defined
  1279                        ; result returned will be the same as that returned by either the phrase >R S>D
  1280                        ; R> FM/MOD DROP or the phrase >R S>D R> SM/REM DROP.
  1281                        ;
  1282                        ; In this implementation it is defined as:
  1283                        ;
  1284                        ;   >R S>D R> FM/MOD DROP
  1285                        
  1286 00:0A3F: 2A 0A 00 03                  HEADER  3,"MOD",NORMAL
       00:0A43: 4D 4F 44 
  1287 00:0A46: 20 C1 14     MOD:            jsr     DO_COLON
  1288 00:0A49: 7E 08                        dw      TO_R
  1289 00:0A4B: 16 0C                        dw      S_TO_D
  1290 00:0A4D: B7 08                        dw      R_FROM
  1291 00:0A4F: D0 09                        dw      FM_SLASH_MOD
  1292 00:0A51: 74 07                        dw      DROP
  1293 00:0A53: E6 0E                        dw      EXIT
  1294                        
  1295                        ; NEGATE ( n1 -- n2 )
  1296                        ;
  1297                        ; Negate n1, giving its arithmetic inverse n2.
  1298                        
  1299 00:0A55: 42 0A 00 06                  HEADER  6,"NEGATE",NORMAL
       00:0A59: 4E 45 47 41 
       00:0A5D: 54 45 
  1300                        NEGATE:
  1301 00:0A5F: 38                           sec                             ; Negate the top of stack
  1302 00:0A60: A9 00 00                     lda     #0
  1303 00:0A63: E5 01                        sbc     <1
  1304 00:0A65: 85 01                        sta     <1
  1305 00:0A67: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A6B: 00 00 
  1306                        
  1307                        ; UMAX ( x1 x2 -- x3 )
  1308                        ;
  1309                        ; x3 is the greater of x1 and x2.
  1310                        
  1311 00:0A6D: 58 0A 00 04                  HEADER  4,"UMAX",NORMAL
       00:0A71: 55 4D 41 58 
  1312                        UMAX:
  1313 00:0A75: A5 01                        lda     <1                      ; Compare the top values
  Tue May  3 2016 22:26                                                                                                    Page 28


  1314 00:0A77: C5 03                        cmp     <3
  1315 00:0A79: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1316 00:0A7B: 4C 74 07                     jmp     DROP                    ; No, x1 is
  1317 00:0A7E: 4C 9A 07     UMAX_EXIT:      jmp     NIP
  1318                        
  1319                        ; UMIN ( x1 x2 -- x3 )
  1320                        ;
  1321                        ; x3 is the lesser of x1 and x2.
  1322                        
  1323 00:0A81: 70 0A 00 04                  HEADER  4,"UMIN",NORMAL
       00:0A85: 55 4D 49 4E 
  1324                        UMIN:
  1325 00:0A89: A5 01                        lda     <1                      ; Compare the top values
  1326 00:0A8B: C5 03                        cmp     <3
  1327 00:0A8D: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1328 00:0A8F: 4C 74 07                     jmp     DROP                    ; No, x1 is
  1329 00:0A92: 4C 9A 07     UMIN_EXIT:      jmp     NIP
  1330                        
  1331                        ;===============================================================================
  1332                        ; Double Precision Arithmetic
  1333                        ;-------------------------------------------------------------------------------
  1334                        
  1335                        ; ?DNEGATE ( d1 sign -- d1/-d1 )
  1336                        ;
  1337                        ; If sign is less than zero than negate d1 otherwise leave it unchanged.
  1338                        
  1339 00:0A95: 20 C1 14     QUERY_DNEGATE:  jsr     DO_COLON
  1340 00:0A98: DD 0C                        dw      ZERO_LESS
  1341 00:0A9A: 80 16 A0 0A                  dw      QUERY_BRANCH,QUERY_DNEG_1
  1342 00:0A9E: AF 0B                        dw      DNEGATE
  1343 00:0AA0: E6 0E        QUERY_DNEG_1:   dw      EXIT
  1344                        
  1345                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1346                        ;
  1347                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1348                        
  1349 00:0AA2: 84 0A 00 02                  HEADER  2,"D+",NORMAL
       00:0AA6: 44 2B 
  1350                        D_PLUS:
  1351 00:0AA8: 18                           clc
  1352 00:0AA9: A5 07                        lda     <7                      ; Add low words
  1353 00:0AAB: 65 03                        adc     <3
  1354 00:0AAD: 85 07                        sta     <7
  1355 00:0AAF: A5 05                        lda     <5                      ; Then the high words
  1356 00:0AB1: 65 01                        adc     <1
  1357 00:0AB3: 85 05                        sta     <5
  1358 00:0AB5: 7B                           tdc                             ; Drop top double
  1359 00:0AB6: 1A                           inc     a
  1360 00:0AB7: 1A                           inc     a
  1361 00:0AB8: 1A                           inc     a
  1362 00:0AB9: 1A                           inc     a
  1363 00:0ABA: 5B                           tcd
  1364 00:0ABB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0ABF: 00 00 
  1365                        
  1366                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1367                        ;
  1368                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  Tue May  3 2016 22:26                                                                                                    Page 29


  1369                        
  1370 00:0AC1: A5 0A 00 02                  HEADER  2,"D-",NORMAL
       00:0AC5: 44 2D 
  1371                        D_MINUS:
  1372 00:0AC7: 38                           sec
  1373 00:0AC8: A5 07                        lda     <7                      ; Subtract low words
  1374 00:0ACA: E5 03                        sbc     <3
  1375 00:0ACC: 85 07                        sta     <7
  1376 00:0ACE: A5 05                        lda     <5                      ; Then the high words
  1377 00:0AD0: E5 01                        sbc     <1
  1378 00:0AD2: 85 05                        sta     <5
  1379 00:0AD4: 7B                           tdc                             ; Drop top double
  1380 00:0AD5: 1A                           inc     a
  1381 00:0AD6: 1A                           inc     a
  1382 00:0AD7: 1A                           inc     a
  1383 00:0AD8: 1A                           inc     a
  1384 00:0AD9: 5B                           tcd
  1385 00:0ADA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0ADE: 00 00 
  1386                        
  1387                        ; D0< ( d -- flag )
  1388                        ;
  1389                        ; flag is true if and only if d is less than zero.
  1390                        
  1391 00:0AE0: C4 0A 00 03                  HEADER  3,"D0<",NORMAL
       00:0AE4: 44 30 3C 
  1392                        D_ZERO_LESS:
  1393 00:0AE7: A6 01                        ldx     <1                      ; Fetch sign
  1394 00:0AE9: 7B                           tdc                             ; Drop a word
  1395 00:0AEA: 1A                           inc     a
  1396 00:0AEB: 1A                           inc     a
  1397 00:0AEC: 5B                           tcd
  1398 00:0AED: 64 01                        stz     <1                      ; Assume false
  1399 00:0AEF: 8A                           txa
  1400 00:0AF0: 10 02                        bpl     D_ZERO_LESS_1
  1401 00:0AF2: C6 01                        dec     <1
  1402 00:0AF4: BB C8 C8 7C  D_ZERO_LESS_1:  CONTINUE
       00:0AF8: 00 00 
  1403                        
  1404                        ; D0= ( d -- flag )
  1405                        ;
  1406                        ; flag is true if and only if d is equal to zero.
  1407                        
  1408 00:0AFA: E3 0A 00 03                  HEADER  3,"D0=",NORMAL
       00:0AFE: 44 30 3D 
  1409                        D_ZERO_EQUAL:
  1410 00:0B01: A6 01                        ldx     <1                      ; Fetch sign
  1411 00:0B03: 7B                           tdc                             ; Drop a word
  1412 00:0B04: 1A                           inc     a
  1413 00:0B05: 1A                           inc     a
  1414 00:0B06: 5B                           tcd
  1415 00:0B07: 64 01                        stz     <1                      ; Assume false
  1416 00:0B09: 8A                           txa
  1417 00:0B0A: D0 02                        bne     D_ZERO_EQUAL_1
  1418 00:0B0C: C6 01                        dec     <1
  1419 00:0B0E: BB C8 C8 7C  D_ZERO_EQUAL_1: CONTINUE
       00:0B12: 00 00 
  1420                        
  Tue May  3 2016 22:26                                                                                                    Page 30


  1421                        ; D2* ( xd1 -- xd2 )
  1422                        ;
  1423                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1424                        ; filling the vacated least-significant bit with zero.
  1425                        
  1426 00:0B14: FD 0A 00 03                  HEADER  3,"D2*",NORMAL
       00:0B18: 44 32 2A 
  1427                        D_TWO_STAR:
  1428 00:0B1B: 06 03                        asl     <3
  1429 00:0B1D: 26 01                        rol     <1
  1430 00:0B1F: BB C8 C8 7C                  CONTINUE
       00:0B23: 00 00 
  1431                        
  1432                        ; D2/ ( xd1 -- xd2 )
  1433                        ;
  1434                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1435                        ; leaving the most-significant bit unchanged.
  1436                        
  1437 00:0B25: 17 0B 00 03                  HEADER  3,"D2/",NORMAL
       00:0B29: 44 32 2F 
  1438                        D_TWO_SLASH:
  1439 00:0B2C: A5 01                        lda     <1
  1440 00:0B2E: 2A                           rol     a
  1441 00:0B2F: 66 01                        ror     <1
  1442 00:0B31: 66 03                        ror     <3
  1443 00:0B33: BB C8 C8 7C                  CONTINUE
       00:0B37: 00 00 
  1444                        
  1445                        ; D< ( d1 d2 -- flag )
  1446                        ;
  1447                        ; flag is true if and only if d1 is less than d2.
  1448                        
  1449 00:0B39: 28 0B 00 02                  HEADER  2,"D<",NORMAL
       00:0B3D: 44 3C 
  1450 00:0B3F: 20 C1 14     D_LESS:         jsr     DO_COLON
  1451 00:0B42: C7 0A                        dw      D_MINUS
  1452 00:0B44: E7 0A                        dw      D_ZERO_LESS
  1453 00:0B46: E6 0E                        dw      EXIT
  1454                        
  1455                        ; D= ( d1 d2 -- flag )
  1456                        ;
  1457                        ; flag is true if and only if d1 is bit-for-bit the same as d2.
  1458                        
  1459 00:0B48: 3C 0B 00 02                  HEADER  2,"D=",NORMAL
       00:0B4C: 44 3D 
  1460 00:0B4E: 20 C1 14     D_EQUAL:        jsr     DO_COLON
  1461 00:0B51: C7 0A                        dw      D_MINUS
  1462 00:0B53: 01 0B                        dw      D_ZERO_EQUAL
  1463 00:0B55: E6 0E                        dw      EXIT
  1464                        
  1465                        ; DABS ( d -- ud )
  1466                        ;
  1467                        ; ud is the absolute value of d.
  1468                        
  1469 00:0B57: 4B 0B 00 04                  HEADER  4,"DABS",NORMAL
       00:0B5B: 44 41 42 53 
  1470                        DABS:
  1471 00:0B5F: A5 01                        lda     <1
  Tue May  3 2016 22:26                                                                                                    Page 31


  1472 00:0B61: 10 03                        bpl     DABS_1
  1473 00:0B63: 4C AF 0B                     jmp     DNEGATE
  1474 00:0B66: BB C8 C8 7C  DABS_1:         CONTINUE
       00:0B6A: 00 00 
  1475                        
  1476                        ; DMAX ( d1 d2 -- d3 )
  1477                        ;
  1478                        ; d3 is the greater of d1 and d2.
  1479                        
  1480 00:0B6C: 5A 0B 00 04                  HEADER  4,"DMAX",NORMAL
       00:0B70: 44 4D 41 58 
  1481 00:0B74: 20 C1 14     DMAX:           jsr     DO_COLON
  1482 00:0B77: DC 06                        dw      TWO_OVER
  1483 00:0B79: DC 06                        dw      TWO_OVER
  1484 00:0B7B: 3F 0B                        dw      D_LESS
  1485 00:0B7D: 80 16 83 0B                  dw      QUERY_BRANCH,DMAX_1
  1486 00:0B81: 26 07                        dw      TWO_SWAP
  1487 00:0B83: AB 06        DMAX_1:         dw      TWO_DROP
  1488 00:0B85: E6 0E                        dw      EXIT
  1489                        
  1490                        ; DMIN ( d1 d2 -- d3 )
  1491                        ;
  1492                        ; d3 is the lesser of d1 and d2.
  1493                        
  1494 00:0B87: 6F 0B 00 04                  HEADER  4,"DMIN",NORMAL
       00:0B8B: 44 4D 49 4E 
  1495 00:0B8F: 20 C1 14     DMIN:           jsr     DO_COLON
  1496 00:0B92: DC 06                        dw      TWO_OVER
  1497 00:0B94: DC 06                        dw      TWO_OVER
  1498 00:0B96: 3F 0B                        dw      D_LESS
  1499 00:0B98: D7 0D                        dw      INVERT
  1500 00:0B9A: 80 16 A0 0B                  dw      QUERY_BRANCH,DMIN_1
  1501 00:0B9E: 26 07                        dw      TWO_SWAP
  1502 00:0BA0: AB 06        DMIN_1:         dw      TWO_DROP
  1503 00:0BA2: E6 0E                        dw      EXIT
  1504                        
  1505                        ; DNEGATE ( d1 -- d2 )
  1506                        ;
  1507                        ; d2 is the negation of d1.
  1508                        
  1509 00:0BA4: 8A 0B 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0BA8: 44 4E 45 47 
       00:0BAC: 41 54 45 
  1510                        DNEGATE:
  1511 00:0BAF: 38                           sec
  1512 00:0BB0: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1513 00:0BB3: E5 03                        sbc     <3
  1514 00:0BB5: 85 03                        sta     <3
  1515 00:0BB7: A9 00 00                     lda     #0                      ; Then the high word
  1516 00:0BBA: E5 01                        sbc     <1
  1517 00:0BBC: 85 01                        sta     <1
  1518 00:0BBE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0BC2: 00 00 
  1519                        
  1520                        ;===============================================================================
  1521                        ; Mixed Arithmetic
  1522                        ;-------------------------------------------------------------------------------
  1523                        
  Tue May  3 2016 22:26                                                                                                    Page 32


  1524                        ; D>S ( d -- n )
  1525                        ;
  1526                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1527                        ; range of a signed single-cell number.
  1528                        
  1529 00:0BC4: A7 0B 00 03                  HEADER  3,"D>S",NORMAL
       00:0BC8: 44 3E 53 
  1530                        D_TO_S:
  1531 00:0BCB: 7B                           tdc
  1532 00:0BCC: 1A                           inc     a                       ; Drop the high word
  1533 00:0BCD: 1A                           inc     a
  1534 00:0BCE: 5B                           tcd
  1535 00:0BCF: BB C8 C8 7C                  CONTINUE
       00:0BD3: 00 00 
  1536                        
  1537                        ; M* ( n1 n2 -- d )
  1538                        ;
  1539                        ; d is the signed product of n1 times n2.
  1540                        ;
  1541                        ; In this implementation it is defined as:
  1542                        ;
  1543                        ;   2DUP XOR >R                 carries sign of the result
  1544                        ;   SWAP ABS SWAP ABS UM*
  1545                        ;   R> ?DNEGATE
  1546                        
  1547 00:0BD5: C7 0B 00 02                  HEADER  2,"M*",NORMAL
       00:0BD9: 4D 2A 
  1548 00:0BDB: 20 C1 14     M_STAR:         jsr     DO_COLON
  1549 00:0BDE: BF 06                        dw      TWO_DUP
  1550 00:0BE0: 59 0E                        dw      XOR
  1551 00:0BE2: 7E 08                        dw      TO_R
  1552 00:0BE4: 0C 08                        dw      SWAP
  1553 00:0BE6: B9 09                        dw      ABS
  1554 00:0BE8: 0C 08                        dw      SWAP
  1555 00:0BEA: B9 09                        dw      ABS
  1556 00:0BEC: 7C 0C                        dw      UM_STAR
  1557 00:0BEE: B7 08                        dw      R_FROM
  1558 00:0BF0: 95 0A                        dw      QUERY_DNEGATE
  1559 00:0BF2: E6 0E                        dw      EXIT
  1560                        
  1561                        ; M*/ ( d1 n1 +n2 -- d2 )
  1562                        ;
  1563                        ; Multiply d1 by n1 producing the triple-cell intermediate result t. Divide t
  1564                        ; by +n2 giving the double-cell quotient d2. An ambiguous condition exists if
  1565                        ; +n2 is zero or negative, or the quotient lies outside of the range of a
  1566                        ; double-precision signed integer.
  1567                        
  1568                        
  1569                        
  1570                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1571                        ;
  1572                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1573                        
  1574 00:0BF4: D8 0B 00 02                  HEADER  2,"M+",NORMAL
       00:0BF8: 4D 2B 
  1575                        M_PLUS:
  1576 00:0BFA: 18                           clc
  1577 00:0BFB: A5 01                        lda     <1
  Tue May  3 2016 22:26                                                                                                    Page 33


  1578 00:0BFD: 65 05                        adc     <5
  1579 00:0BFF: 85 05                        sta     <5
  1580 00:0C01: 90 02                        bcc     $+4
  1581 00:0C03: E6 03                        inc     <3
  1582 00:0C05: 7B                           tdc
  1583 00:0C06: 1A                           inc     a
  1584 00:0C07: 1A                           inc     a
  1585 00:0C08: 5B                           tcd
  1586 00:0C09: BB C8 C8 7C                  CONTINUE
       00:0C0D: 00 00 
  1587                        
  1588                        ; S>D ( n -- d )
  1589                        ;
  1590                        ; Convert the number n to the double-cell number d with the same numerical
  1591                        ; value.
  1592                        
  1593 00:0C0F: F7 0B 00 03                  HEADER  3,"S>D",NORMAL
       00:0C13: 53 3E 44 
  1594                        S_TO_D:
  1595 00:0C16: 7B                           tdc
  1596 00:0C17: 3A                           dec     a                       ; Assume n is positive
  1597 00:0C18: 3A                           dec     a
  1598 00:0C19: 5B                           tcd
  1599 00:0C1A: 64 01                        stz     <1                      ; .. push a zero value
  1600 00:0C1C: A5 03                        lda     <3                      ; Test the number
  1601 00:0C1E: 10 02                        bpl     S_TO_D_1
  1602 00:0C20: C6 01                        dec     <1                      ; Make top -1 if negative
  1603 00:0C22: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0C26: 00 00 
  1604                        
  1605                        ; SM/REM ( d1 n1 -- n2 n3 )
  1606                        ;
  1607                        ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
  1608                        ; Input and output stack arguments are signed. An ambiguous condition exists if
  1609                        ; n1 is zero or if the quotient lies outside the range of a single-cell signed
  1610                        ; integer.
  1611                        ;
  1612                        ; In this implementation it is defined as:
  1613                        ;
  1614                        ;   2DUP XOR >R                 sign of quotient
  1615                        ;   OVER >R                     sign of remainder
  1616                        ;   ABS >R DABS R> UM/MOD
  1617                        ;   SWAP R> ?NEGATE
  1618                        ;   SWAP R> ?NEGATE ;
  1619                        
  1620 00:0C28: 12 0C 00 06                  HEADER  6,"SM/REM",NORMAL
       00:0C2C: 53 4D 2F 52 
       00:0C30: 45 4D 
  1621 00:0C32: 20 C1 14     SM_SLASH_REM:   jsr     DO_COLON
  1622 00:0C35: BF 06                        dw      TWO_DUP
  1623 00:0C37: 59 0E                        dw      XOR
  1624 00:0C39: 7E 08                        dw      TO_R
  1625 00:0C3B: A8 07                        dw      OVER
  1626 00:0C3D: 7E 08                        dw      TO_R
  1627 00:0C3F: B9 09                        dw      ABS
  1628 00:0C41: 7E 08                        dw      TO_R
  1629 00:0C43: 5F 0B                        dw      DABS
  1630 00:0C45: B7 08                        dw      R_FROM
  Tue May  3 2016 22:26                                                                                                    Page 34


  1631 00:0C47: A8 0C                        dw      UM_SLASH_MOD
  1632 00:0C49: 0C 08                        dw      SWAP
  1633 00:0C4B: B7 08                        dw      R_FROM
  1634 00:0C4D: A5 09                        dw      QUERY_NEGATE
  1635 00:0C4F: 0C 08                        dw      SWAP
  1636 00:0C51: B7 08                        dw      R_FROM
  1637 00:0C53: A5 09                        dw      QUERY_NEGATE
  1638 00:0C55: E6 0E                        dw      EXIT
  1639                        
  1640                        ; UD* ( ud1 d2 -- ud3)
  1641                        ;
  1642                        ; 32*16->32 multiply
  1643                        ;
  1644                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1645                        
  1646 00:0C57: 2B 0C 00 03                  HEADER  3,"UD*",NORMAL
       00:0C5B: 55 44 2A 
  1647 00:0C5E: 20 C1 14     UD_STAR:        jsr     DO_COLON
  1648 00:0C61: 85 07                        dw      DUP
  1649 00:0C63: 7E 08                        dw      TO_R
  1650 00:0C65: 7C 0C                        dw      UM_STAR
  1651 00:0C67: 74 07                        dw      DROP
  1652 00:0C69: 0C 08                        dw      SWAP
  1653 00:0C6B: B7 08                        dw      R_FROM
  1654 00:0C6D: 7C 0C                        dw      UM_STAR
  1655 00:0C6F: F2 07                        dw      ROT
  1656 00:0C71: 18 09                        dw      PLUS
  1657 00:0C73: E6 0E                        dw      EXIT
  1658                        
  1659                        ; UM* ( u1 u2 -- ud )
  1660                        ;
  1661                        ; Multiply u1 by u2, giving the unsigned double-cell product ud. All values and
  1662                        ; arithmetic are unsigned.
  1663                        
  1664 00:0C75: 5A 0C 00 03                  HEADER  3,"UM*",NORMAL
       00:0C79: 55 4D 2A 
  1665                        UM_STAR:
  1666 00:0C7C: A5 01                        lda     <1                      ; Fetch multiplier
  1667 00:0C7E: 48                           pha
  1668 00:0C7F: 64 01                        stz     <1                      ; Clear the result
  1669 00:0C81: A2 10 00                     ldx     #16
  1670 00:0C84: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1671 00:0C86: 4A                           lsr     a
  1672 00:0C87: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1673 00:0C89: A3 01                        lda     1,s                     ; Fetch multiplicand
  1674 00:0C8B: 18                           clc
  1675 00:0C8C: 65 01                        adc     <1
  1676 00:0C8E: 85 01                        sta     <1
  1677 00:0C90: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1678 00:0C92: 66 03                        ror     <3
  1679 00:0C94: CA                           dex
  1680 00:0C95: D0 ED                        bne     UM_STAR_1
  1681 00:0C97: 68                           pla
  1682 00:0C98: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C9C: 00 00 
  1683                        
  1684                        ; UM/MOD ( ud u1 -- u2 u3 )
  1685                        ;
  Tue May  3 2016 22:26                                                                                                    Page 35


  1686                        ; Divide ud by u1, giving the quotient u3 and the remainder u2. All values and
  1687                        ; arithmetic are unsigned. An ambiguous condition exists if u1 is zero or if the
  1688                        ; quotient lies outside the range of a single-cell unsigned integer.
  1689                        
  1690 00:0C9E: 78 0C 00 06                  HEADER  6,"UM/MOD",NORMAL
       00:0CA2: 55 4D 2F 4D 
       00:0CA6: 4F 44 
  1691                        UM_SLASH_MOD:
  1692 00:0CA8: 38                           sec                             ; Check for overflow
  1693 00:0CA9: A5 03                        lda     <3
  1694 00:0CAB: E5 01                        sbc     <1
  1695 00:0CAD: B0 1A                        bcs     UM_SLASH_MOD_3
  1696                        
  1697 00:0CAF: A2 11 00                     ldx     #17
  1698 00:0CB2: 26 05        UM_SLASH_MOD_1: rol     <5                      ; Rotate dividend lo
  1699 00:0CB4: CA                           dex
  1700 00:0CB5: F0 19                        beq     UM_SLASH_MOD_4
  1701 00:0CB7: 26 03                        rol     <3
  1702 00:0CB9: B0 06                        bcs     UM_SLASH_MOD_2          ; Carry set dividend > divisor
  1703                        
  1704 00:0CBB: A5 03                        lda     <3                      ; Is dividend < divisor?
  1705 00:0CBD: C5 01                        cmp     <1
  1706 00:0CBF: 90 F1                        bcc     UM_SLASH_MOD_1          ; Yes, shift in 0
  1707                        
  1708 00:0CC1: A5 03        UM_SLASH_MOD_2: lda     <3                      ; Reduce dividend
  1709 00:0CC3: E5 01                        sbc     <1
  1710 00:0CC5: 85 03                        sta     <3
  1711 00:0CC7: 80 E9                        bra     UM_SLASH_MOD_1          ; Shift in 1
  1712                        
  1713 00:0CC9: A9 FF FF     UM_SLASH_MOD_3: lda     #$ffff                  ; Overflowed set results
  1714 00:0CCC: 85 03                        sta     <3
  1715 00:0CCE: 85 05                        sta     <5
  1716 00:0CD0: 7B           UM_SLASH_MOD_4: tdc                             ; Drop top word
  1717 00:0CD1: 1A                           inc     a
  1718 00:0CD2: 1A                           inc     a
  1719 00:0CD3: 5B                           tcd
  1720 00:0CD4: 4C 0C 08                     jmp     SWAP                    ; Swap quotient and remainder
  1721                        
  1722                        ;===============================================================================
  1723                        ; Comparisons
  1724                        ;-------------------------------------------------------------------------------
  1725                        
  1726                        ; 0< ( n -- flag )
  1727                        ;
  1728                        ; flag is true if and only if n is less than zero.
  1729                        
  1730 00:0CD7: A1 0C 00 02                  HEADER  2,"0<",NORMAL
       00:0CDB: 30 3C 
  1731                        ZERO_LESS:
  1732 00:0CDD: A5 01                        lda     <1                      ; Test top of stack
  1733 00:0CDF: 64 01                        stz     <1                      ; Assume false result
  1734 00:0CE1: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1735 00:0CE3: C6 01                        dec     <1                      ; Yes, make true result
  1736 00:0CE5: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0CE9: 00 00 
  1737                        
  1738                        ; 0<> ( x -- flag )
  1739                        ;
  Tue May  3 2016 22:26                                                                                                    Page 36


  1740                        ; flag is true if and only if x is not equal to zero.
  1741                        
  1742 00:0CEB: DA 0C 00 03                  HEADER  3,"0<>",NORMAL
       00:0CEF: 30 3C 3E 
  1743                        ZERO_NOT_EQUAL:
  1744 00:0CF2: A5 01                        lda     <1                      ; Test top of stack
  1745 00:0CF4: 64 01                        stz     <1                      ; Assume false result
  1746 00:0CF6: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1747 00:0CF8: C6 01                        dec     <1                      ; Yes, make true result
  1748 00:0CFA: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0CFE: 00 00 
  1749                        
  1750                        ; 0= ( x -- flag )
  1751                        ;
  1752                        ; flag is true if and only if x is equal to zero.
  1753                        
  1754 00:0D00: EE 0C 00 02                  HEADER  2,"0=",NORMAL
       00:0D04: 30 3D 
  1755                        ZERO_EQUAL:
  1756 00:0D06: A5 01                        lda     <1                      ; Test top of stack
  1757 00:0D08: 64 01                        stz     <1                      ; Assume false result
  1758 00:0D0A: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1759 00:0D0C: C6 01                        dec     <1                      ; Yes, make true result
  1760 00:0D0E: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0D12: 00 00 
  1761                        
  1762                        ; 0> ( n -- flag )
  1763                        ;
  1764                        ; flag is true if and only if n is greater than zero.
  1765                        
  1766 00:0D14: 03 0D 00 02                  HEADER  2,"0>",NORMAL
       00:0D18: 30 3E 
  1767                        ZERO_GREATER:
  1768 00:0D1A: A5 01                        lda     <1                      ; Test top of stack
  1769 00:0D1C: 64 01                        stz     <1                      ; Assume false result
  1770 00:0D1E: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1771 00:0D20: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1772 00:0D22: C6 01                        dec     <1                      ; Yes, make true result
  1773 00:0D24: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0D28: 00 00 
  1774                        
  1775                        ; < ( n1 n2 -- flag )
  1776                        ;
  1777                        ; flag is true if and only if n1 is less than n2.
  1778                        
  1779 00:0D2A: 17 0D 00 01                  HEADER  1,"<",NORMAL
       00:0D2E: 3C 
  1780 00:0D2F: 20 C1 14     LESS:           jsr     DO_COLON
  1781 00:0D32: 0C 08                        dw      SWAP
  1782 00:0D34: 70 0D                        dw      GREATER
  1783 00:0D36: E6 0E                        dw      EXIT
  1784                        
  1785                        ; <> ( x1 x2 -- flag )
  1786                        ;
  1787                        ; flag is true if and only if x1 is not bit-for-bit the same as x2.
  1788                        
  1789 00:0D38: 2D 0D 00 02                  HEADER  2,"<>",NORMAL
       00:0D3C: 3C 3E 
  Tue May  3 2016 22:26                                                                                                    Page 37


  1790                        NOT_EQUAL:
  1791 00:0D3E: A6 01                        ldx     <1                      ; Pull x2 from stack
  1792 00:0D40: 7B                           tdc
  1793 00:0D41: 1A                           inc     a
  1794 00:0D42: 1A                           inc     a
  1795 00:0D43: 5B                           tcd
  1796 00:0D44: E4 01                        cpx     <1                      ; Compare with x1
  1797 00:0D46: 64 01                        stz     <1                      ; Assume equal
  1798 00:0D48: F0 02                        beq     NE_EXIT                 ; Test flags
  1799 00:0D4A: C6 01                        dec     <1                      ; Make result true
  1800 00:0D4C: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0D50: 00 00 
  1801                        
  1802                        ; = ( x1 x2 -- flag )
  1803                        ;
  1804                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1805                        
  1806 00:0D52: 3B 0D 00 01                  HEADER  1,"=",NORMAL
       00:0D56: 3D 
  1807                        EQUAL:
  1808 00:0D57: A6 01                        ldx     <1                      ; Pull x2 from stack
  1809 00:0D59: 7B                           tdc
  1810 00:0D5A: 1A                           inc     a
  1811 00:0D5B: 1A                           inc     a
  1812 00:0D5C: 5B                           tcd
  1813 00:0D5D: E4 01                        cpx     <1                      ; Compare with x1
  1814 00:0D5F: 64 01                        stz     <1                      ; Assume not equal
  1815 00:0D61: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1816 00:0D63: C6 01                        dec     <1                      ; Make result true
  1817 00:0D65: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0D69: 00 00 
  1818                        
  1819                        ; > ( n1 n2 -- flag )
  1820                        ;
  1821                        ; flag is true if and only if n1 is greater than n2.
  1822                        
  1823 00:0D6B: 55 0D 00 01                  HEADER  1,">",NORMAL
       00:0D6F: 3E 
  1824                        GREATER:
  1825 00:0D70: A6 01                        ldx     <1                      ; Pull x2 from stack
  1826 00:0D72: 7B                           tdc
  1827 00:0D73: 1A                           inc     a
  1828 00:0D74: 1A                           inc     a
  1829 00:0D75: 5B                           tcd
  1830 00:0D76: 8A                           txa
  1831 00:0D77: 38                           sec                             ; Compare with x1
  1832 00:0D78: E5 01                        sbc     <1
  1833 00:0D7A: 64 01                        stz     <1                      ; Assume false result
  1834 00:0D7C: 50 03                        bvc     GREATER_1
  1835 00:0D7E: 49 00 80                     eor     #$8000
  1836 00:0D81: 10 02        GREATER_1:      bpl     GREATER_2               ; V == 1 && N == 1
  1837 00:0D83: C6 01                        dec     <1
  1838 00:0D85: BB C8 C8 7C  GREATER_2:      CONTINUE
       00:0D89: 00 00 
  1839                        
  1840                        ; U< ( u1 u2 -- flag )
  1841                        ;
  1842                        ; flag is true if and only if u1 is less than u2.
  Tue May  3 2016 22:26                                                                                                    Page 38


  1843                        
  1844 00:0D8B: 6E 0D 00 02                  HEADER  2,"U<",NORMAL
       00:0D8F: 55 3C 
  1845                        U_LESS:
  1846 00:0D91: A6 01                        ldx     <1                      ; Pull x2
  1847 00:0D93: 7B                           tdc                             ; Drop from stack
  1848 00:0D94: 1A                           inc     a
  1849 00:0D95: 1A                           inc     a
  1850 00:0D96: 5B                           tcd
  1851 00:0D97: E4 01                        cpx     <1                      ; Compare with x1
  1852 00:0D99: 64 01                        stz     <1                      ; Assume false
  1853 00:0D9B: F0 04                        beq     U_LESS_1                ; Equal
  1854 00:0D9D: 90 02                        bcc     U_LESS_1                ; Less
  1855 00:0D9F: C6 01                        dec     <1
  1856 00:0DA1: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0DA5: 00 00 
  1857                        
  1858                        ; U> ( u1 u2 -- flag )
  1859                        ;
  1860                        ; flag is true if and only if u1 is greater than u2.
  1861                        
  1862 00:0DA7: 8E 0D 00 02                  HEADER  2,"U>",NORMAL
       00:0DAB: 55 3E 
  1863 00:0DAD: 20 C1 14     U_GREATER:      jsr     DO_COLON
  1864 00:0DB0: 0C 08                        dw      SWAP
  1865 00:0DB2: 91 0D                        dw      U_LESS
  1866 00:0DB4: E6 0E                        dw      EXIT
  1867                        
  1868                        ;===============================================================================
  1869                        ; Logical Operations
  1870                        ;-------------------------------------------------------------------------------
  1871                        
  1872                        ; AND ( x1 x2 -- x3 )
  1873                        ;
  1874                        ; x3 is the bit-by-bit logical “and” of x1 with x2.
  1875                        
  1876 00:0DB6: AA 0D 00 03                  HEADER  3,"AND",NORMAL
       00:0DBA: 41 4E 44 
  1877                        AND:
  1878 00:0DBD: A5 01                        lda     <1
  1879 00:0DBF: 25 03                        and     <3
  1880 00:0DC1: 85 03                        sta     <3
  1881 00:0DC3: 7B                           tdc
  1882 00:0DC4: 1A                           inc     a
  1883 00:0DC5: 1A                           inc     a
  1884 00:0DC6: 5B                           tcd
  1885 00:0DC7: BB C8 C8 7C                  CONTINUE
       00:0DCB: 00 00 
  1886                        
  1887                        ; INVERT ( x1 -- x2 )
  1888                        ;
  1889                        ; Invert all bits of x1, giving its logical inverse x2.
  1890                        
  1891 00:0DCD: B9 0D 00 06                  HEADER  6,"INVERT",NORMAL
       00:0DD1: 49 4E 56 45 
       00:0DD5: 52 54 
  1892                        INVERT:
  1893 00:0DD7: A5 01                        lda     <1                      ; Fetch top value
  Tue May  3 2016 22:26                                                                                                    Page 39


  1894 00:0DD9: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1895 00:0DDC: 85 01                        sta     <1                      ; .. and write back
  1896 00:0DDE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0DE2: 00 00 
  1897                        
  1898                        ; LSHIFT ( x1 u -- x2 )
  1899                        ;
  1900                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1901                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1902                        ; exists if u is greater than or equal to the number of bits in a cell.
  1903                        
  1904 00:0DE4: D0 0D 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:0DE8: 4C 53 48 49 
       00:0DEC: 46 54 
  1905                        LSHIFT:
  1906 00:0DEE: A6 01                        ldx     <1                      ; Pull bit count
  1907 00:0DF0: 08                           php
  1908 00:0DF1: 7B                           tdc
  1909 00:0DF2: 1A                           inc     a                       ; .. from the stack
  1910 00:0DF3: 1A                           inc     a
  1911 00:0DF4: 5B                           tcd
  1912 00:0DF5: 28                           plp
  1913 00:0DF6: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1914 00:0DF8: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1915 00:0DFB: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1916 00:0DFD: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1917 00:0DFF: CA                           dex                             ; Update count
  1918 00:0E00: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1919 00:0E02: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0E06: 00 00 
  1920 00:0E08: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1921 00:0E0A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0E0E: 00 00 
  1922                        
  1923                        ; OR ( x1 x2 -- x3 )
  1924                        ;
  1925                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1926                        
  1927 00:0E10: E7 0D 00 02                  HEADER  2,"OR",NORMAL
       00:0E14: 4F 52 
  1928                        OR:
  1929 00:0E16: A5 01                        lda     <1
  1930 00:0E18: 05 03                        ora     <3
  1931 00:0E1A: 85 03                        sta     <3
  1932 00:0E1C: 7B                           tdc
  1933 00:0E1D: 1A                           inc     a
  1934 00:0E1E: 1A                           inc     a
  1935 00:0E1F: 5B                           tcd
  1936 00:0E20: BB C8 C8 7C                  CONTINUE
       00:0E24: 00 00 
  1937                        
  1938                        ; RSHIFT ( x1 u -- x2 )
  1939                        ;
  1940                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1941                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1942                        ; exists if u is greater than or equal to the number of bits in a cell.
  1943                        
  1944 00:0E26: 13 0E 00 06                  HEADER  6,"RSHIFT",NORMAL
  Tue May  3 2016 22:26                                                                                                    Page 40


       00:0E2A: 52 53 48 49 
       00:0E2E: 46 54 
  1945                        RSHIFT:
  1946 00:0E30: A6 01                        ldx     <1                      ; Pull bit count
  1947 00:0E32: 08                           php
  1948 00:0E33: 7B                           tdc
  1949 00:0E34: 1A                           inc     a                       ; .. from the stack
  1950 00:0E35: 1A                           inc     a
  1951 00:0E36: 5B                           tcd
  1952 00:0E37: 28                           plp
  1953 00:0E38: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1954 00:0E3A: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1955 00:0E3D: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1956 00:0E3F: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1957 00:0E41: CA                           dex                             ; Update count
  1958 00:0E42: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1959 00:0E44: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0E48: 00 00 
  1960 00:0E4A: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1961 00:0E4C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0E50: 00 00 
  1962                        
  1963                        ; XOR ( x1 x2 -- x3 )
  1964                        ;
  1965                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1966                        
  1967 00:0E52: 29 0E 00 03                  HEADER  3,"XOR",NORMAL
       00:0E56: 58 4F 52 
  1968                        XOR:
  1969 00:0E59: A5 01                        lda     <1
  1970 00:0E5B: 45 03                        eor     <3
  1971 00:0E5D: 85 03                        sta     <3
  1972 00:0E5F: 7B                           tdc
  1973 00:0E60: 1A                           inc     a
  1974 00:0E61: 1A                           inc     a
  1975 00:0E62: 5B                           tcd
  1976 00:0E63: BB C8 C8 7C                  CONTINUE
       00:0E67: 00 00 
  1977                        
  1978                        ;===============================================================================
  1979                        ; Control Words
  1980                        ;-------------------------------------------------------------------------------
  1981                        
  1982                        ; ?ABORT
  1983                        ;
  1984                        ;   ROT IF TYPE ABORT THEN 2DROP ;
  1985                        
  1986 00:0E69: 20 C1 14     QUERY_ABORT:    jsr     DO_COLON
  1987 00:0E6C: F2 07                        dw      ROT
  1988 00:0E6E: 80 16 76 0E                  dw      QUERY_BRANCH,QUERY_ABORT_1
  1989 00:0E72: FF 18                        dw      TYPE
  1990 00:0E74: 83 0E                        dw      ABORT
  1991 00:0E76: AB 06        QUERY_ABORT_1:  dw      TWO_DROP
  1992 00:0E78: E6 0E                        dw      EXIT
  1993                        
  1994                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1995                        ;
  1996                        ; Empty the data stack and perform the function of QUIT, which includes
  Tue May  3 2016 22:26                                                                                                    Page 41


  1997                        ; emptying the return stack, without displaying a message.
  1998                        
  1999 00:0E7A: 55 0E 00 05                  HEADER  5,"ABORT",NORMAL
       00:0E7E: 41 42 4F 52 
       00:0E82: 54 
  2000 00:0E83: 20 C1 14     ABORT:          jsr     DO_COLON
  2001 00:0E86: 8A 0E                        dw      DO_ABORT
  2002 00:0E88: F5 0E                        dw      QUIT
  2003                        
  2004                        DO_ABORT:
  2005 00:0E8A: A9 7F 01                     lda     #DSTACK_END-1
  2006 00:0E8D: 5B                           tcd
  2007 00:0E8E: BB C8 C8 7C                  CONTINUE
       00:0E92: 00 00 
  2008                        
  2009                        ; (BUILD) ( dtc-addr -- )
  2010                        ;
  2011                        ; Adds a jump the to exection function for the new word.
  2012                        
  2013                        ;               HEADER  7,"(BUILD)",NORMAL
  2014 00:0E94: 20 C1 14     BUILD:          jsr     DO_COLON
  2015 00:0E97: C7 16 20 00                  dw      DO_LITERAL,$20
  2016 00:0E9B: F5 05                        dw      C_COMMA
  2017 00:0E9D: 79 05                        dw      COMMA
  2018 00:0E9F: E6 0E                        dw      EXIT
  2019                        
  2020                        ; CREATE ( -- )
  2021                        ;
  2022                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2023                        ; definition for name with the execution semantics defined below. If the data-
  2024                        ; space pointer is not aligned, reserve enough data space to align it. The new
  2025                        ; data-space pointer defines name’s data field. CREATE does not allocate data
  2026                        ; space in name’s data field.
  2027                        
  2028 00:0EA1: 7D 0E 00 06                  HEADER  6,"CREATE",NORMAL
       00:0EA5: 43 52 45 41 
       00:0EA9: 54 45 
  2029 00:0EAB: 20 C1 14     CREATE:         jsr     DO_COLON
  2030 00:0EAE: 94 04                        dw      LATEST
  2031 00:0EB0: B9 05                        dw      FETCH
  2032 00:0EB2: 79 05                        dw      COMMA
  2033 00:0EB4: CE 04                        dw      ZERO
  2034 00:0EB6: F5 05                        dw      C_COMMA
  2035 00:0EB8: 24 06                        dw      HERE
  2036 00:0EBA: 94 04                        dw      LATEST
  2037 00:0EBC: 4B 05                        dw      STORE
  2038 00:0EBE: E0 04                        dw      BL
  2039 00:0EC0: B4 12                        dw      WORD
  2040 00:0EC2: 0C 06                        dw      C_FETCH
  2041 00:0EC4: 70 09                        dw      ONE_PLUS
  2042 00:0EC6: CC 05                        dw      ALLOT
  2043 00:0EC8: E6 0E                        dw      EXIT
  2044                        
  2045                        ; EXECUTE ( i*x xt -- j*x )
  2046                        ;
  2047                        ; Remove xt from the stack and perform the semantics identified by it. Other
  2048                        ; stack effects are due to the word EXECUTEd.
  2049                        
  Tue May  3 2016 22:26                                                                                                    Page 42


  2050 00:0ECA: A4 0E 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0ECE: 45 58 45 43 
       00:0ED2: 55 54 45 
  2051                        EXECUTE:
  2052 00:0ED5: A6 01                        ldx     <1
  2053 00:0ED7: 7B                           tdc
  2054 00:0ED8: 1A                           inc     a
  2055 00:0ED9: 1A                           inc     a
  2056 00:0EDA: 5B                           tcd
  2057 00:0EDB: CA                           dex
  2058 00:0EDC: DA                           phx
  2059 00:0EDD: 60                           rts
  2060                        
  2061                        ; EXIT ( -- ) ( R: nest-sys -- )
  2062                        ;
  2063                        ; Return control to the calling definition specified by nest-sys. Before
  2064                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  2065                        ; parameters by executing UNLOOP.
  2066                        
  2067 00:0EDE: CD 0E 00 04                  HEADER  4,"EXIT",NORMAL
       00:0EE2: 45 58 49 54 
  2068                        EXIT:
  2069 00:0EE6: 7A                           ply
  2070 00:0EE7: BB C8 C8 7C                  CONTINUE
       00:0EEB: 00 00 
  2071                        
  2072                        ; QUIT ( -- ) ( R: i*x -- )
  2073                        ;
  2074                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  2075                        ; user input device the input source, and enter interpretation state. Do not
  2076                        ; display a message. Repeat the following:
  2077                        ; – Accept a line from the input source into the input buffer, set >IN to zero,
  2078                        ;   and interpret.
  2079                        ; – Display the implementation-defined system prompt if in interpretation state,
  2080                        ;   all processing has been completed, and no ambiguous condition exists.
  2081                        ;
  2082                        ; In this implementation it is defined as:
  2083                        ;
  2084                        ;   DO_QUIT 0 STATE !
  2085                        ;   0 (SOURCE-ID) !
  2086                        ;   BEGIN
  2087                        ;     REFILL
  2088                        ;     WHILE SOURCE EVALUATE
  2089                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  2090                        ;   AGAIN ;
  2091                        
  2092 00:0EED: E1 0E 00 04                  HEADER  4,"QUIT",NORMAL
       00:0EF1: 51 55 49 54 
  2093 00:0EF5: 20 C1 14     QUIT:           jsr     DO_COLON
  2094 00:0EF8: 25 0F                        dw      DO_QUIT
  2095 00:0EFA: CE 04                        dw      ZERO
  2096 00:0EFC: B8 04                        dw      STATE
  2097 00:0EFE: 4B 05                        dw      STORE
  2098 00:0F00: CE 04                        dw      ZERO
  2099 00:0F02: AA 04                        dw      SOURCEID
  2100 00:0F04: 4B 05                        dw      STORE
  2101 00:0F06: AF 11        QUIT_1:         dw      REFILL
  2102 00:0F08: 80 16 0E 0F                  dw      QUERY_BRANCH,QUIT_2
  Tue May  3 2016 22:26                                                                                                    Page 43


  2103 00:0F0C: E6 10                        dw      INTERPRET
  2104 00:0F0E: B8 04        QUIT_2:         dw      STATE
  2105 00:0F10: B9 05                        dw      FETCH
  2106 00:0F12: 06 0D                        dw      ZERO_EQUAL
  2107 00:0F14: 80 16 21 0F                  dw      QUERY_BRANCH,QUIT_3
  2108 00:0F18: 82 17                        dw      DO_S_QUOTE
  2109 00:0F1A: 02 4F 6B                     db      2,"Ok"
  2110 00:0F1D: FF 18                        dw      TYPE
  2111 00:0F1F: 82 18                        dw      CR
  2112 00:0F21: 5F 16 06 0F  QUIT_3:         dw      BRANCH,QUIT_1
  2113                        
  2114                        DO_QUIT:
  2115 00:0F25: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  2116 00:0F28: 1B                           tcs
  2117 00:0F29: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0F2D: 00 00 
  2118                        
  2119                        ;===============================================================================
  2120                        ; Parser & Interpreter
  2121                        ;-------------------------------------------------------------------------------
  2122                        
  2123                        ; ?NUMBER
  2124                        ;
  2125                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  2126                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  2127                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  2128                        ;   ELSE 2DROP NIP R>
  2129                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  2130                        ;   THEN ;
  2131                        
  2132 00:0F2F: F0 0E 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0F33: 3F 4E 55 4D 
       00:0F37: 42 45 52 
  2133 00:0F3A: 20 C1 14     QUERY_NUMBER:   jsr     DO_COLON
  2134 00:0F3D: 85 07                        dw      DUP
  2135 00:0F3F: CE 04                        dw      ZERO
  2136 00:0F41: CE 04                        dw      ZERO
  2137 00:0F43: F2 07                        dw      ROT
  2138 00:0F45: 0D 14                        dw      COUNT
  2139 00:0F47: 78 0F                        dw      QUERY_SIGN
  2140 00:0F49: 7E 08                        dw      TO_R
  2141 00:0F4B: BF 0F                        dw      TO_NUMBER
  2142 00:0F4D: 80 16 5D 0F                  dw      QUERY_BRANCH,QNUM_1
  2143 00:0F51: B7 08                        dw      R_FROM
  2144 00:0F53: AB 06                        dw      TWO_DROP
  2145 00:0F55: AB 06                        dw      TWO_DROP
  2146 00:0F57: CE 04                        dw      ZERO
  2147 00:0F59: 5F 16 6D 0F                  dw      BRANCH,QNUM_3
  2148 00:0F5D: AB 06        QNUM_1:         dw      TWO_DROP
  2149 00:0F5F: 9A 07                        dw      NIP
  2150 00:0F61: B7 08                        dw      R_FROM
  2151 00:0F63: 80 16 69 0F                  dw      QUERY_BRANCH,QNUM_2
  2152 00:0F67: 5F 0A                        dw      NEGATE
  2153 00:0F69: C7 16 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  2154 00:0F6D: E6 0E        QNUM_3:         dw      EXIT
  2155                        
  2156                        ; ?SIGN ( c-addr n -- adr' n' f )
  2157                        ;
  Tue May  3 2016 22:26                                                                                                    Page 44


  2158                        ;   OVER C@                 -- adr n c
  2159                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  2160                        ;   DUP IF 1+               -- +=0, -=+2
  2161                        ;       >R 1 /STRING R>     -- adr' n' f
  2162                        ;   THEN ;
  2163                        
  2164 00:0F6F: 32 0F 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0F73: 3F 53 49 47 
       00:0F77: 4E 
  2165 00:0F78: 20 C1 14     QUERY_SIGN:     jsr     DO_COLON
  2166 00:0F7B: A8 07                        dw      OVER
  2167 00:0F7D: 0C 06                        dw      C_FETCH
  2168 00:0F7F: C7 16 2C 00                  dw      DO_LITERAL,','
  2169 00:0F83: 2E 09                        dw      MINUS
  2170 00:0F85: 85 07                        dw      DUP
  2171 00:0F87: B9 09                        dw      ABS
  2172 00:0F89: C7 16 01 00                  dw      DO_LITERAL,1
  2173 00:0F8D: 57 0D                        dw      EQUAL
  2174 00:0F8F: BD 0D                        dw      AND
  2175 00:0F91: 85 07                        dw      DUP
  2176 00:0F93: 80 16 A3 0F                  dw      QUERY_BRANCH,QSIGN_1
  2177 00:0F97: 70 09                        dw      ONE_PLUS
  2178 00:0F99: 7E 08                        dw      TO_R
  2179 00:0F9B: C7 16 01 00                  dw      DO_LITERAL,1
  2180 00:0F9F: 30 13                        dw      SLASH_STRING
  2181 00:0FA1: B7 08                        dw      R_FROM
  2182 00:0FA3: E6 0E        QSIGN_1:        dw      EXIT
  2183                        
  2184                        ; >COUNTED ( c-addr n -- )
  2185                        ;
  2186                        ;   2DUP C! CHAR+ SWAP CMOVE
  2187                        
  2188 00:0FA5: 20 C1 14     TO_COUNTED:     jsr     DO_COLON
  2189 00:0FA8: BF 06                        dw      TWO_DUP
  2190 00:0FAA: DB 05                        dw      C_STORE
  2191 00:0FAC: 7A 06                        dw      CHAR_PLUS
  2192 00:0FAE: 0C 08                        dw      SWAP
  2193 00:0FB0: 74 13                        dw      CMOVE
  2194 00:0FB2: E6 0E                        dw      EXIT
  2195                        
  2196                        ; >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
  2197                        ;
  2198                        ; ud2 is the unsigned result of converting the characters within the string
  2199                        ; specified by c-addr1 u1 into digits, using the number in BASE, and adding
  2200                        ; each into ud1 after multiplying ud1 by the number in BASE. Conversion
  2201                        ; continues left-to-right until a character that is not convertible, including
  2202                        ; any “+” or “-”, is encountered or the string is entirely converted. c-addr2
  2203                        ; is the location of the first unconverted character or the first character
  2204                        ; past the end of the string if the string was entirely converted. u2 is the
  2205                        ; number of unconverted characters in the string. An ambiguous condition exists
  2206                        ; if ud2 overflows during the conversion.
  2207                        ;
  2208                        ; In this implementation its is defined as:
  2209                        ;
  2210                        ;   BEGIN
  2211                        ;   DUP WHILE
  2212                        ;       OVER C@ DIGIT?
  2213                        ;       0= IF DROP EXIT THEN
  Tue May  3 2016 22:26                                                                                                    Page 45


  2214                        ;       >R 2SWAP BASE @ UD*
  2215                        ;       R> M+ 2SWAP
  2216                        ;       1 /STRING
  2217                        ;   REPEAT ;
  2218                        
  2219 00:0FB4: 72 0F 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0FB8: 3E 4E 55 4D 
       00:0FBC: 42 45 52 
  2220 00:0FBF: 20 C1 14     TO_NUMBER:      jsr     DO_COLON
  2221 00:0FC2: 85 07        TO_NUM_1:       dw      DUP
  2222 00:0FC4: 80 16 F2 0F                  dw      QUERY_BRANCH,TO_NUM_3
  2223 00:0FC8: A8 07                        dw      OVER
  2224 00:0FCA: 0C 06                        dw      C_FETCH
  2225 00:0FCC: 71 10                        dw      DIGIT_QUERY
  2226 00:0FCE: 06 0D                        dw      ZERO_EQUAL
  2227 00:0FD0: 80 16 D8 0F                  dw      QUERY_BRANCH,TO_NUM_2
  2228 00:0FD4: 74 07                        dw      DROP
  2229 00:0FD6: E6 0E                        dw      EXIT
  2230 00:0FD8: 7E 08        TO_NUM_2:       dw      TO_R
  2231 00:0FDA: 26 07                        dw      TWO_SWAP
  2232 00:0FDC: 64 04                        dw      BASE
  2233 00:0FDE: B9 05                        dw      FETCH
  2234 00:0FE0: 5E 0C                        dw      UD_STAR
  2235 00:0FE2: B7 08                        dw      R_FROM
  2236 00:0FE4: FA 0B                        dw      M_PLUS
  2237 00:0FE6: 26 07                        dw      TWO_SWAP
  2238 00:0FE8: C7 16 01 00                  dw      DO_LITERAL,1
  2239 00:0FEC: 30 13                        dw      SLASH_STRING
  2240 00:0FEE: 5F 16 C2 0F                  dw      BRANCH,TO_NUM_1
  2241 00:0FF2: E6 0E        TO_NUM_3:       dw      EXIT
  2242                        
  2243                        ; ACCEPT ( c-addr +n1 -- +n2 )
  2244                        ;
  2245                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  2246                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  2247                        ; received. A program that depends on the presence or absence of non-graphic
  2248                        ; characters in the string has an environmental dependency. The editing
  2249                        ; functions, if any, that the system performs in order to construct the string
  2250                        ; are implementation-defined.
  2251                        ;
  2252                        ; Input terminates when an implementation-defined line terminator is received.
  2253                        ; When input terminates, nothing is appended to the string, and the display is
  2254                        ; maintained in an implementation-defined way.
  2255                        ;
  2256                        ; +n2 is the length of the string stored at c-addr.
  2257                        ;
  2258                        ; In this implementation it is defined as:
  2259                        ;
  2260                        ;   OVER + 1- OVER      -- sa ea a
  2261                        ;   BEGIN KEY           -- sa ea a c
  2262                        ;   DUP 0D <> WHILE
  2263                        ;     DUP 8 = OVER 127 = OR IF
  2264                        ;       DROP 1-
  2265                        ;       >R OVER R> UMAX
  2266                        ;       8 EMIT SPACE 8 EMIT
  2267                        ;     ELSE
  2268                        ;       DUP EMIT        -- sa ea a c
  2269                        ;       OVER C! 1+ OVER UMIN
  Tue May  3 2016 22:26                                                                                                    Page 46


  2270                        ;     THEN              -- sa ea a
  2271                        ;   REPEAT              -- sa ea a c
  2272                        ;   DROP NIP SWAP - ;
  2273                        
  2274 00:0FF4: B7 0F 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0FF8: 41 43 43 45 
       00:0FFC: 50 54 
  2275 00:0FFE: 20 C1 14     ACCEPT:         jsr     DO_COLON
  2276 00:1001: A8 07                        dw      OVER
  2277 00:1003: 18 09                        dw      PLUS
  2278 00:1005: 7E 09                        dw      ONE_MINUS
  2279 00:1007: A8 07                        dw      OVER
  2280 00:1009: B1 18        ACCEPT_1:       dw      KEY
  2281 00:100B: 85 07                        dw      DUP
  2282 00:100D: C7 16 0D 00                  dw      DO_LITERAL,$0D
  2283 00:1011: 3E 0D                        dw      NOT_EQUAL
  2284 00:1013: 80 16 5D 10                  dw      QUERY_BRANCH,ACCEPT_4
  2285 00:1017: 85 07                        dw      DUP
  2286 00:1019: C7 16 08 00                  dw      DO_LITERAL,$08
  2287 00:101D: 57 0D                        dw      EQUAL
  2288 00:101F: A8 07                        dw      OVER
  2289 00:1021: C7 16 7F 00                  dw      DO_LITERAL,$7f
  2290 00:1025: 57 0D                        dw      EQUAL
  2291 00:1027: 16 0E                        dw      OR
  2292 00:1029: 80 16 4B 10                  dw      QUERY_BRANCH,ACCEPT_2
  2293 00:102D: 74 07                        dw      DROP
  2294 00:102F: 7E 09                        dw      ONE_MINUS
  2295 00:1031: 7E 08                        dw      TO_R
  2296 00:1033: A8 07                        dw      OVER
  2297 00:1035: B7 08                        dw      R_FROM
  2298 00:1037: 75 0A                        dw      UMAX
  2299 00:1039: C7 16 08 00                  dw      DO_LITERAL,8
  2300 00:103D: 9B 18                        dw      EMIT
  2301 00:103F: CD 18                        dw      SPACE
  2302 00:1041: C7 16 08 00                  dw      DO_LITERAL,8
  2303 00:1045: 9B 18                        dw      EMIT
  2304 00:1047: 5F 16 59 10                  dw      BRANCH,ACCEPT_3
  2305 00:104B: 85 07        ACCEPT_2:       dw      DUP
  2306 00:104D: 9B 18                        dw      EMIT
  2307 00:104F: A8 07                        dw      OVER
  2308 00:1051: DB 05                        dw      C_STORE
  2309 00:1053: 70 09                        dw      ONE_PLUS
  2310 00:1055: A8 07                        dw      OVER
  2311 00:1057: 89 0A                        dw      UMIN
  2312 00:1059: 5F 16 09 10  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  2313 00:105D: 74 07        ACCEPT_4:       dw      DROP
  2314 00:105F: 9A 07                        dw      NIP
  2315 00:1061: 0C 08                        dw      SWAP
  2316 00:1063: 2E 09                        dw      MINUS
  2317 00:1065: E6 0E                        dw      EXIT
  2318                        
  2319                        ; DIGIT?
  2320                        ;
  2321                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  2322                        ;   DUP 140 > 107 AND -   30 -     but it works!
  2323                        ;   DUP BASE @ U< ;
  2324                        
  2325 00:1067: F7 0F 00 06                  HEADER  6,"DIGIT?",NORMAL
  Tue May  3 2016 22:26                                                                                                    Page 47


       00:106B: 44 49 47 49 
       00:106F: 54 3F 
  2326 00:1071: 20 C1 14     DIGIT_QUERY:    jsr     DO_COLON
  2327 00:1074: 85 07                        dw      DUP
  2328 00:1076: C7 16 39 00                  dw      DO_LITERAL,'9'
  2329 00:107A: 70 0D                        dw      GREATER
  2330 00:107C: C7 16 00 01                  dw      DO_LITERAL,$100
  2331 00:1080: BD 0D                        dw      AND
  2332 00:1082: 18 09                        dw      PLUS
  2333 00:1084: 85 07                        dw      DUP
  2334 00:1086: C7 16 40 01                  dw      DO_LITERAL,$140
  2335 00:108A: 70 0D                        dw      GREATER
  2336 00:108C: C7 16 07 01                  dw      DO_LITERAL,$107
  2337 00:1090: BD 0D                        dw      AND
  2338 00:1092: 2E 09                        dw      MINUS
  2339 00:1094: C7 16 30 00                  dw      DO_LITERAL,'0'
  2340 00:1098: 2E 09                        dw      MINUS
  2341 00:109A: 85 07                        dw      DUP
  2342 00:109C: 64 04                        dw      BASE
  2343 00:109E: B9 05                        dw      FETCH
  2344 00:10A0: 91 0D                        dw      U_LESS
  2345 00:10A2: E6 0E                        dw      EXIT
  2346                        
  2347                        ; EVALUATE ( i*x c-addr u -- j*x )
  2348                        ;
  2349                        ; Save the current input source specification. Store minus-one (-1) in
  2350                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  2351                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  2352                        ; parse area is empty, restore the prior input source specification. Other
  2353                        ; stack effects are due to the words EVALUATEd.
  2354                        ;
  2355                        ;   >R >R SAVE-INPUT
  2356                        ;   -1 (SOURCE-ID) !
  2357                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  2358                        ;   INTERPRET
  2359                        ;   RESTORE-INPUT DROP
  2360                        
  2361 00:10A4: 6A 10 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:10A8: 45 56 41 4C 
       00:10AC: 55 41 54 45 
  2362 00:10B0: 20 C1 14     EVALUATE:       jsr     DO_COLON
  2363 00:10B3: 7E 08                        dw      TO_R
  2364 00:10B5: 7E 08                        dw      TO_R
  2365 00:10B7: 3C 12                        dw      SAVE_INPUT
  2366 00:10B9: B7 08                        dw      R_FROM
  2367 00:10BB: B7 08                        dw      R_FROM
  2368 00:10BD: 0C 05                        dw      TRUE
  2369 00:10BF: AA 04                        dw      SOURCEID
  2370 00:10C1: 4B 05                        dw      STORE
  2371 00:10C3: CE 04                        dw      ZERO
  2372 00:10C5: 57 04                        dw      TO_IN
  2373 00:10C7: 4B 05                        dw      STORE
  2374 00:10C9: 99 04                        dw      LENGTH
  2375 00:10CB: 4B 05                        dw      STORE
  2376 00:10CD: 75 04                        dw      BUFFER
  2377 00:10CF: 4B 05                        dw      STORE
  2378 00:10D1: E6 10                        dw      INTERPRET
  2379 00:10D3: ED 11                        dw      RESTORE_INPUT
  Tue May  3 2016 22:26                                                                                                    Page 48


  2380 00:10D5: 74 07                        dw      DROP
  2381 00:10D7: E6 0E                        dw      EXIT
  2382                        
  2383                        ; INTERPRET ( -- )
  2384                        ;
  2385                        ;
  2386                        ;   BEGIN
  2387                        ;   BL WORD DUP C@ WHILE        -- textadr
  2388                        ;       FIND                    -- a 0/1/-1
  2389                        ;       ?DUP IF                 -- xt 1/-1
  2390                        ;           1+ STATE @ 0= OR    immed or interp?
  2391                        ;           IF EXECUTE ELSE , THEN
  2392                        ;       ELSE                    -- textadr
  2393                        ;           ?NUMBER
  2394                        ;           IF STATE @
  2395                        ;               IF POSTPONE LITERAL THEN     converted ok
  2396                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  2397                        ;           THEN
  2398                        ;       THEN
  2399                        ;   REPEAT DROP ;
  2400                        
  2401 00:10D9: A7 10 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:10DD: 49 4E 54 45 
       00:10E1: 52 50 52 45 
       00:10E5: 54 
  2402 00:10E6: 20 C1 14     INTERPRET:      jsr     DO_COLON
  2403 00:10E9: E0 04        INTERPRET_1:    dw      BL
  2404 00:10EB: B4 12                        dw      WORD
  2405 00:10ED: 85 07                        dw      DUP
  2406 00:10EF: 0C 06                        dw      C_FETCH
  2407 00:10F1: 80 16 3D 11                  dw      QUERY_BRANCH,INTERPRET_7
  2408 00:10F5: 49 11                        dw      FIND
  2409 00:10F7: 48 07                        dw      QUERY_DUP
  2410 00:10F9: 80 16 17 11                  dw      QUERY_BRANCH,INTERPRET_4
  2411 00:10FD: 70 09                        dw      ONE_PLUS
  2412 00:10FF: B8 04                        dw      STATE
  2413 00:1101: B9 05                        dw      FETCH
  2414 00:1103: 06 0D                        dw      ZERO_EQUAL
  2415 00:1105: 16 0E                        dw      OR
  2416 00:1107: 80 16 11 11                  dw      QUERY_BRANCH,INTERPRET_2
  2417 00:110B: D5 0E                        dw      EXECUTE
  2418 00:110D: 5F 16 13 11                  dw      BRANCH,INTERPRET_3
  2419 00:1111: 79 05        INTERPRET_2:    dw      COMMA
  2420 00:1113: 5F 16 39 11  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  2421 00:1117: 3A 0F        INTERPRET_4:    dw      QUERY_NUMBER
  2422 00:1119: 80 16 2B 11                  dw      QUERY_BRANCH,INTERPRET_5
  2423 00:111D: B8 04                        dw      STATE
  2424 00:111F: B9 05                        dw      FETCH
  2425 00:1121: 80 16 39 11                  dw      QUERY_BRANCH,INTERPRET_6
  2426 00:1125: BA 16                        dw      LITERAL
  2427 00:1127: 5F 16 39 11                  dw      BRANCH,INTERPRET_6
  2428 00:112B: 0D 14        INTERPRET_5:    dw      COUNT
  2429 00:112D: FF 18                        dw      TYPE
  2430 00:112F: C7 16 3F 00                  dw      DO_LITERAL,$3f
  2431 00:1133: 9B 18                        dw      EMIT
  2432 00:1135: 82 18                        dw      CR
  2433 00:1137: 83 0E                        dw      ABORT
  2434 00:1139: 5F 16 E9 10  INTERPRET_6     dw      BRANCH,INTERPRET_1
  Tue May  3 2016 22:26                                                                                                    Page 49


  2435 00:113D: 74 07        INTERPRET_7:    dw      DROP
  2436 00:113F: E6 0E                        dw      EXIT
  2437                        
  2438                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  2439                        ;
  2440                        ; Find the definition named in the counted string at c-addr. If the definition
  2441                        ; is not found, return c-addr and zero. If the definition is found, return its
  2442                        ; execution token xt. If the definition is immediate, also return one (1),
  2443                        ; otherwise also return minus-one (-1). For a given string, the values returned
  2444                        ; by FIND while compiling may differ from those returned while not compiling.
  2445                        ;
  2446                        ; In this implementation it is defined as:
  2447                        ;
  2448                        ;   LATEST @ BEGIN             -- a nfa
  2449                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  2450                        ;       S=                     -- a nfa f
  2451                        ;       DUP IF
  2452                        ;           DROP
  2453                        ;           NFA>LFA @ DUP      -- a link link
  2454                        ;       THEN
  2455                        ;   0= UNTIL                   -- a nfa  OR  a 0
  2456                        ;   DUP IF
  2457                        ;       NIP DUP NFA>CFA        -- nfa xt
  2458                        ;       SWAP IMMED?            -- xt iflag
  2459                        ;       0= 1 OR                -- xt 1/-1
  2460                        ;   THEN ;
  2461                        
  2462 00:1141: DC 10 00 04                  HEADER  4,"FIND",NORMAL
       00:1145: 46 49 4E 44 
  2463 00:1149: 20 C1 14     FIND:           jsr     DO_COLON
  2464 00:114C: 94 04                        dw      LATEST
  2465 00:114E: B9 05                        dw      FETCH
  2466 00:1150: BF 06        FIND1:          dw      TWO_DUP
  2467 00:1152: A8 07                        dw      OVER
  2468 00:1154: 0C 06                        dw      C_FETCH
  2469 00:1156: 7A 06                        dw      CHAR_PLUS
  2470 00:1158: 04 12                        dw      S_EQUAL
  2471 00:115A: 85 07                        dw      DUP
  2472 00:115C: 80 16 68 11                  dw      QUERY_BRANCH,FIND2
  2473 00:1160: 74 07                        dw      DROP
  2474 00:1162: 9A 11                        dw      NFA_TO_LFA
  2475 00:1164: B9 05                        dw      FETCH
  2476 00:1166: 85 07                        dw      DUP
  2477 00:1168: 06 0D        FIND2:          dw      ZERO_EQUAL
  2478 00:116A: 80 16 50 11                  dw      QUERY_BRANCH,FIND1
  2479 00:116E: 85 07                        dw      DUP
  2480 00:1170: 80 16 86 11                  dw      QUERY_BRANCH,FIND3
  2481 00:1174: 9A 07                        dw      NIP
  2482 00:1176: 85 07                        dw      DUP
  2483 00:1178: 91 11                        dw      NFA_TO_CFA
  2484 00:117A: 0C 08                        dw      SWAP
  2485 00:117C: 88 11                        dw      IMMED_QUERY
  2486 00:117E: 06 0D                        dw      ZERO_EQUAL
  2487 00:1180: C7 16 01 00                  dw      DO_LITERAL,1
  2488 00:1184: 16 0E                        dw      OR
  2489 00:1186: E6 0E        FIND3:          dw      EXIT
  2490                        
  2491                        ; IMMED? ( nfa -- f )
  Tue May  3 2016 22:26                                                                                                    Page 50


  2492                        
  2493 00:1188: 20 C1 14     IMMED_QUERY:    jsr     DO_COLON
  2494 00:118B: 7E 09                        dw      ONE_MINUS
  2495 00:118D: 0C 06                        dw      C_FETCH
  2496 00:118F: E6 0E                        dw      EXIT
  2497                        
  2498                        ; NFA>CFA ( nfa -- cfa )
  2499                        
  2500 00:1191: 20 C1 14     NFA_TO_CFA:     jsr     DO_COLON
  2501 00:1194: 0D 14                        dw      COUNT
  2502 00:1196: 18 09                        dw      PLUS
  2503 00:1198: E6 0E                        dw      EXIT
  2504                        
  2505                        ; NFA>LFA ( nfa -- lfa )
  2506                        
  2507 00:119A: 20 C1 14     NFA_TO_LFA:     jsr     DO_COLON
  2508 00:119D: C7 16 03 00                  dw      DO_LITERAL,3
  2509 00:11A1: 2E 09                        dw      MINUS
  2510 00:11A3: E6 0E                        dw      EXIT
  2511                        
  2512                        ; REFILL ( -- flag )
  2513                        ;
  2514                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2515                        ; if successful.
  2516                        ;
  2517                        ; When the input source is the user input device, attempt to receive input into
  2518                        ; the terminal input buffer. If successful, make the result the input buffer,
  2519                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2520                        ; is considered successful. If there is no input available from the current
  2521                        ; input source, return false.
  2522                        ;
  2523                        ; When the input source is a string from EVALUATE, return false and perform no
  2524                        ; other action.
  2525                        ;
  2526                        ; In this implementation it is defined as:
  2527                        ;
  2528                        ;   SOURCE-ID 0= IF
  2529                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2530                        ;     LENGTH ! BUFFER !
  2531                        ;     0 >IN ! TRUE EXIT
  2532                        ;   THEN
  2533                        ;   FALSE
  2534                        
  2535 00:11A5: 44 11 00 06                  HEADER  6,"REFILL",NORMAL
       00:11A9: 52 45 46 49 
       00:11AD: 4C 4C 
  2536 00:11AF: 20 C1 14     REFILL:         jsr     DO_COLON
  2537 00:11B2: A3 12                        dw      SOURCE_ID
  2538 00:11B4: 06 0D                        dw      ZERO_EQUAL
  2539 00:11B6: 80 16 D8 11                  dw      QUERY_BRANCH,REFILL_1
  2540 00:11BA: C4 04                        dw      TIB
  2541 00:11BC: 85 07                        dw      DUP
  2542 00:11BE: 49 04                        dw      HASH_TIB
  2543 00:11C0: B9 05                        dw      FETCH
  2544 00:11C2: FE 0F                        dw      ACCEPT
  2545 00:11C4: CD 18                        dw      SPACE
  2546 00:11C6: 99 04                        dw      LENGTH
  2547 00:11C8: 4B 05                        dw      STORE
  Tue May  3 2016 22:26                                                                                                    Page 51


  2548 00:11CA: 75 04                        dw      BUFFER
  2549 00:11CC: 4B 05                        dw      STORE
  2550 00:11CE: CE 04                        dw      ZERO
  2551 00:11D0: 57 04                        dw      TO_IN
  2552 00:11D2: 4B 05                        dw      STORE
  2553 00:11D4: 0C 05                        dw      TRUE
  2554 00:11D6: E6 0E                        dw      EXIT
  2555 00:11D8: F8 04        REFILL_1:       dw      FALSE
  2556 00:11DA: E6 0E                        dw      EXIT
  2557                        
  2558                        ; RESTORE-INPUT ( xn ... x1 n -- flag )
  2559                        ;
  2560                        ; Attempt to restore the input source specification to the state described by
  2561                        ; x1 through xn. flag is true if the input source specification cannot be so
  2562                        ; restored.
  2563                        ;
  2564                        ; An ambiguous condition exists if the input source represented by the
  2565                        ; arguments is not the same as the current input source.
  2566                        ;
  2567                        ; In this implementation it is defined as:
  2568                        ;
  2569                        ;   >IN ! (LENGTH) ! BUFFER !
  2570                        ;   SOURCEID !
  2571                        ;   TRUE
  2572                        
  2573 00:11DC: A8 11 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:11E0: 52 45 53 54 
       00:11E4: 4F 52 45 2D 
       00:11E8: 49 4E 50 55 
       00:11EC: 54 
  2574 00:11ED: 20 C1 14     RESTORE_INPUT   jsr     DO_COLON
  2575 00:11F0: 57 04                        dw      TO_IN
  2576 00:11F2: 4B 05                        dw      STORE
  2577 00:11F4: 99 04                        dw      LENGTH
  2578 00:11F6: 4B 05                        dw      STORE
  2579 00:11F8: 75 04                        dw      BUFFER
  2580 00:11FA: 4B 05                        dw      STORE
  2581 00:11FC: AA 04                        dw      SOURCEID
  2582 00:11FE: 4B 05                        dw      STORE
  2583 00:1200: 0C 05                        dw      TRUE
  2584 00:1202: E6 0E                        dw      EXIT
  2585                        
  2586                        ; S= ( c-addr1 caddr2 u -- n)
  2587                        ;
  2588                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2589                        
  2590                        S_EQUAL:
  2591 00:1204: 5A                           phy
  2592 00:1205: A6 01                        ldx     <1                      ; Fetch maximum length
  2593 00:1207: F0 14                        beq     S_EQUAL_3
  2594 00:1209: A0 00 00                     ldy     #0
  2595 00:120C: E2 20                        short_a
  2596                        S_EQUAL_1:
  2597 00:120E: B1 05                        lda     (5),y                   ; Compare bytes
  2598 00:1210: D1 03                        cmp     (3),y
  2599 00:1212: D0 06                        bne     S_EQUAL_2
  2600 00:1214: C8                           iny
  2601 00:1215: CA                           dex                             ; End of strings?
  Tue May  3 2016 22:26                                                                                                    Page 52


  2602 00:1216: D0 F6                        bne     S_EQUAL_1               ; No
  2603 00:1218: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2604                        S_EQUAL_2:
  2605 00:121A: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2606                        S_EQUAL_3:
  2607 00:121D: C2 20                        long_a
  2608 00:121F: 7B                           tdc                             ; Clean up the stack
  2609 00:1220: 1A                           inc     a
  2610 00:1221: 1A                           inc     a
  2611 00:1222: 1A                           inc     a
  2612 00:1223: 1A                           inc     a
  2613 00:1224: 5B                           tcd
  2614 00:1225: 86 01                        stx     <1                      ; Save the flag
  2615 00:1227: 7A                           ply
  2616 00:1228: BB C8 C8 7C                  CONTINUE
       00:122C: 00 00 
  2617                        
  2618                        ; SAVE-INPUT ( -- xn ... x1 n )
  2619                        ;
  2620                        ; x1 through xn describe the current state of the input source specification
  2621                        ; for later use by RESTORE-INPUT.
  2622                        
  2623 00:122E: DF 11 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:1232: 53 41 56 45 
       00:1236: 2D 49 4E 50 
       00:123A: 55 54 
  2624 00:123C: 20 C1 14     SAVE_INPUT:     jsr     DO_COLON
  2625 00:123F: AA 04                        dw      SOURCEID
  2626 00:1241: B9 05                        dw      FETCH
  2627 00:1243: 75 04                        dw      BUFFER
  2628 00:1245: B9 05                        dw      FETCH
  2629 00:1247: 99 04                        dw      LENGTH
  2630 00:1249: B9 05                        dw      FETCH
  2631 00:124B: 57 04                        dw      TO_IN
  2632 00:124D: B9 05                        dw      FETCH
  2633 00:124F: E6 0E                        dw      EXIT
  2634                        
  2635                        ; SCAN ( c-addr n c == c-addr' n' )
  2636                        
  2637                        SCAN:
  2638                        SCAN_1:
  2639 00:1251: A5 03                        lda     <3                      ; Any data left to scan?
  2640 00:1253: F0 10                        beq     SCAN_2                  ; No.
  2641 00:1255: A5 01                        lda     <1                      ; Fetch and compare with scan
  2642 00:1257: E2 20                        short_a
  2643 00:1259: D2 05                        cmp     (5)
  2644 00:125B: C2 20                        long_a
  2645 00:125D: F0 06                        beq     SCAN_2
  2646 00:125F: E6 05                        inc     <5
  2647 00:1261: C6 03                        dec     <3
  2648 00:1263: 80 EC                        bra     SCAN_1
  2649                        SCAN_2:
  2650 00:1265: 4C 74 07                     jmp     DROP                    ; Drop the character
  2651                        
  2652                        ; SKIP ( c-addr n c == c-addr' n' )
  2653                        
  2654                        SKIP:
  2655 00:1268: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  Tue May  3 2016 22:26                                                                                                    Page 53


  2656 00:126A: F0 10                        beq     SKIP_2                  ; No.
  2657 00:126C: A5 01                        lda     <1                      ; Fetch and compare with skip
  2658 00:126E: E2 20                        short_a
  2659 00:1270: D2 05                        cmp     (5)
  2660 00:1272: C2 20                        long_a
  2661 00:1274: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2662 00:1276: E6 05                        inc     <5                      ; Bump data address
  2663 00:1278: C6 03                        dec     <3                      ; and update length
  2664 00:127A: 80 EC                        bra     SKIP_1                  ; And repeat
  2665                        SKIP_2:
  2666 00:127C: 4C 74 07                     jmp     DROP                    ; Drop the character
  2667                        
  2668                        ; SOURCE ( -- c-addr u )
  2669                        ;
  2670                        ; c-addr is the address of, and u is the number of characters in, the input
  2671                        ; buffer.
  2672                        ;
  2673                        ; In this implementation it is defined as
  2674                        ;
  2675                        ;   BUFFER @ LENGTH @
  2676                        
  2677 00:127F: 31 12 00 06                  HEADER  6,"SOURCE",NORMAL
       00:1283: 53 4F 55 52 
       00:1287: 43 45 
  2678 00:1289: 20 C1 14     SOURCE:         jsr     DO_COLON
  2679 00:128C: 75 04                        dw      BUFFER
  2680 00:128E: B9 05                        dw      FETCH
  2681 00:1290: 99 04                        dw      LENGTH
  2682 00:1292: B9 05                        dw      FETCH
  2683 00:1294: E6 0E                        dw      EXIT
  2684                        
  2685                        ; SOURCE-ID ( -- 0 | -1 )
  2686                        ;
  2687                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2688                        ; device.
  2689                        
  2690 00:1296: 82 12 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:129A: 53 4F 55 52 
       00:129E: 43 45 2D 49 
       00:12A2: 44 
  2691 00:12A3: 20 C1 14     SOURCE_ID:      jsr     DO_COLON
  2692 00:12A6: AA 04                        dw      SOURCEID
  2693 00:12A8: B9 05                        dw      FETCH
  2694 00:12AA: E6 0E                        dw      EXIT
  2695                        
  2696                        ; WORD ( char “<chars>ccc<char>” -- c-addr )
  2697                        ;
  2698                        ; Skip leading delimiters. Parse characters ccc delimited by char. An
  2699                        ; ambiguous condition exists if the length of the parsed string is greater
  2700                        ; than the implementation-defined length of a counted string.
  2701                        ;
  2702                        ; c-addr is the address of a transient region containing the parsed word as
  2703                        ; a counted string. If the parse area was empty or contained no characters
  2704                        ; other than the delimiter, the resulting string has a zero length. A space,
  2705                        ; not included in the length, follows the string. A program may replace
  2706                        ; characters within the string.
  2707                        ;
  2708                        ; In this implementation it is defined as:
  Tue May  3 2016 22:26                                                                                                    Page 54


  2709                        ;
  2710                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2711                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2712                        ;   OVER >R  ROT SCAN           -- adr" n"
  2713                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2714                        ;   R> R> ROT -   >IN +!        update >IN offset
  2715                        ;   TUCK -                      -- adr' N
  2716                        ;   HERE >counted               --
  2717                        ;   HERE                        -- a
  2718                        ;   BL OVER COUNT + C! ;    append trailing blank
  2719                        
  2720 00:12AC: 99 12 00 04                  HEADER  4,"WORD",NORMAL
       00:12B0: 57 4F 52 44 
  2721 00:12B4: 20 C1 14     WORD:           jsr     DO_COLON
  2722 00:12B7: 85 07                        dw      DUP
  2723 00:12B9: 89 12                        dw      SOURCE
  2724 00:12BB: 57 04                        dw      TO_IN
  2725 00:12BD: B9 05                        dw      FETCH
  2726 00:12BF: 30 13                        dw      SLASH_STRING
  2727 00:12C1: 85 07                        dw      DUP
  2728 00:12C3: 7E 08                        dw      TO_R
  2729 00:12C5: F2 07                        dw      ROT
  2730 00:12C7: 68 12                        dw      SKIP
  2731 00:12C9: A8 07                        dw      OVER
  2732 00:12CB: 7E 08                        dw      TO_R
  2733 00:12CD: F2 07                        dw      ROT
  2734 00:12CF: 51 12                        dw      SCAN
  2735 00:12D1: 85 07                        dw      DUP
  2736 00:12D3: 80 16 D9 12                  dw      QUERY_BRANCH,WORD_1
  2737 00:12D7: 8B 06                        dw      CHAR_MINUS
  2738 00:12D9: B7 08        WORD_1:         dw      R_FROM
  2739 00:12DB: B7 08                        dw      R_FROM
  2740 00:12DD: F2 07                        dw      ROT
  2741 00:12DF: 2E 09                        dw      MINUS
  2742 00:12E1: 57 04                        dw      TO_IN
  2743 00:12E3: 61 05                        dw      PLUS_STORE
  2744 00:12E5: 22 08                        dw      TUCK
  2745 00:12E7: 2E 09                        dw      MINUS
  2746 00:12E9: 24 06                        dw      HERE
  2747 00:12EB: A5 0F                        dw      TO_COUNTED
  2748 00:12ED: 24 06                        dw      HERE
  2749 00:12EF: E0 04                        dw      BL
  2750 00:12F1: A8 07                        dw      OVER
  2751 00:12F3: 0D 14                        dw      COUNT
  2752 00:12F5: 18 09                        dw      PLUS
  2753 00:12F7: DB 05                        dw      C_STORE
  2754 00:12F9: E6 0E                        dw      EXIT
  2755                        
  2756                        ;===============================================================================
  2757                        ; String Words
  2758                        ;-------------------------------------------------------------------------------
  2759                        
  2760                        ; -TRAILING ( c-addr u1 -- c-addr u2 )
  2761                        ;
  2762                        ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
  2763                        ; the end of the character string specified by c-addr u1. If u1 is zero or the
  2764                        ; entire string consists of spaces, u2 is zero.
  2765                        
  Tue May  3 2016 22:26                                                                                                    Page 55


  2766 00:12FB: AF 12 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:12FF: 2D 54 52 41 
       00:1303: 49 4C 49 4E 
       00:1307: 47 
  2767                        DASH_TRAILING:
  2768 00:1308: 5A                           phy                             ; Save IP
  2769 00:1309: A4 01                        ldy     <1                      ; Is u1 > 0?
  2770 00:130B: F0 0F                        beq     DASH_TRAIL_3            ; No
  2771 00:130D: E2 20                        short_a
  2772 00:130F: 88                           dey                             ; Convert to offset
  2773 00:1310: B1 03        DASH_TRAIL_1:   lda     (3),y                   ; Space character at end?
  2774 00:1312: C9 20                        cmp     #' '
  2775 00:1314: D0 03                        bne     DASH_TRAIL_2            ; No
  2776 00:1316: 88                           dey                             ; More characters to check?
  2777 00:1317: 10 F7                        bpl     DASH_TRAIL_1            ; Yes
  2778 00:1319: C2 20        DASH_TRAIL_2:   long_a
  2779 00:131B: C8                           iny                             ; Convert to length
  2780 00:131C: 84 01        DASH_TRAIL_3:   sty     <1                      ; Update
  2781 00:131E: 7A                           ply                             ; Restore IP
  2782 00:131F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1323: 00 00 
  2783                        
  2784                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2785                        ;
  2786                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2787                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2788                        ; characters and is u1 minus n characters long.
  2789                        ;
  2790                        ; In this implementation it is defined as:
  2791                        ;
  2792                        ;   ROT OVER + ROT ROT -
  2793                        
  2794 00:1325: FE 12 00 07                  HEADER  7,"/STRING",NORMAL
       00:1329: 2F 53 54 52 
       00:132D: 49 4E 47 
  2795 00:1330: 20 C1 14     SLASH_STRING:   jsr     DO_COLON
  2796 00:1333: F2 07                        dw      ROT
  2797 00:1335: A8 07                        dw      OVER
  2798 00:1337: 18 09                        dw      PLUS
  2799 00:1339: F2 07                        dw      ROT
  2800 00:133B: F2 07                        dw      ROT
  2801 00:133D: 2E 09                        dw      MINUS
  2802 00:133F: E6 0E                        dw      EXIT
  2803                        
  2804                        ; BLANK ( c-addr u -- )
  2805                        ;
  2806                        ; If u is greater than zero, store the character value for space in u
  2807                        ; consecutive character positions beginning at c-addr.
  2808                        ;
  2809                        ; In this implementation it is defined as
  2810                        ;
  2811                        ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
  2812                        
  2813 00:1341: 28 13 00 05                  HEADER  5,"BLANK",NORMAL
       00:1345: 42 4C 41 4E 
       00:1349: 4B 
  2814 00:134A: 20 C1 14     BLANK:          jsr     DO_COLON
  2815 00:134D: 48 07                        dw      QUERY_DUP
  Tue May  3 2016 22:26                                                                                                    Page 56


  2816 00:134F: 80 16 67 13                  dw      QUERY_BRANCH,BLANK_2
  2817 00:1353: A8 07                        dw      OVER
  2818 00:1355: 18 09                        dw      PLUS
  2819 00:1357: 0C 08                        dw      SWAP
  2820 00:1359: 2E 16                        dw      DO_DO
  2821 00:135B: E0 04        BLANK_1:        dw      BL
  2822 00:135D: 90 08                        dw      I
  2823 00:135F: DB 05                        dw      C_STORE
  2824 00:1361: F9 16 5B 13                  dw      DO_LOOP,BLANK_1
  2825 00:1365: E6 0E                        dw      EXIT
  2826 00:1367: 74 07        BLANK_2:        dw      DROP
  2827 00:1369: E6 0E                        dw      EXIT
  2828                        
  2829                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2830                        ;
  2831                        ; If u is greater than zero, copy u consecutive characters from the data space
  2832                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2833                        ; character from lower addresses to higher addresses.
  2834                        
  2835 00:136B: 44 13 00 05                  HEADER  5,"CMOVE",NORMAL
       00:136F: 43 4D 4F 56 
       00:1373: 45 
  2836                        CMOVE:
  2837 00:1374: 5A                           phy
  2838 00:1375: A6 01                        ldx     <1                      ; Any characters to move?
  2839 00:1377: F0 0F                        beq     CMOVE_2                 ; No
  2840 00:1379: A0 00 00                     ldy     #0
  2841 00:137C: E2 20                        short_a
  2842                        CMOVE_1:                                        ; Transfer a byte
  2843 00:137E: B1 05                        lda     (5),y
  2844 00:1380: 91 03                        sta     (3),y
  2845 00:1382: C8                           iny
  2846 00:1383: CA                           dex                             ; Decrement count
  2847 00:1384: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2848 00:1386: C2 20                        long_a
  2849                        CMOVE_2:
  2850 00:1388: 7B                           tdc                             ; Clean up the stack
  2851 00:1389: 18                           clc
  2852 00:138A: 69 06 00                     adc     #6
  2853 00:138D: 5B                           tcd
  2854 00:138E: 7A                           ply
  2855 00:138F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1393: 00 00 
  2856                        
  2857                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2858                        ;
  2859                        ; If u is greater than zero, copy u consecutive characters from the data space
  2860                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2861                        ; character from higher addresses to lower addresses.
  2862                        
  2863 00:1395: 6E 13 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:1399: 43 4D 4F 56 
       00:139D: 45 3E 
  2864                        CMOVE_GREATER:
  2865 00:139F: 5A                           phy
  2866 00:13A0: A6 01                        ldx     <1                      ; Any characters to move?
  2867 00:13A2: F0 0E                        beq     CMOVE_GT_2              ; No.
  2868 00:13A4: A4 01                        ldy     <1
  Tue May  3 2016 22:26                                                                                                    Page 57


  2869 00:13A6: E2 20                        short_a
  2870                        CMOVE_GT_1:
  2871 00:13A8: 88                           dey                             ; Transfer a byte
  2872 00:13A9: B1 05                        lda     (5),y
  2873 00:13AB: 91 03                        sta     (3),y
  2874 00:13AD: CA                           dex                             ; Decrement length
  2875 00:13AE: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2876 00:13B0: C2 20                        long_a
  2877                        CMOVE_GT_2:
  2878 00:13B2: 7B                           tdc                             ; Clean up the stack
  2879 00:13B3: 18                           clc
  2880 00:13B4: 69 06 00                     adc     #6
  2881 00:13B7: 5B                           tcd
  2882 00:13B8: 7A                           ply
  2883 00:13B9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13BD: 00 00 
  2884                        
  2885                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2886                        ;
  2887                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2888                        ; u2. The strings are compared, beginning at the given addresses, character by
  2889                        ; character, up to the length of the shorter string or until a difference is
  2890                        ; found. If the two strings are identical, n is zero. If the two strings are
  2891                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2892                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2893                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2894                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2895                        ; numeric value than the corresponding character in the string specified by
  2896                        ; c-addr2 u2 and one (1) otherwise.
  2897                        
  2898 00:13BF: 98 13 00 07                  HEADER  7,"COMPARE",NORMAL
       00:13C3: 43 4F 4D 50 
       00:13C7: 41 52 45 
  2899                        COMPARE:
  2900 00:13CA: A5 01                        lda     <1                      ; Both string lengths zero?
  2901 00:13CC: 05 05                        ora     <5
  2902 00:13CE: F0 26                        beq     COMPARE_X               ; Yes, must be equal
  2903                        
  2904 00:13D0: A5 01                        lda     <1                      ; Second string length zero?
  2905 00:13D2: F0 1A                        beq     COMPARE_P               ; Yes, must be shorter
  2906 00:13D4: A5 05                        lda     <5                      ; First string length zero?
  2907 00:13D6: F0 1B                        beq     COMPARE_N               ; Yes, must be shorter
  2908 00:13D8: E2 20                        short_a
  2909 00:13DA: B2 07                        lda     (7)                     ; Compare next characters
  2910 00:13DC: D2 03                        cmp     (3)
  2911 00:13DE: C2 20                        long_a
  2912 00:13E0: 90 11                        bcc     COMPARE_N
  2913 00:13E2: D0 0A                        bne     COMPARE_P
  2914                        
  2915 00:13E4: E6 03                        inc     <3                      ; Bump string pointers
  2916 00:13E6: E6 07                        inc     <7
  2917 00:13E8: C6 01                        dec     <1                      ; And reduce lengths
  2918 00:13EA: C6 05                        dec     <5
  2919 00:13EC: 80 DC                        bra     COMPARE
  2920                        
  2921 00:13EE: A9 01 00     COMPARE_P:      lda     #1
  2922 00:13F1: 80 03                        bra     COMPARE_X
  2923 00:13F3: A9 FF FF     COMPARE_N:      lda     #-1
  Tue May  3 2016 22:26                                                                                                    Page 58


  2924                        
  2925 00:13F6: 85 07        COMPARE_X:      sta     <7                      ; Save the result
  2926 00:13F8: 7B                           tdc
  2927 00:13F9: 18                           clc
  2928 00:13FA: 69 06 00                     adc     #6
  2929 00:13FD: 5B                           tcd
  2930 00:13FE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1402: 00 00 
  2931                        
  2932                        ; COUNT ( c-addr1 -- c-addr2 u )
  2933                        ;
  2934                        ; Return the character string specification for the counted string stored at
  2935                        ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
  2936                        ; the contents of the character at c-addr1, which is the length in characters
  2937                        ; of the string at c-addr2.
  2938                        ;
  2939                        ; In this implementation it is defined as
  2940                        ;
  2941                        ;   DUP CHAR+ SWAP C@
  2942                        
  2943 00:1404: C2 13 00 05                  HEADER  5,"COUNT",NORMAL
       00:1408: 43 4F 55 4E 
       00:140C: 54 
  2944 00:140D: 20 C1 14     COUNT:          jsr     DO_COLON
  2945 00:1410: 85 07                        dw      DUP
  2946 00:1412: 7A 06                        dw      CHAR_PLUS
  2947 00:1414: 0C 08                        dw      SWAP
  2948 00:1416: 0C 06                        dw      C_FETCH
  2949 00:1418: E6 0E                        dw      EXIT
  2950                        
  2951                        ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
  2952                        ;
  2953                        ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
  2954                        ; u2. If flag is true, a match was found at c-addr3 with u3 characters
  2955                        ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
  2956                        ; is u1.
  2957                        
  2958 00:141A: 07 14 00 06                  HEADER  6,"SEARCH",NORMAL
       00:141E: 53 45 41 52 
       00:1422: 43 48 
  2959 00:1424: 20 C1 14     SEARCH:         jsr     DO_COLON
  2960                        ; TODO
  2961 00:1427: BB C8 C8 7C                  CONTINUE
       00:142B: 00 00 
  2962                        
  2963                        ;===============================================================================
  2964                        ; Compiling Words
  2965                        ;-------------------------------------------------------------------------------
  2966                        
  2967                        ; ( ( -- )
  2968                        ;
  2969                        ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
  2970                        ;
  2971                        ; The number of characters in ccc may be zero to the number of characters in the
  2972                        ; parse area.
  2973                        ;
  2974                        ; In this implementation it is defined as:
  2975                        ;
  Tue May  3 2016 22:26                                                                                                    Page 59


  2976                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2977                        
  2978 00:142D: 1D 14 80 01                  HEADER  1,"(",IMMEDIATE
       00:1431: 28 
  2979 00:1432: 20 C1 14                     jsr     DO_COLON
  2980 00:1435: C7 16 29 00                  dw      DO_LITERAL,')'
  2981 00:1439: B4 12                        dw      WORD
  2982 00:143B: 74 07                        dw      DROP
  2983 00:143D: E6 0E                        dw      EXIT
  2984                        
  2985                        ; .(
  2986                        
  2987 00:143F: 30 14 80 02                  HEADER  2,".(",IMMEDIATE
       00:1443: 2E 28 
  2988 00:1445: 20 C1 14     DOT_PAREN:      jsr     DO_COLON
  2989 00:1448: C7 16 29 00                  dw      DO_LITERAL,')'
  2990 00:144C: B4 12                        dw      WORD
  2991 00:144E: 0D 14                        dw      COUNT
  2992 00:1450: FF 18                        dw      TYPE
  2993 00:1452: E6 0E                        dw      EXIT
  2994                        
  2995                        ; ." ( -- )
  2996                        
  2997 00:1454: 42 14 80                     LINK    IMMEDIATE
  2998 00:1457: 02 2E 22                     db      2,".",'"'
  2999 00:145A: 20 C1 14     DOT_QUOTE:      jsr     DO_COLON
  3000 00:145D: 69 17                        dw      S_QUOTE
  3001 00:145F: C7 16 FF 18                  dw      DO_LITERAL,TYPE
  3002 00:1463: 79 05                        dw      COMMA
  3003 00:1465: E6 0E                        dw      EXIT
  3004                        
  3005                        
  3006                        ; +LOOP ( -- )
  3007                        
  3008 00:1467: 57 14 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:146B: 2B 4C 4F 4F 
       00:146F: 50 
  3009 00:1470: 20 C1 14     PLUS_LOOP:      jsr     DO_COLON
  3010 00:1473: C7 16 89 14                  dw      DO_LITERAL,DO_PLUS_LOOP
  3011 00:1477: 79 05                        dw      COMMA
  3012 00:1479: 79 05                        dw      COMMA
  3013 00:147B: 48 07                        dw      QUERY_DUP
  3014 00:147D: 80 16 87 14                  dw      QUERY_BRANCH,PLUS_LOOP_1
  3015 00:1481: 24 06                        dw      HERE
  3016 00:1483: 0C 08                        dw      SWAP
  3017 00:1485: 4B 05                        dw      STORE
  3018 00:1487: E6 0E        PLUS_LOOP_1:    dw      EXIT
  3019                        
  3020                        DO_PLUS_LOOP:
  3021 00:1489: A6 01                        ldx     <1                      ; Fetch increment
  3022 00:148B: 7B                           tdc                             ; And drop
  3023 00:148C: 1A                           inc     a
  3024 00:148D: 1A                           inc     a
  3025 00:148E: 5B                           tcd
  3026 00:148F: 18                           clc                             ; Add to loop counter
  3027 00:1490: 8A                           txa
  3028 00:1491: 63 01                        adc     1,s
  3029 00:1493: 83 01                        sta     1,s
  Tue May  3 2016 22:26                                                                                                    Page 60


  3030 00:1495: C3 03                        cmp     3,s                     ; Reached limit?
  3031 00:1497: B0 0A                        bcs     DO_PLOOP_END            ; Yes
  3032 00:1499: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3033 00:149C: A8                           tay
  3034 00:149D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14A1: 00 00 
  3035                        
  3036 00:14A3: C8           DO_PLOOP_END:   iny                             ; Skip over address
  3037 00:14A4: C8                           iny
  3038 00:14A5: 68                           pla                             ; Drop loop variables
  3039 00:14A6: 68                           pla
  3040 00:14A7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14AB: 00 00 
  3041                        
  3042                        ; : ( -- )
  3043                        
  3044 00:14AD: 6A 14 00 01                  HEADER  1,":",NORMAL
       00:14B1: 3A 
  3045 00:14B2: 20 C1 14     COLON:          jsr     DO_COLON
  3046 00:14B5: AB 0E                        dw      CREATE
  3047 00:14B7: C7 16 C1 14                  dw      DO_LITERAL,DO_COLON
  3048 00:14BB: 94 0E                        dw      BUILD
  3049 00:14BD: 6F 18                        dw      RIGHT_BRACKET
  3050 00:14BF: E6 0E                        dw      EXIT
  3051                        
  3052                        DO_COLON:
  3053 00:14C1: FA                           plx                             ; Pull new word IP-1
  3054 00:14C2: 5A                           phy                             ; Save the old IP
  3055 00:14C3: E8                           inx                             ; Work out new IP
  3056 00:14C4: 9B                           txy
  3057 00:14C5: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14C9: 00 00 
  3058                        
  3059                        ; :NONAME ( -- xt )
  3060                        
  3061 00:14CB: B0 14 00 07                  HEADER  7,":NONAME",NORMAL
       00:14CF: 3A 4E 4F 4E 
       00:14D3: 41 4D 45 
  3062 00:14D6: 20 C1 14     NONAME:         jsr     DO_COLON
  3063 00:14D9: 24 06                        dw      HERE
  3064 00:14DB: C7 16 C1 14                  dw      DO_LITERAL,DO_COLON
  3065 00:14DF: 94 0E                        dw      BUILD
  3066 00:14E1: 6F 18                        dw      RIGHT_BRACKET
  3067 00:14E3: E6 0E                        dw      EXIT
  3068                        
  3069                        ; ; ( -- )
  3070                        
  3071 00:14E5: CE 14 80                     LINK    IMMEDIATE
  3072 00:14E8: 01 3B                        db      1,";"
  3073 00:14EA: 20 C1 14     SEMICOLON:      jsr     DO_COLON
  3074 00:14ED: C7 16 E6 0E                  dw      DO_LITERAL,EXIT
  3075 00:14F1: 79 05                        dw      COMMA
  3076 00:14F3: 4D 18                        dw      LEFT_BRACKET
  3077 00:14F5: E6 0E                        dw      EXIT
  3078                        
  3079                        ; ?DO ( -- )
  3080                        
  3081 00:14F7: E8 14 80 03                  HEADER  3,"?DO",IMMEDIATE
  Tue May  3 2016 22:26                                                                                                    Page 61


       00:14FB: 3F 44 4F 
  3082 00:14FE: 20 C1 14     QUERY_DO:       jsr     DO_COLON
  3083 00:1501: C7 16 11 15                  dw      DO_LITERAL,QUERY_DO_DO
  3084 00:1505: 79 05                        dw      COMMA
  3085 00:1507: 24 06                        dw      HERE
  3086 00:1509: CE 04                        dw      ZERO
  3087 00:150B: 79 05                        dw      COMMA
  3088 00:150D: 24 06                        dw      HERE
  3089 00:150F: E6 0E                        dw      EXIT
  3090                        
  3091                        QUERY_DO_DO:
  3092 00:1511: A5 01                        lda     <1                      ; Are the start and limit
  3093 00:1513: 45 03                        eor     <3                      ; .. the same?
  3094 00:1515: F0 05                        beq     QUERY_DO_DO_1
  3095 00:1517: C8                           iny                             ; No, Skip over jump address
  3096 00:1518: C8                           iny
  3097 00:1519: 4C 2E 16                     jmp     DO_DO                   ; And start a normal loop
  3098                        
  3099 00:151C: 7B           QUERY_DO_DO_1:  tdc                             ; Drop the loop parameters
  3100 00:151D: 1A                           inc     a
  3101 00:151E: 1A                           inc     a
  3102 00:151F: 1A                           inc     a
  3103 00:1520: 1A                           inc     a
  3104 00:1521: 5B                           tcd
  3105 00:1522: 4C 5F 16                     jmp     BRANCH                  ; And skip over loop
  3106                        
  3107                        ; 2CONSTANT ( x “<spaces>name” -- )
  3108                        ;
  3109                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3110                        ; definition for name with the execution semantics defined below.
  3111                        
  3112 00:1525: FA 14 00 09                  HEADER  9,"2CONSTANT",NORMAL
       00:1529: 32 43 4F 4E 
       00:152D: 53 54 41 4E 
       00:1531: 54 
  3113 00:1532: 20 C1 14     TWO_CONSTANT:   jsr     DO_COLON
  3114 00:1535: AB 0E                        dw      CREATE
  3115 00:1537: C7 16 43 15                  dw      DO_LITERAL,DO_TWO_CONSTANT
  3116 00:153B: 94 0E                        dw      BUILD
  3117 00:153D: 79 05                        dw      COMMA
  3118 00:153F: 79 05                        dw      COMMA
  3119 00:1541: E6 0E                        dw      EXIT; AGAIN ( -- )
  3120                        
  3121                        DO_TWO_CONSTANT:
  3122 00:1543: FA                           plx                             ; Get return address
  3123 00:1544: 7B                           tdc                             ; Create space on stack
  3124 00:1545: 3A                           dec     a
  3125 00:1546: 3A                           dec     a
  3126 00:1547: 3A                           dec     a
  3127 00:1548: 3A                           dec     a
  3128 00:1549: 5B                           tcd
  3129 00:154A: BD 01 00                     lda     !1,x                    ; Transfer the value
  3130 00:154D: 85 01                        sta     <1
  3131 00:154F: BD 03 00                     lda     !3,x
  3132 00:1552: 85 03                        sta     <3
  3133 00:1554: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1558: 00 00 
  3134                        
  Tue May  3 2016 22:26                                                                                                    Page 62


  3135                        ; 2LITERAL
  3136                        
  3137 00:155A: 28 15 80 08                  HEADER  8,"2LITERAL",IMMEDIATE
       00:155E: 32 4C 49 54 
       00:1562: 45 52 41 4C 
  3138 00:1566: 20 C1 14     TWO_LITERAL:    jsr     DO_COLON
  3139 00:1569: C7 16 75 15                  dw      DO_LITERAL,DO_TWO_LITERAL
  3140 00:156D: 79 05                        dw      COMMA
  3141 00:156F: 79 05                        dw      COMMA
  3142 00:1571: 79 05                        dw      COMMA
  3143 00:1573: E6 0E                        dw      EXIT
  3144                        
  3145                        DO_TWO_LITERAL:
  3146 00:1575: 7B                           tdc                             ; Make room on stack
  3147 00:1576: 3A                           dec     a
  3148 00:1577: 3A                           dec     a
  3149 00:1578: 3A                           dec     a
  3150 00:1579: 3A                           dec     a
  3151 00:157A: 5B                           tcd
  3152 00:157B: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3153 00:157E: 85 01                        sta     <1
  3154 00:1580: B9 02 00                     lda     !2,y
  3155 00:1583: 85 03                        sta     <3
  3156 00:1585: C8                           iny                             ; Bump IP
  3157 00:1586: C8                           iny
  3158 00:1587: C8                           iny
  3159 00:1588: C8                           iny
  3160 00:1589: BB C8 C8 7C                  CONTINUE                        ; Done
       00:158D: 00 00 
  3161                        
  3162                        ; 2VARIABLE
  3163                        
  3164 00:158F: 5D 15 80 09                  HEADER  9,"2VARIABLE",IMMEDIATE
       00:1593: 32 56 41 52 
       00:1597: 49 41 42 4C 
       00:159B: 45 
  3165 00:159C: 20 C1 14     TWO_VARIABLE:   jsr     DO_COLON
  3166 00:159F: AB 0E                        dw      CREATE
  3167 00:15A1: C7 16 12 18                  dw      DO_LITERAL,DO_VARIABLE
  3168 00:15A5: 94 0E                        dw      BUILD
  3169 00:15A7: C7 16 02 00                  dw      DO_LITERAL,2
  3170 00:15AB: 69 06                        dw      CELLS
  3171 00:15AD: CC 05                        dw      ALLOT
  3172 00:15AF: E6 0E                        dw      EXIT
  3173                        
  3174                        ; ABORT" ( -- )
  3175                        
  3176 00:15B1: 92 15 80                     LINK    IMMEDIATE
  3177 00:15B4: 06 41 42 4F                  db      6,"ABORT",'"'
       00:15B8: 52 54 22 
  3178 00:15BB: 20 C1 14     ABORT_QUOTE:    jsr     DO_COLON
  3179 00:15BE: 69 17                        dw      S_QUOTE
  3180 00:15C0: C7 16 69 0E                  dw      DO_LITERAL,QUERY_ABORT
  3181 00:15C4: 79 05                        dw      COMMA
  3182 00:15C6: E6 0E                        dw      EXIT
  3183                        
  3184                        ; AGAIN ( -- )
  3185 00:15C8: B4 15 80 05                  HEADER  5,"AGAIN",IMMEDIATE
  Tue May  3 2016 22:26                                                                                                    Page 63


       00:15CC: 41 47 41 49 
       00:15D0: 4E 
  3186 00:15D1: 20 C1 14     AGAIN:          jsr     DO_COLON
  3187 00:15D4: C7 16 5F 16                  dw      DO_LITERAL,BRANCH
  3188 00:15D8: 79 05                        dw      COMMA
  3189 00:15DA: 79 05                        dw      COMMA
  3190 00:15DC: E6 0E                        dw      EXIT
  3191                        
  3192                        ; BEGIN ( -- )
  3193                        
  3194 00:15DE: CB 15 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:15E2: 42 45 47 49 
       00:15E6: 4E 
  3195 00:15E7: 20 C1 14     BEGIN:          jsr     DO_COLON
  3196 00:15EA: 24 06                        dw      HERE
  3197 00:15EC: E6 0E                        dw      EXIT
  3198                        
  3199                        ; CONSTANT ( x “<spaces>name” -- )
  3200                        ;
  3201                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3202                        ; definition for name with the execution semantics defined below.
  3203                        
  3204 00:15EE: E1 15 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:15F2: 43 4F 4E 53 
       00:15F6: 54 41 4E 54 
  3205 00:15FA: 20 C1 14     CONSTANT:       jsr     DO_COLON
  3206 00:15FD: AB 0E                        dw      CREATE
  3207 00:15FF: C7 16 09 16                  dw      DO_LITERAL,DO_CONSTANT
  3208 00:1603: 94 0E                        dw      BUILD
  3209 00:1605: 79 05                        dw      COMMA
  3210 00:1607: E6 0E                        dw      EXIT
  3211                        
  3212                        DO_CONSTANT:
  3213 00:1609: FA                           plx                             ; Get return address
  3214 00:160A: 7B                           tdc                             ; Create space on stack
  3215 00:160B: 3A                           dec     a
  3216 00:160C: 3A                           dec     a
  3217 00:160D: 5B                           tcd
  3218 00:160E: BD 01 00                     lda     !1,x                    ; Transfer the value
  3219 00:1611: 85 01                        sta     <1
  3220 00:1613: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1617: 00 00 
  3221                        
  3222                        ; DO ( -- )
  3223                        
  3224 00:1619: F1 15 80 02                  HEADER  2,"DO",IMMEDIATE
       00:161D: 44 4F 
  3225 00:161F: 20 C1 14     DO:             jsr     DO_COLON
  3226 00:1622: C7 16 2E 16                  dw      DO_LITERAL,DO_DO
  3227 00:1626: 79 05                        dw      COMMA
  3228 00:1628: CE 04                        dw      ZERO
  3229 00:162A: 24 06                        dw      HERE
  3230 00:162C: E6 0E                        dw      EXIT
  3231                        
  3232                        DO_DO:
  3233 00:162E: A5 03                        lda     <3
  3234 00:1630: 48                           pha
  3235 00:1631: A5 01                        lda     <1
  Tue May  3 2016 22:26                                                                                                    Page 64


  3236 00:1633: 48                           pha
  3237 00:1634: 7B                           tdc
  3238 00:1635: 1A                           inc     a
  3239 00:1636: 1A                           inc     a
  3240 00:1637: 1A                           inc     a
  3241 00:1638: 1A                           inc     a
  3242 00:1639: 5B                           tcd
  3243 00:163A: BB C8 C8 7C                  CONTINUE
       00:163E: 00 00 
  3244                        
  3245                        ; ELSE ( -- )
  3246                        
  3247 00:1640: 1C 16 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:1644: 45 4C 53 45 
  3248 00:1648: 20 C1 14     ELSE:           jsr     DO_COLON
  3249 00:164B: C7 16 5F 16                  dw      DO_LITERAL,BRANCH
  3250 00:164F: 79 05                        dw      COMMA
  3251 00:1651: 24 06                        dw      HERE
  3252 00:1653: CE 04                        dw      ZERO
  3253 00:1655: 79 05                        dw      COMMA
  3254 00:1657: 24 06                        dw      HERE
  3255 00:1659: 0C 08                        dw      SWAP
  3256 00:165B: 4B 05                        dw      STORE
  3257 00:165D: E6 0E                        dw      EXIT
  3258                        
  3259                        BRANCH:
  3260 00:165F: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  3261 00:1662: A8                           tay
  3262 00:1663: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1667: 00 00 
  3263                        
  3264                        ; IF ( -- )
  3265                        
  3266 00:1669: 43 16 80 02                  HEADER  2,"IF",IMMEDIATE
       00:166D: 49 46 
  3267 00:166F: 20 C1 14     IF:             jsr     DO_COLON
  3268 00:1672: C7 16 80 16                  dw      DO_LITERAL,QUERY_BRANCH
  3269 00:1676: 79 05                        dw      COMMA
  3270 00:1678: 24 06                        dw      HERE
  3271 00:167A: CE 04                        dw      ZERO
  3272 00:167C: 79 05                        dw      COMMA
  3273 00:167E: E6 0E                        dw      EXIT
  3274                        
  3275                        QUERY_BRANCH:
  3276 00:1680: A6 01                        ldx     <1                      ; Pull the top of stack value
  3277 00:1682: 7B                           tdc
  3278 00:1683: 1A                           inc     a                       ; Drop top item
  3279 00:1684: 1A                           inc     a
  3280 00:1685: 5B                           tcd
  3281 00:1686: 8A                           txa
  3282 00:1687: F0 D6                        beq     BRANCH                  ; Branch if top was zero
  3283 00:1689: C8                           iny                             ; Otherwise skip address
  3284 00:168A: C8                           iny
  3285 00:168B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:168F: 00 00 
  3286                        
  3287                        ; IMMEDIATE ( -- )
  3288                        
  Tue May  3 2016 22:26                                                                                                    Page 65


  3289 00:1691: 6C 16 80 09                  HEADER  9,"IMMEDIATE",IMMEDIATE
       00:1695: 49 4D 4D 45 
       00:1699: 44 49 41 54 
       00:169D: 45 
  3290 00:169E: 20 C1 14                     jsr     DO_COLON
  3291 00:16A1: C7 16 80 00                  dw      DO_LITERAL,IMMEDIATE
  3292 00:16A5: 94 04                        dw      LATEST
  3293 00:16A7: B9 05                        dw      FETCH
  3294 00:16A9: 7E 09                        dw      ONE_MINUS
  3295 00:16AB: DB 05                        dw      C_STORE
  3296 00:16AD: E6 0E                        dw      EXIT
  3297                        
  3298                        ; LITERAL ( x -- )
  3299                        ;
  3300                        ; Append the run-time semantics given below to the current definition.
  3301                        
  3302 00:16AF: 94 16 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:16B3: 4C 49 54 45 
       00:16B7: 52 41 4C 
  3303 00:16BA: 20 C1 14     LITERAL:        jsr     DO_COLON
  3304 00:16BD: C7 16 C7 16                  dw      DO_LITERAL,DO_LITERAL
  3305 00:16C1: 79 05                        dw      COMMA
  3306 00:16C3: 79 05                        dw      COMMA
  3307 00:16C5: E6 0E                        dw      EXIT
  3308                        
  3309                        DO_LITERAL:
  3310 00:16C7: 7B                           tdc                             ; Make room on stack
  3311 00:16C8: 3A                           dec     a
  3312 00:16C9: 3A                           dec     a
  3313 00:16CA: 5B                           tcd
  3314 00:16CB: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3315 00:16CE: 85 01                        sta     <1
  3316 00:16D0: C8                           iny
  3317 00:16D1: C8                           iny
  3318 00:16D2: BB C8 C8 7C                  CONTINUE                        ; Done
       00:16D6: 00 00 
  3319                        
  3320                        ; LOOP
  3321                        
  3322 00:16D8: B2 16 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:16DC: 4C 4F 4F 50 
  3323 00:16E0: 20 C1 14     LOOP:           jsr     DO_COLON
  3324 00:16E3: C7 16 F9 16                  dw      DO_LITERAL,DO_LOOP
  3325 00:16E7: 79 05                        dw      COMMA
  3326 00:16E9: 79 05                        dw      COMMA
  3327 00:16EB: 48 07                        dw      QUERY_DUP
  3328 00:16ED: 80 16 F7 16                  dw      QUERY_BRANCH,LOOP_1
  3329 00:16F1: 24 06                        dw      HERE
  3330 00:16F3: 0C 08                        dw      SWAP
  3331 00:16F5: 4B 05                        dw      STORE
  3332 00:16F7: E6 0E        LOOP_1:         dw      EXIT
  3333                        
  3334                        ; (LOOP)
  3335                        
  3336                        ;               HEADER  6,"(LOOP)",NORMAL
  3337                        DO_LOOP
  3338 00:16F9: A3 01                        lda     1,s                     ; Add one to loop counter
  3339 00:16FB: 1A                           inc     a
  Tue May  3 2016 22:26                                                                                                    Page 66


  3340 00:16FC: 83 01                        sta     1,s
  3341 00:16FE: C3 03                        cmp     3,s                     ; Reached limit?
  3342 00:1700: B0 0A                        bcs     DO_LOOP_END             ; Yes
  3343 00:1702: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3344 00:1705: A8                           tay
  3345 00:1706: BB C8 C8 7C                  CONTINUE                        ; Done
       00:170A: 00 00 
  3346                        
  3347 00:170C: C8           DO_LOOP_END:    iny                             ; Skip over address
  3348 00:170D: C8                           iny
  3349 00:170E: 68                           pla                             ; Drop loop variables
  3350 00:170F: 68                           pla
  3351 00:1710: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1714: 00 00 
  3352                        
  3353                        ; POSTPONE
  3354                        
  3355                        ;   BL WORD FIND
  3356                        ;   DUP 0= ABORT" ?"
  3357                        ;   0< IF   -- xt       non immed: add code to current
  3358                        ;                       def'n to compile xt later.
  3359                        ;       ['] LIT ,XT  ,  add "LIT,xt,COMMAXT"
  3360                        ;       ['] ,XT ,XT     to current definition
  3361                        ;   ELSE  ,XT      immed: compile into cur. def'n
  3362                        ;   THEN ; IMMEDIATE
  3363                        
  3364 00:1716: DB 16 80 08                  HEADER  8,"POSTPONE",IMMEDIATE
       00:171A: 50 4F 53 54 
       00:171E: 50 4F 4E 45 
  3365 00:1722: 20 C1 14     POSTPONE:       jsr     DO_COLON
  3366 00:1725: E0 04                        dw      BL
  3367 00:1727: B4 12                        dw      WORD
  3368 00:1729: 49 11                        dw      FIND
  3369 00:172B: 85 07                        dw      DUP
  3370 00:172D: 06 0D                        dw      ZERO_EQUAL
  3371 00:172F: 82 17                        dw      DO_S_QUOTE
  3372 00:1731: 01 3F                        db      1,"?"
  3373 00:1733: 69 0E                        dw      QUERY_ABORT
  3374 00:1735: DD 0C                        dw      ZERO_LESS
  3375 00:1737: 80 16 47 17                  dw      QUERY_BRANCH,POSTPONE_1
  3376 00:173B: C7 16 C7 16                  dw      DO_LITERAL,DO_LITERAL
  3377 00:173F: 79 05                        dw      COMMA
  3378 00:1741: 79 05                        dw      COMMA
  3379 00:1743: 5F 16 49 17                  dw      BRANCH,POSTPONE_2
  3380 00:1747: 79 05        POSTPONE_1:     dw      COMMA
  3381 00:1749: E6 0E        POSTPONE_2:     dw      EXIT
  3382                        
  3383                        ; RECURSE ( -- )
  3384                        
  3385 00:174B: 19 17 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:174F: 52 45 43 55 
       00:1753: 52 53 45 
  3386 00:1756: 20 C1 14     RECURSE:        jsr     DO_COLON
  3387 00:1759: 94 04                        dw      LATEST
  3388 00:175B: B9 05                        dw      FETCH
  3389 00:175D: 91 11                        dw      NFA_TO_CFA
  3390 00:175F: 79 05                        dw      COMMA
  3391 00:1761: E6 0E                        dw      EXIT
  Tue May  3 2016 22:26                                                                                                    Page 67


  3392                        
  3393                        ; S"
  3394                        
  3395 00:1763: 4E 17 80                     LINK    IMMEDIATE
  3396 00:1766: 02 53 22                     db      2,"S",'"'
  3397 00:1769: 20 C1 14     S_QUOTE:        jsr     DO_COLON
  3398 00:176C: C7 16 82 17                  dw      DO_LITERAL,DO_S_QUOTE
  3399 00:1770: 79 05                        dw      COMMA
  3400 00:1772: C7 16 22 00                  dw      DO_LITERAL,'"'
  3401 00:1776: B4 12                        dw      WORD
  3402 00:1778: 0C 06                        dw      C_FETCH
  3403 00:177A: 70 09                        dw      ONE_PLUS
  3404 00:177C: 47 06                        dw      ALIGNED
  3405 00:177E: CC 05                        dw      ALLOT
  3406 00:1780: E6 0E                        dw      EXIT
  3407                        
  3408                        ; (S") ( -- c-addr u )
  3409                        
  3410                        DO_S_QUOTE:
  3411 00:1782: 20 C1 14                     jsr     DO_COLON
  3412 00:1785: B7 08                        dw      R_FROM
  3413 00:1787: 0D 14                        dw      COUNT
  3414 00:1789: BF 06                        dw      TWO_DUP
  3415 00:178B: 18 09                        dw      PLUS
  3416 00:178D: 47 06                        dw      ALIGNED
  3417 00:178F: 7E 08                        dw      TO_R
  3418 00:1791: E6 0E                        dw      EXIT
  3419                        
  3420                        ; THEN ( -- )
  3421                        
  3422 00:1793: 66 17 80 04                  HEADER  4,"THEN",IMMEDIATE
       00:1797: 54 48 45 4E 
  3423 00:179B: 20 C1 14     THEN:           jsr     DO_COLON
  3424 00:179E: 24 06                        dw      HERE
  3425 00:17A0: 0C 08                        dw      SWAP
  3426 00:17A2: 4B 05                        dw      STORE
  3427 00:17A4: E6 0E                        dw      EXIT
  3428                        
  3429                        ; UNTIL ( -- )
  3430                        
  3431 00:17A6: 96 17 80 05                  HEADER  5,"UNTIL",IMMEDIATE
       00:17AA: 55 4E 54 49 
       00:17AE: 4C 
  3432 00:17AF: 20 C1 14     UNTIL:          jsr     DO_COLON
  3433 00:17B2: C7 16 80 16                  dw      DO_LITERAL,QUERY_BRANCH
  3434 00:17B6: 79 05                        dw      COMMA
  3435 00:17B8: 79 05                        dw      COMMA
  3436 00:17BA: E6 0E                        dw      EXIT
  3437                        
  3438                        ; USER
  3439                        
  3440 00:17BC: A9 17 00 04                  HEADER  4,"USER",NORMAL
       00:17C0: 55 53 45 52 
  3441 00:17C4: 20 C1 14     USER:           jsr     DO_COLON
  3442 00:17C7: AB 0E                        dw      CREATE
  3443 00:17C9: C7 16 DD 17                  dw      DO_LITERAL,DO_USER
  3444 00:17CD: 94 0E                        dw      BUILD
  3445 00:17CF: 79 05                        dw      COMMA
  Tue May  3 2016 22:26                                                                                                    Page 68


  3446 00:17D1: E6 0E                        dw      EXIT
  3447                        
  3448 00:17D3: BF 17 00 06                  HEADER  6,"(USER)",NORMAL
       00:17D7: 28 55 53 45 
       00:17DB: 52 29 
  3449                        DO_USER:
  3450 00:17DD: 7B                           tdc
  3451 00:17DE: 3A                           dec     a                       ; Push on data stack
  3452 00:17DF: 3A                           dec     a
  3453 00:17E0: 5B                           tcd
  3454 00:17E1: FA                           plx
  3455 00:17E2: 18                           clc
  3456 00:17E3: BD 01 00                     lda     !1,x
  3457 00:17E6: 69 00 00                     adc     #USER_AREA
  3458 00:17E9: 85 01                        sta     <1
  3459 00:17EB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:17EF: 00 00 
  3460                        
  3461                        ; VARIABLE ( “<spaces>name” -- )
  3462                        ;
  3463                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3464                        ; definition for name with the execution semantics defined below. Reserve one
  3465                        ; cell of data space at an aligned address.
  3466                        
  3467 00:17F1: D6 17 00                     LINK    NORMAL
  3468 00:17F4: 08 56 41 52                  db      8,"VARIABLE"
       00:17F8: 49 41 42 4C 
       00:17FC: 45 
  3469 00:17FD: 20 C1 14     VARIABLE:       jsr     DO_COLON
  3470 00:1800: AB 0E                        dw      CREATE
  3471 00:1802: C7 16 12 18                  dw      DO_LITERAL,DO_VARIABLE
  3472 00:1806: 94 0E                        dw      BUILD
  3473 00:1808: C7 16 01 00                  dw      DO_LITERAL,1
  3474 00:180C: 69 06                        dw      CELLS
  3475 00:180E: CC 05                        dw      ALLOT
  3476 00:1810: E6 0E                        dw      EXIT
  3477                        
  3478                        DO_VARIABLE:
  3479 00:1812: 7B                           tdc
  3480 00:1813: 3A                           dec     a
  3481 00:1814: 3A                           dec     a
  3482 00:1815: 5B                           tcd
  3483 00:1816: 68                           pla
  3484 00:1817: 1A                           inc     a
  3485 00:1818: 85 01                        sta     <1
  3486 00:181A: BB C8 C8 7C                  CONTINUE
       00:181E: 00 00 
  3487                        
  3488                        ; WORDS ( -- )
  3489                        ;
  3490                        ;   LATEST @ BEGIN
  3491                        ;       DUP COUNT TYPE SPACE
  3492                        ;       NFA>LFA @
  3493                        ;   DUP 0= UNTIL
  3494                        ;   DROP ;
  3495                        
  3496 00:1820: F4 17 00 05                  HEADER  5,"WORDS",NORMAL
       00:1824: 57 4F 52 44 
  Tue May  3 2016 22:26                                                                                                    Page 69


       00:1828: 53 
  3497 00:1829: 20 C1 14                     jsr     DO_COLON
  3498 00:182C: 94 04                        dw      LATEST
  3499 00:182E: B9 05                        dw      FETCH
  3500 00:1830: 85 07        WORDS_1:        dw      DUP
  3501 00:1832: 0D 14                        dw      COUNT
  3502 00:1834: FF 18                        dw      TYPE
  3503 00:1836: CD 18                        dw      SPACE
  3504 00:1838: 9A 11                        dw      NFA_TO_LFA
  3505 00:183A: B9 05                        dw      FETCH
  3506 00:183C: 85 07                        dw      DUP
  3507 00:183E: 06 0D                        dw      ZERO_EQUAL
  3508 00:1840: 80 16 30 18                  dw      QUERY_BRANCH,WORDS_1
  3509 00:1844: 74 07                        dw      DROP
  3510 00:1846: E6 0E                        dw      EXIT
  3511                        
  3512                        ; [
  3513                        ;
  3514                        ; In this implementation it is defined as
  3515                        ;
  3516                        ;   0 STATE !
  3517                        
  3518 00:1848: 23 18 80 01                  HEADER  1,"[",IMMEDIATE
       00:184C: 5B 
  3519 00:184D: 20 C1 14     LEFT_BRACKET:   jsr     DO_COLON
  3520 00:1850: CE 04                        dw      ZERO
  3521 00:1852: B8 04                        dw      STATE
  3522 00:1854: 4B 05                        dw      STORE
  3523 00:1856: E6 0E                        dw      EXIT
  3524                        
  3525                        ; \ ( -- )
  3526                        ;
  3527                        ; Parse and discard the remainder of the parse area. \ is an immediate word.
  3528                        ;
  3529                        ; In this implementation it is defined as
  3530                        ;
  3531                        ;   1 WORD DROP
  3532                        
  3533 00:1858: 4B 18 80 01                  HEADER  1,"\",IMMEDIATE
       00:185C: 5C 
  3534 00:185D: 20 C1 14     BACKSLASH:      jsr     DO_COLON
  3535 00:1860: C7 16 01 00                  dw      DO_LITERAL,1
  3536 00:1864: B4 12                        dw      WORD
  3537 00:1866: 74 07                        dw      DROP
  3538 00:1868: E6 0E                        dw      EXIT
  3539                        
  3540                        ; ]
  3541                        ;
  3542                        ; In this implementation it is defined as
  3543                        ;
  3544                        ;   -1 STATE !
  3545                        
  3546 00:186A: 5B 18 00 01                  HEADER  1,"]",NORMAL
       00:186E: 5D 
  3547 00:186F: 20 C1 14     RIGHT_BRACKET:  jsr     DO_COLON
  3548 00:1872: C7 16 FF FF                  dw      DO_LITERAL,-1
  3549 00:1876: B8 04                        dw      STATE
  3550 00:1878: 4B 05                        dw      STORE
  Tue May  3 2016 22:26                                                                                                    Page 70


  3551 00:187A: E6 0E                        dw      EXIT
  3552                        
  3553                        ;===============================================================================
  3554                        ; I/O Operations
  3555                        ;-------------------------------------------------------------------------------
  3556                        
  3557                        ; CR ( -- )
  3558                        ;
  3559                        ; Cause subsequent output to appear at the beginning of the next line.
  3560                        ;
  3561                        ; In this implementation it is defined as
  3562                        ;
  3563                        ;   13 EMIT 10 EMIT
  3564                        
  3565 00:187C: 6D 18 00 02                  HEADER  2,"CR",NORMAL
       00:1880: 43 52 
  3566 00:1882: 20 C1 14     CR:             jsr     DO_COLON
  3567 00:1885: C7 16 0D 00                  dw      DO_LITERAL,13
  3568 00:1889: 9B 18                        dw      EMIT
  3569 00:188B: C7 16 0A 00                  dw      DO_LITERAL,10
  3570 00:188F: 9B 18                        dw      EMIT
  3571 00:1891: E6 0E                        dw      EXIT
  3572                        
  3573                        ; EMIT ( x -- )
  3574                        ;
  3575                        ; If x is a graphic character in the implementation-defined character set,
  3576                        ; display x. The effect of EMIT for all other values of x is implementation
  3577                        ; -defined.
  3578                        
  3579 00:1893: 7F 18 00 04                  HEADER  4,"EMIT",NORMAL
       00:1897: 45 4D 49 54 
  3580                                        extern  UartTx
  3581                        EMIT:
  3582 00:189B: A5 01                        lda     <1                      ; Fetch character from stack
  3583 00:189D: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  3584 00:18A0: 7B                           tdc
  3585 00:18A1: 1A                           inc     a                       ; Drop the character
  3586 00:18A2: 1A                           inc     a
  3587 00:18A3: 5B                           tcd
  3588 00:18A4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:18A8: 00 00 
  3589                        
  3590                        ; KEY ( -- char )
  3591                        ;
  3592                        ; Receive one character char, a member of the implementation-defined character
  3593                        ; set. Keyboard events that do not correspond to such characters are discarded
  3594                        ; until a valid character is received, and those events are subsequently
  3595                        ; unavailable.
  3596                        ;
  3597                        ; All standard characters can be received. Characters received by KEY are not
  3598                        ; displayed.
  3599                        
  3600 00:18AA: 96 18 00 03                  HEADER  3,"KEY",NORMAL
       00:18AE: 4B 45 59 
  3601                                        extern  UartRx
  3602                        KEY:
  3603 00:18B1: 20 xx xx                     jsr     UartRx                  ; Receive a character
  3604 00:18B4: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  Tue May  3 2016 22:26                                                                                                    Page 71


  3605 00:18B7: AA                           tax
  3606 00:18B8: 7B                           tdc
  3607 00:18B9: 3A                           dec     a                       ; And push to stack
  3608 00:18BA: 3A                           dec     a
  3609 00:18BB: 5B                           tcd
  3610 00:18BC: 86 01                        stx     <1
  3611 00:18BE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:18C2: 00 00 
  3612                        
  3613                        ; SPACE ( -- )
  3614                        ;
  3615                        ; Display one space.
  3616                        ;
  3617                        ; In this implementation it is defined as
  3618                        ;
  3619                        ;   BL EMIT
  3620                        
  3621 00:18C4: AD 18 00 05                  HEADER  5,"SPACE",NORMAL
       00:18C8: 53 50 41 43 
       00:18CC: 45 
  3622 00:18CD: 20 C1 14     SPACE:          jsr     DO_COLON
  3623 00:18D0: E0 04                        dw      BL
  3624 00:18D2: 9B 18                        dw      EMIT
  3625 00:18D4: E6 0E                        dw      EXIT
  3626                        
  3627                        ; SPACES ( n -- )
  3628                        ;
  3629                        ; If n is greater than zero, display n spaces.
  3630                        ;
  3631                        ; In this implementation it is defined as
  3632                        ;
  3633                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  3634                        
  3635 00:18D6: C7 18 00 06                  HEADER  6,"SPACES",NORMAL
       00:18DA: 53 50 41 43 
       00:18DE: 45 53 
  3636 00:18E0: 20 C1 14     SPACES:         jsr     DO_COLON
  3637 00:18E3: 85 07        SPACES_1:       dw      DUP
  3638 00:18E5: 1A 0D                        dw      ZERO_GREATER
  3639 00:18E7: 80 16 F3 18                  dw      QUERY_BRANCH,SPACES_2
  3640 00:18EB: CD 18                        dw      SPACE
  3641 00:18ED: 7E 09                        dw      ONE_MINUS
  3642 00:18EF: 5F 16 E3 18                  dw      BRANCH,SPACES_1
  3643 00:18F3: 74 07        SPACES_2:       dw      DROP
  3644 00:18F5: E6 0E                        dw      EXIT
  3645                        
  3646                        ; TYPE ( c-addr u -- )
  3647                        ;
  3648                        ; If u is greater than zero, display the character string specified by c-addr
  3649                        ; and u.
  3650                        ;
  3651                        ; In this implementation it is defined as
  3652                        ;
  3653                        ;   ?DUP IF
  3654                        ;     OVER + SWAP DO I C@ EMIT LOOP
  3655                        ;   ELSE DROP THEN
  3656                        
  3657 00:18F7: D9 18 00 04                  HEADER  4,"TYPE",NORMAL
  Tue May  3 2016 22:26                                                                                                    Page 72


       00:18FB: 54 59 50 45 
  3658 00:18FF: 20 C1 14     TYPE:           jsr     DO_COLON
  3659 00:1902: 48 07                        dw      QUERY_DUP
  3660 00:1904: 80 16 1E 19                  dw      QUERY_BRANCH,TYPE_2
  3661 00:1908: A8 07                        dw      OVER
  3662 00:190A: 18 09                        dw      PLUS
  3663 00:190C: 0C 08                        dw      SWAP
  3664 00:190E: 2E 16                        dw      DO_DO
  3665 00:1910: 90 08        TYPE_1:         dw      I
  3666 00:1912: 0C 06                        dw      C_FETCH
  3667 00:1914: 9B 18                        dw      EMIT
  3668 00:1916: F9 16 10 19                  dw      DO_LOOP,TYPE_1
  3669 00:191A: 5F 16 20 19                  dw      BRANCH,TYPE_3
  3670 00:191E: 74 07        TYPE_2          dw      DROP
  3671 00:1920: E6 0E        TYPE_3          dw      EXIT
  3672                        
  3673                        ;===============================================================================
  3674                        ; Formatted Output
  3675                        ;-------------------------------------------------------------------------------
  3676                        
  3677                        ; # ( ud1 -- ud2 )
  3678                        ;
  3679                        ; Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
  3680                        ; (n is the least-significant digit of ud1.) Convert n to external form and add
  3681                        ; the resulting character to the beginning of the pictured numeric output string.
  3682                        ; An ambiguous condition exists if # executes outside of a <# #> delimited
  3683                        ; number conversion.
  3684                        ;
  3685                        ;       BASE @ >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ROT DUP 9 > 7 AND + 30 + HOLD
  3686                        
  3687 00:1922: FA 18 00 01                  HEADER  1,"#",NORMAL
       00:1926: 23 
  3688 00:1927: 20 C1 14     HASH:           jsr     DO_COLON
  3689 00:192A: 64 04                        dw      BASE
  3690 00:192C: B9 05                        dw      FETCH
  3691 00:192E: 7E 08                        dw      TO_R
  3692 00:1930: CE 04                        dw      ZERO
  3693 00:1932: CA 08                        dw      R_FETCH
  3694 00:1934: A8 0C                        dw      UM_SLASH_MOD
  3695 00:1936: F2 07                        dw      ROT
  3696 00:1938: F2 07                        dw      ROT
  3697 00:193A: B7 08                        dw      R_FROM
  3698 00:193C: A8 0C                        dw      UM_SLASH_MOD
  3699 00:193E: F2 07                        dw      ROT
  3700 00:1940: F2 07                        dw      ROT
  3701 00:1942: 85 07                        dw      DUP
  3702 00:1944: C7 16 09 00                  dw      DO_LITERAL,9
  3703 00:1948: 70 0D                        dw      GREATER
  3704 00:194A: C7 16 07 00                  dw      DO_LITERAL,7
  3705 00:194E: BD 0D                        dw      AND
  3706 00:1950: 18 09                        dw      PLUS
  3707 00:1952: C7 16 30 00                  dw      DO_LITERAL,'0'
  3708 00:1956: 18 09                        dw      PLUS
  3709 00:1958: C1 19                        dw      HOLD
  3710 00:195A: E6 0E                        dw      EXIT
  3711                        
  3712                        ; #> ( xd -- c-addr u )
  3713                        ;
  Tue May  3 2016 22:26                                                                                                    Page 73


  3714                        ; Drop xd. Make the pictured numeric output string available as a character
  3715                        ; string. c-addr and u specify the resulting character string. A program may
  3716                        ; replace characters within the string.
  3717                        ;
  3718                        ;       2DROP HP @ PAD OVER -
  3719                        
  3720 00:195C: 25 19 00 02                  HEADER  2,"#>",NORMAL
       00:1960: 23 3E 
  3721 00:1962: 20 C1 14     HASH_GREATER:   jsr     DO_COLON
  3722 00:1965: AB 06                        dw      TWO_DROP
  3723 00:1967: 85 04                        dw      HP
  3724 00:1969: B9 05                        dw      FETCH
  3725 00:196B: DB 19                        dw      PAD
  3726 00:196D: A8 07                        dw      OVER
  3727 00:196F: 2E 09                        dw      MINUS
  3728 00:1971: E6 0E                        dw      EXIT
  3729                        
  3730                        ; #S ( ud1 -- ud2 )
  3731                        ;
  3732                        ; Convert one digit of ud1 according to the rule for #. Continue conversion
  3733                        ; until the quotient is zero. ud2 is zero. An ambiguous condition exists if #S
  3734                        ; executes outside of a <# #> delimited number conversion.
  3735                        ;
  3736                        ;       BEGIN # 2DUP OR 0= UNTIL
  3737                        
  3738 00:1973: 5F 19 00 02                  HEADER  2,"#S",NORMAL
       00:1977: 23 53 
  3739 00:1979: 20 C1 14     HASH_S:         jsr     DO_COLON
  3740 00:197C: 27 19        HASH_S_1:       dw      HASH
  3741 00:197E: BF 06                        dw      TWO_DUP
  3742 00:1980: 16 0E                        dw      OR
  3743 00:1982: 06 0D                        dw      ZERO_EQUAL
  3744 00:1984: 80 16 7C 19                  dw      QUERY_BRANCH,HASH_S_1
  3745 00:1988: E6 0E                        dw      EXIT
  3746                        
  3747                        ; . ( n -- )
  3748                        ;
  3749                        ; Display n in free field format.
  3750                        ;
  3751                        ;       <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE
  3752                        
  3753 00:198A: 76 19 00 01                  HEADER  1,".",NORMAL
       00:198E: 2E 
  3754 00:198F: 20 C1 14     DOT:            jsr     DO_COLON
  3755 00:1992: AE 19                        dw      LESS_HASH
  3756 00:1994: 85 07                        dw      DUP
  3757 00:1996: B9 09                        dw      ABS
  3758 00:1998: CE 04                        dw      ZERO
  3759 00:199A: 79 19                        dw      HASH_S
  3760 00:199C: F2 07                        dw      ROT
  3761 00:199E: E8 19                        dw      SIGN
  3762 00:19A0: 62 19                        dw      HASH_GREATER
  3763 00:19A2: FF 18                        dw      TYPE
  3764 00:19A4: CD 18                        dw      SPACE
  3765 00:19A6: E6 0E                        dw      EXIT
  3766                        
  3767                        ; <# ( -- )
  3768                        ;
  Tue May  3 2016 22:26                                                                                                    Page 74


  3769                        ; Initialize the pictured numeric output conversion process.
  3770                        ;
  3771                        ;       PAD HP !
  3772                        
  3773 00:19A8: 8D 19 00 02                  HEADER  2,"<#",NORMAL
       00:19AC: 3C 23 
  3774 00:19AE: 20 C1 14     LESS_HASH:      jsr     DO_COLON
  3775 00:19B1: DB 19                        dw      PAD
  3776 00:19B3: 85 04                        dw      HP
  3777 00:19B5: 4B 05                        dw      STORE
  3778 00:19B7: E6 0E                        dw      EXIT
  3779                        
  3780                        ; HOLD ( char -- )
  3781                        
  3782                        ; Add char to the beginning of the pictured numeric output string. An
  3783                        ; ambiguous condition exists if HOLD executes outside of a <# #> delimited
  3784                        ; number conversion.
  3785                        ;
  3786                        ;       -1 HP +!  HP @ C!
  3787                        
  3788 00:19B9: AB 19 00 04                  HEADER  4,"HOLD",NORMAL
       00:19BD: 48 4F 4C 44 
  3789 00:19C1: 20 C1 14     HOLD:           jsr     DO_COLON
  3790 00:19C4: C7 16 FF FF                  dw      DO_LITERAL,-1
  3791 00:19C8: 85 04                        dw      HP
  3792 00:19CA: 61 05                        dw      PLUS_STORE
  3793 00:19CC: 85 04                        dw      HP
  3794 00:19CE: B9 05                        dw      FETCH
  3795 00:19D0: DB 05                        dw      C_STORE
  3796 00:19D2: E6 0E                        dw      EXIT
  3797                        
  3798                        ; PAD ( -- c-addr )
  3799                        ;
  3800                        ; c-addr is the address of a transient region that can be used to hold data
  3801                        ; for intermediate processing.
  3802                        
  3803 00:19D4: BC 19 00 03                  HEADER  3,"PAD",NORMAL
       00:19D8: 50 41 44 
  3804 00:19DB: 20 09 16     PAD:            jsr     DO_CONSTANT
  3805 00:19DE: B0 02                        dw      PAD_AREA
  3806                        
  3807                        ; SIGN ( n -- )
  3808                        ;
  3809                        ; If n is negative, add a minus sign to the beginning of the pictured numeric
  3810                        ; output string. An ambiguous condition exists if SIGN executes outside of a
  3811                        ; <# #> delimited number conversion.
  3812                        ;
  3813                        ;       [ HEX ] 0< IF 2D HOLD THEN
  3814                        
  3815 00:19E0: D7 19 00 04                  HEADER  4,"SIGN",NORMAL
       00:19E4: 53 49 47 4E 
  3816 00:19E8: 20 C1 14     SIGN:           jsr     DO_COLON
  3817 00:19EB: DD 0C                        dw      ZERO_LESS
  3818 00:19ED: 80 16 F7 19                  dw      QUERY_BRANCH,SIGN_1
  3819 00:19F1: C7 16 2D 00                  dw      DO_LITERAL,'-'
  3820 00:19F5: C1 19                        dw      HOLD
  3821 00:19F7: E6 0E        SIGN_1:         dw      EXIT
  3822                        
  Tue May  3 2016 22:26                                                                                                    Page 75


  3823                        ; U. ( u -- )
  3824                        ;
  3825                        ; Display u in free field format.
  3826                        ;
  3827                        ;  <# 0 #S #> TYPE SPACE
  3828                        
  3829 00:19F9: E3 19 00 02                  HEADER  2,"U.",NORMAL
       00:19FD: 55 2E 
  3830 00:19FF: 20 C1 14     U_DOT:          jsr     DO_COLON
  3831 00:1A02: AE 19                        dw      LESS_HASH
  3832 00:1A04: CE 04                        dw      ZERO
  3833 00:1A06: 79 19                        dw      HASH_S
  3834 00:1A08: 62 19                        dw      HASH_GREATER
  3835 00:1A0A: FF 18                        dw      TYPE
  3836 00:1A0C: CD 18                        dw      SPACE
  3837 00:1A0E: E6 0E                        dw      EXIT
  3838                        
  3839                        ;===============================================================================
  3840                        ; Programming Tools
  3841                        ;-------------------------------------------------------------------------------
  3842                        
  3843                        ; .NYBBLE ( n -- )
  3844                        ;
  3845                        ; Print the least significant nybble of the top value on the stack in hex.
  3846                        
  3847                        ;               HEADER  7,".NYBBLE",NORMAL
  3848                        DOT_NYBBLE:
  3849 00:1A10: A5 01                        lda     <1
  3850 00:1A12: 29 0F 00                     and     #$000f
  3851 00:1A15: 09 30 00                     ora     #$0030
  3852 00:1A18: C9 3A 00                     cmp     #$003a
  3853 00:1A1B: 90 03                        bcc     $+5
  3854 00:1A1D: 69 06 00                     adc     #$0006
  3855 00:1A20: 20 xx xx                     jsr     UartTx
  3856 00:1A23: 4C 74 07                     jmp     DROP
  3857                        
  3858                        ; .BYTE ( n -- )
  3859                        ;
  3860                        ; Print least significant byte of top value on the stack in hex followed by
  3861                        ; a space.
  3862                        
  3863 00:1A26: FC 19 00 05                  HEADER  5,".BYTE",NORMAL
       00:1A2A: 2E 42 59 54 
       00:1A2E: 45 
  3864 00:1A2F: 20 C1 14     DOT_BYTE:       jsr     DO_COLON
  3865 00:1A32: 85 07                        dw      DUP
  3866 00:1A34: C7 16 04 00                  dw      DO_LITERAL,4
  3867 00:1A38: 30 0E                        dw      RSHIFT
  3868 00:1A3A: 10 1A                        dw      DOT_NYBBLE
  3869 00:1A3C: 10 1A                        dw      DOT_NYBBLE
  3870 00:1A3E: CD 18                        dw      SPACE
  3871 00:1A40: E6 0E                        dw      EXIT
  3872                        
  3873                        ; .WORD ( n -- )
  3874                        ;
  3875                        ; Print the top value on the stack in hex followed by a space.
  3876                        
  3877 00:1A42: 29 1A 00 05                  HEADER  5,".WORD",NORMAL
  Tue May  3 2016 22:26                                                                                                    Page 76


       00:1A46: 2E 57 4F 52 
       00:1A4A: 44 
  3878 00:1A4B: 20 C1 14     DOT_WORD:       jsr     DO_COLON
  3879 00:1A4E: 85 07                        dw      DUP
  3880 00:1A50: C7 16 0C 00                  dw      DO_LITERAL,12
  3881 00:1A54: 30 0E                        dw      RSHIFT
  3882 00:1A56: 10 1A                        dw      DOT_NYBBLE
  3883 00:1A58: 85 07                        dw      DUP
  3884 00:1A5A: C7 16 08 00                  dw      DO_LITERAL,8
  3885 00:1A5E: 30 0E                        dw      RSHIFT
  3886 00:1A60: 10 1A                        dw      DOT_NYBBLE
  3887 00:1A62: 85 07                        dw      DUP
  3888 00:1A64: C7 16 04 00                  dw      DO_LITERAL,4
  3889 00:1A68: 30 0E                        dw      RSHIFT
  3890 00:1A6A: 10 1A                        dw      DOT_NYBBLE
  3891 00:1A6C: 10 1A                        dw      DOT_NYBBLE
  3892 00:1A6E: CD 18                        dw      SPACE
  3893 00:1A70: E6 0E                        dw      EXIT
  3894                        
  3895                        ; .DP
  3896                        
  3897 00:1A72: 45 1A 00 03                  HEADER  3,".DP",NORMAL
       00:1A76: 2E 44 50 
  3898 00:1A79: 20 C1 14                     jsr     DO_COLON
  3899 00:1A7C: DE 1A                        dw      AT_DP
  3900 00:1A7E: 4B 1A                        dw      DOT_WORD
  3901 00:1A80: E6 0E                        dw      EXIT
  3902                        
  3903 00:1A82: 75 1A 00 03                  HEADER  3,".RP",NORMAL
       00:1A86: 2E 52 50 
  3904 00:1A89: 20 C1 14                     jsr     DO_COLON
  3905 00:1A8C: F3 1A                        dw      AT_RP
  3906 00:1A8E: 4B 1A                        dw      DOT_WORD
  3907 00:1A90: E6 0E                        dw      EXIT
  3908                        
  3909                        ; .S ( -- )
  3910                        ;
  3911                        ; Copy and display the values currently on the data stack. The format of the
  3912                        ; display is implementation-dependent.
  3913                        
  3914 00:1A92: 85 1A 00 02                  HEADER  2,".S",NORMAL
       00:1A96: 2E 53 
  3915 00:1A98: 20 C1 14                     jsr     DO_COLON
  3916 00:1A9B: C7 16 7B 00  		dw	DO_LITERAL,'{'
  3917 00:1A9F: 9B 18        		dw	EMIT
  3918 00:1AA1: CD 18        		dw	SPACE
  3919 00:1AA3: DE 1A                        dw      AT_DP
  3920 00:1AA5: 70 09                        dw      ONE_PLUS
  3921 00:1AA7: C7 16 80 01                  dw      DO_LITERAL,DSTACK_END
  3922 00:1AAB: 0C 08                        dw      SWAP
  3923 00:1AAD: 11 15 BF 1A                  dw      QUERY_DO_DO,DOT_S_2
  3924 00:1AB1: 90 08        DOT_S_1:        dw      I
  3925 00:1AB3: B9 05                        dw      FETCH
  3926 00:1AB5: 4B 1A                        dw      DOT_WORD
  3927 00:1AB7: C7 16 02 00                  dw      DO_LITERAL,2
  3928 00:1ABB: 89 14                        dw      DO_PLUS_LOOP
  3929 00:1ABD: B1 1A                        dw      DOT_S_1
  3930 00:1ABF: C7 16 7D 00  DOT_S_2:	dw	DO_LITERAL,'}'
  Tue May  3 2016 22:26                                                                                                    Page 77


  3931 00:1AC3: 9B 18        		dw	EMIT
  3932 00:1AC5: CD 18        		dw	SPACE
  3933 00:1AC7: E6 0E                        dw      EXIT
  3934                        
  3935                        ; ? ( a-addr -- )
  3936                        ;
  3937                        ; Display the value stored at a-addr.
  3938                        
  3939 00:1AC9: 95 1A 00 01                  HEADER  1,"?",NORMAL
       00:1ACD: 3F 
  3940 00:1ACE: 20 C1 14                     jsr     DO_COLON
  3941 00:1AD1: B9 05                        dw      FETCH
  3942 00:1AD3: 4B 1A                        dw      DOT_WORD
  3943 00:1AD5: E6 0E                        dw      EXIT
  3944                        
  3945 00:1AD7: CC 1A 00 03                  HEADER  3,"@DP",NORMAL
       00:1ADB: 40 44 50 
  3946                        AT_DP:
  3947 00:1ADE: 0B                           phd
  3948 00:1ADF: 7B                           tdc
  3949 00:1AE0: 3A                           dec     a
  3950 00:1AE1: 3A                           dec     a
  3951 00:1AE2: 5B                           tcd
  3952 00:1AE3: 68                           pla
  3953 00:1AE4: 85 01                        sta     <1
  3954 00:1AE6: BB C8 C8 7C                  CONTINUE
       00:1AEA: 00 00 
  3955                        
  3956 00:1AEC: DA 1A 00 03                  HEADER  3,"@RP",NORMAL
       00:1AF0: 40 52 50 
  3957                        AT_RP:
  3958 00:1AF3: 7B                           tdc
  3959 00:1AF4: 3A                           dec     a
  3960 00:1AF5: 3A                           dec     a
  3961 00:1AF6: 5B                           tcd
  3962 00:1AF7: BA                           tsx
  3963 00:1AF8: 86 01                        stx     <1
  3964 00:1AFA: BB C8 C8 7C                  CONTINUE
       00:1AFE: 00 00 
  3965                        
  3966                        
  3967                        ;-------------------------------------------------------------------------------
  3968                        
  3969                                        include "device.asm"
     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _ ____   __  ____
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )___ \ / /_| ___|
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/  __) | '_ \___ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |    / __/| (_) |__) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|   |_____|\___/____/
     7                        ;
     8                        ; Device Specific Words for the W65C265SXB
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
  Tue May  3 2016 22:26                                                                                                    Page 78


    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ;------------------------------------------------------------------------------
    23                        
    24                        ; (TITLE) - ( -- )
    25                        ;
    26                        
    27                        ;               HEADER  7,"(TITLE)",NORMAL
    28 00:1B00: 20 C1 14     DO_TITLE:       jsr     DO_COLON
    29 00:1B03: 82 17                        dw      DO_S_QUOTE
    30 00:1B05: 1C 57 36 35                  db      28,"W65C265SXB ANS-Forth [16.05]"
       00:1B09: 43 32 36 35 
       00:1B0D: 53 58 42 20 
       00:1B11: 41 4E 53 2D 
       00:1B15: 46 6F 72 74 
       00:1B19: 68 20 5B 31 
       00:1B1D: 36 2E 30 35 
       00:1B21: 5D 
    31 00:1B22: E6 0E                        dw      EXIT
    32                        
    33                        ; BYE ( -- )
    34                        ;
    35                        ; Return control to the host operating system, if any.
    36                        
    37 00:1B24: EF 1A 00 03                  HEADER  3,"BYE",NORMAL
       00:1B28: 42 59 45 
    38                        BYE:
    39 00:1B2B: 78                           sei
    40 00:1B2C: D8                           cld
    41 00:1B2D: 38 FB                        emulate
    42 00:1B2F: 6C FC FF                     jmp     ($fffc)         ; Reset the processor
    43                        
    44                        ; UNUSED ( -- u )
    45                        ;
    46                        ; u is the amount of space remaining in the region addressed by HERE , in
    47                        ; address units.
    48                        
    49 00:1B32: 27 1B 00 06                  HEADER  6,"UNUSED",NORMAL
       00:1B36: 55 4E 55 53 
       00:1B3A: 45 44 
    50 00:1B3C: 20 C1 14     UNUSED:         jsr     DO_COLON
    51 00:1B3F: C7 16 00 80                  dw      DO_LITERAL,$8000
    52 00:1B43: 24 06                        dw      HERE
    53 00:1B45: 2E 09                        dw      MINUS
    54 00:1B47: E6 0E                        dw      EXIT
    55                        
    56                        
    57                        ;-------------------------------------------------------------------------------
    58                        
    59                        
  3970                        
  3971                                        TRAILER
  3972                        NEXT_WORD:
  Tue May  3 2016 22:26                                                                                                    Page 79


  3973                        
  3974                                        end


      Lines assembled: 5755
      Errors: 0
