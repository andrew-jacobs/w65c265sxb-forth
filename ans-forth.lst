  Wed Apr 20 2016 11:57                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;===============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;-------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The DP register is used for the Forth data stack is values can be accessed
    27                        ; using the direct-page addressing modes. The code uses the same offsets as
    28                        ; would be used with the stack relative instructions (i.e <1, <3, etc.).
    29                        ;
    30                        ; The Y register holds the forth instruction pointer leaving X free for general
    31                        ; use in words. Some words push Y if they need an extra register.
    32                        ;
    33                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    34                        ; CamelForth implementations.
    35                        ;
    36                        ;-------------------------------------------------------------------------------
    37                        
    38                                        pw      132
    39                                        inclist on
    40                                        maclist off
    41                        
    42                                        chip    65816
    43                                        longi   off
    44                                        longa   off
    45                        
    46                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
  Wed Apr 20 2016 11:57                                                                                                    Page 2


     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
  Wed Apr 20 2016 11:57                                                                                                    Page 3


    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    47                        
    48                        ;===============================================================================
    49                        ; Macros
    50                        ;-------------------------------------------------------------------------------
    51                        
    52                        ; The LINK macro deposits the link section of a word header automatically
    53                        ; linking the new word to the last.
    54                        
    55             00000000   WORDZ           set     0                       ; Word counter
    56             00000000   WORD0           equ     0                       ; Null address for first word
    57                        
    58                        LINK            macro   TYPE
  Wed Apr 20 2016 11:57                                                                                                    Page 4


    59                                        dw      WORD@<WORDZ>            ; Link
    60                                        db      TYPE                    ; Type
    61                        WORDZ           set     WORDZ+1
    62                        WORD@<WORDZ>:
    63                                        endm
    64                        
    65                        ; Deposits a word header containing the name which is linked back to the
    66                        ; previous word.
    67                        ;
    68                        ; The WDC assembler does not handle string parameters to macros very well,
    69                        ; stopping at the first comma or space in them, so some headers must be
    70                        ; manually constructed.
    71                        
    72             00000000   NORMAL          equ     $00
    73             00000080   IMMEDIATE       equ     $80
    74                        
    75                        HEADER          macro   LEN,NAME,TYPE
    76                                        LINK    TYPE
    77                                        db      LEN,NAME
    78                                        endm
    79                        
    80                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    81                        ; word pointer.
    82                        
    83                        CONTINUE        macro
    84                                        tyx                             ; Copy IP to X
    85                                        iny
    86                                        iny
    87                                        jmp     (0,x)                   ; Then execute word
    88                                        endm
    89                        
    90                        TRAILER         macro
    91                        LAST_WORD       equ     WORD@<WORDZ>
    92                                        endm
    93                        
    94                        ;===============================================================================
    95                        ; Definitions
    96                        ;-------------------------------------------------------------------------------
    97                        
    98             00000016   USER_SIZE       equ     22
    99             00000080   DSTACK_SIZE     equ     128
   100             00000080   RSTACK_SIZE     equ     128
   101                        
   102             00000000   TO_IN_OFFSET    equ     0
   103             00000002   BASE_OFFSET     equ     2
   104             00000004   BLK_OFFSET      equ     4
   105             00000006   DP_OFFSET       equ     6
   106             00000008   LATEST_OFFSET   equ     8
   107             0000000A   SCR_OFFSET      equ     10
   108             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   109             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   110             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   111             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   112             00000014   HP_OFFSET       equ     20
   113                        
   114             00000080   TIB_SIZE        equ     128
   115             00000030   PAD_SIZE        equ     48
   116                        
  Wed Apr 20 2016 11:57                                                                                                    Page 5


   117                        ;===============================================================================
   118                        ; Data Areas
   119                        ;-------------------------------------------------------------------------------
   120                        
   121                                        page0
   122                                        org     $00
   123                        
   124 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   125                        
   126                        
   127             00000100   DSTACK_START    equ     $0100
   128             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   129                        
   130             00000180   RSTACK_START    equ     $0180
   131             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   132                        
   133                        
   134                                        data
   135                                        org     $0200
   136                        
   137 00:0200:              TIB_AREA:       ds      TIB_SIZE                ; Terminal Input Buffer
   138 00:0280:                              ds      PAD_SIZE                ; Pad area
   139                        PAD_AREA:       ds      0
   140                        
   141                        ;===============================================================================
   142                        ; Forth Entry Point
   143                        ;-------------------------------------------------------------------------------
   144                        
   145                        FORTH           section OFFSET $0400
   146                        
   147                                        public  Start
   148                        Start:
   149 00:0400: 18 FB                        native                          ; Go to native mode
   150 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   151 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   152 00:0407: 1B                           tcs
   153 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   154 00:040B: 5B                           tcd
   155                        
   156 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   157 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   158                        
   159                        COLD:
   160 00:0415: 25 05                        dw      DECIMAL
   161 00:0417: CE 04                        dw      ZERO
   162 00:0419: 70 04                        dw      BLK
   163 00:041B: 4B 05                        dw      STORE
   164 00:041D: F8 04                        dw      FALSE
   165 00:041F: B8 04                        dw      STATE
   166 00:0421: 4B 05                        dw      STORE
   167 00:0423: 1B 16                        dw      DO_LITERAL
   168 00:0425: 7F 1A                        dw      NEXT_WORD
   169 00:0427: 80 04                        dw      DP
   170 00:0429: 4B 05                        dw      STORE
   171 00:042B: 1B 16                        dw      DO_LITERAL
   172 00:042D: 6B 1A                        dw      LAST_WORD
   173 00:042F: 94 04                        dw      LATEST
  Wed Apr 20 2016 11:57                                                                                                    Page 6


   174 00:0431: 4B 05                        dw      STORE
   175 00:0433: CA 17                        dw      CR
   176 00:0435: CA 17                        dw      CR
   177 00:0437: 36 1A                        dw      DO_TITLE
   178 00:0439: 47 18                        dw      TYPE
   179 00:043B: CA 17                        dw      CR
   180 00:043D: CA 17                        dw      CR
   181 00:043F: 5C 0E                        dw      ABORT
   182                        
   183                        ;===============================================================================
   184                        ; System/User Variables
   185                        ;-------------------------------------------------------------------------------
   186                        
   187                        ; #TIB ( -- a-addr )
   188                        ;
   189                        ; a-addr is the address of a cell containing the number of characters in the
   190                        ; terminal input buffer.
   191                        
   192 00:0441: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0445: 23 54 49 42 
   193 00:0449: 20 5F 15     HASH_TIB:       jsr     DO_CONSTANT
   194 00:044C: 4E 04                        dw      $+2
   195 00:044E: 7E 00                        dw      TIB_SIZE-2
   196                        
   197                        ; >IN ( -- a-addr )
   198                        ;
   199                        ; a-addr is the address of a cell containing the offset in characters from the
   200                        ; start of the input buffer to the start of the parse area.
   201                        
   202 00:0450: 44 04 00 03                  HEADER  3,">IN",NORMAL
       00:0454: 3E 49 4E 
   203 00:0457: 20 25 17     TO_IN:          jsr     DO_USER
   204 00:045A: 00 00                        dw      TO_IN_OFFSET
   205                        
   206                        ; BASE ( -- a-addr )
   207                        ;
   208                        ; a-addr is the address of a cell containing the current number-conversion
   209                        ; radix {{2...36}}.
   210                        
   211 00:045C: 53 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0460: 42 41 53 45 
   212 00:0464: 20 25 17     BASE:           jsr     DO_USER
   213 00:0467: 02 00                        dw      BASE_OFFSET
   214                        
   215                        ; BLK ( -- a-addr )
   216                        ;
   217                        ; a-addr is the address of a cell containing zero or the number of the mass-
   218                        ; storage block being interpreted. If BLK contains zero, the input source is
   219                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   220                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   221                        
   222 00:0469: 5F 04 00 03                  HEADER  3,"BLK",NORMAL
       00:046D: 42 4C 4B 
   223 00:0470: 20 25 17     BLK:            jsr     DO_USER
   224 00:0473: 04 00                        dw      BLK_OFFSET
   225                        
   226                        ; (BUFFER)
   227                        
  Wed Apr 20 2016 11:57                                                                                                    Page 7


   228                        ;               HEADER  8,"(BUFFER)",NORMAL
   229 00:0475: 20 25 17     BUFFER:         jsr     DO_USER
   230 00:0478: 10 00                        dw      BUFFER_OFFSET
   231                        
   232                        ; DP ( -- a-addr )
   233                        ;
   234                        ; Dictionary Pointer
   235                        
   236 00:047A: 6C 04 00 02                  HEADER  2,"DP",NORMAL
       00:047E: 44 50 
   237 00:0480: 20 25 17     DP:             jsr     DO_USER
   238 00:0483: 06 00                        dw      DP_OFFSET
   239                        
   240                        ; HP ( -- a-addr )
   241                        ;
   242                        ; Hold Pointer
   243                        
   244 00:0485: 20 25 17     HP:             jsr     DO_USER
   245 00:0488: 14 00                        dw      HP_OFFSET
   246                        
   247                        ; LATEST ( -- a-addr )
   248                        
   249 00:048A: 7D 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:048E: 4C 41 54 45 
       00:0492: 53 54 
   250 00:0494: 20 25 17     LATEST:         jsr     DO_USER
   251 00:0497: 08 00                        dw      LATEST_OFFSET
   252                        
   253                        ; (LENGTH)
   254                        
   255                        ;               HEADER  8,"(LENGTH)",NORMAL
   256 00:0499: 20 25 17     LENGTH:         jsr     DO_USER
   257 00:049C: 12 00                        dw      LENGTH_OFFSET
   258                        
   259                        ; SCR ( -- a-addr )
   260                        ;
   261                        ; a-addr is the address of a cell containing the block number of the block most
   262                        ; recently LISTed.
   263                        
   264 00:049E: 8D 04 00 03                  HEADER  3,"SCR",NORMAL
       00:04A2: 53 43 52 
   265 00:04A5: 20 25 17     SCR:            jsr     DO_USER
   266 00:04A8: 0A 00                        dw      SCR_OFFSET
   267                        
   268                        ; (SOURCE-ID)
   269                        
   270                        ;               HEADER  11,"(SOURCE-ID)",NORMAL
   271 00:04AA: 20 25 17     SOURCEID:       jsr     DO_USER
   272 00:04AD: 0C 00                        dw      SOURCEID_OFFSET
   273                        
   274                        ; STATE ( -- a-addr )
   275                        ;
   276                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   277                        ; is true when in compilation state, false otherwise. The true value in STATE
   278                        ; is non-zero, but is otherwise implementation-defined.
   279                        
   280 00:04AF: A1 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04B3: 53 54 41 54 
  Wed Apr 20 2016 11:57                                                                                                    Page 8


       00:04B7: 45 
   281 00:04B8: 20 25 17     STATE:          jsr     DO_USER
   282 00:04BB: 0E 00                        dw      STATE_OFFSET
   283                        
   284                        ; TIB ( -- c-addr )
   285                        ;
   286                        ; c-addr is the address of the terminal input buffer.
   287                        
   288 00:04BD: B2 04 00 03                  HEADER  3,"TIB",NORMAL
       00:04C1: 54 49 42 
   289 00:04C4: 20 5F 15     TIB:            jsr     DO_CONSTANT
   290 00:04C7: 00 02                        dw      TIB_AREA
   291                        
   292                        ;===============================================================================
   293                        ; Constants
   294                        ;-------------------------------------------------------------------------------
   295                        
   296                        ; 0 ( -- 0 )
   297                        ;
   298                        ; Push the constant value zero on the stack
   299                        
   300 00:04C9: C0 04 00 01                  HEADER  1,"0",NORMAL
       00:04CD: 30 
   301                        ZERO:
   302 00:04CE: 7B                           tdc
   303 00:04CF: 3A                           dec     a                       ; Make space on the stack
   304 00:04D0: 3A                           dec     a
   305 00:04D1: 5B                           tcd
   306 00:04D2: 64 01                        stz     <1                      ; And create a zero value
   307 00:04D4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04D8: 00 00 
   308                        
   309                        ; BL ( -- char )
   310                        ;
   311                        ; char is the character value for a space.
   312                        
   313 00:04DA: CC 04 00 02                  HEADER  2,"BL",NORMAL
       00:04DE: 42 4C 
   314                        BL:
   315 00:04E0: 7B                           tdc
   316 00:04E1: 3A                           dec     a                       ; Make space on the stack
   317 00:04E2: 3A                           dec     a
   318 00:04E3: 5B                           tcd
   319 00:04E4: A9 20 00                     lda     #' '                    ; And save a space value
   320 00:04E7: 85 01                        sta     <1
   321 00:04E9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04ED: 00 00 
   322                        
   323                        ; FALSE ( -- false )
   324                        ;
   325                        ; Return a false flag.
   326                        
   327 00:04EF: DD 04 00 05                  HEADER  5,"FALSE",NORMAL
       00:04F3: 46 41 4C 53 
       00:04F7: 45 
   328                        FALSE:
   329 00:04F8: 7B                           tdc
   330 00:04F9: 3A                           dec     a                       ; Make space on the stack
  Wed Apr 20 2016 11:57                                                                                                    Page 9


   331 00:04FA: 3A                           dec     a
   332 00:04FB: 5B                           tcd
   333 00:04FC: 64 01                        stz     <1                      ; And create a false value
   334 00:04FE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0502: 00 00 
   335                        
   336                        ; TRUE ( -- true )
   337                        ;
   338                        ; Return a true flag, a single-cell value with all bits set.
   339                        
   340 00:0504: F2 04 00 04                  HEADER  4,"TRUE",NORMAL
       00:0508: 54 52 55 45 
   341                        TRUE:
   342 00:050C: 7B                           tdc
   343 00:050D: 3A                           dec     a                       ; Make space on the stack
   344 00:050E: 3A                           dec     a
   345 00:050F: 5B                           tcd
   346 00:0510: 64 01                        stz     <1                      ; And create a true value
   347 00:0512: C6 01                        dec     <1
   348 00:0514: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0518: 00 00 
   349                        
   350                        ;===============================================================================
   351                        ; Radix
   352                        ;-------------------------------------------------------------------------------
   353                        
   354                        ; DECIMAL ( -- )
   355                        ;
   356                        ; Set the numeric conversion radix to ten (decimal).
   357                        
   358 00:051A: 07 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:051E: 44 45 43 49 
       00:0522: 4D 41 4C 
   359 00:0525: 20 45 14     DECIMAL:        jsr     DO_COLON
   360 00:0528: 1B 16 0A 00                  dw      DO_LITERAL,10
   361 00:052C: 64 04                        dw      BASE
   362 00:052E: 4B 05                        dw      STORE
   363 00:0530: BF 0E                        dw      EXIT
   364                        
   365                        ; HEX ( -- )
   366                        ;
   367                        ; Set contents of BASE to sixteen.
   368                        
   369 00:0532: 1D 05 00 03                  HEADER  3,"HEX",NORMAL
       00:0536: 48 45 58 
   370 00:0539: 20 45 14     HEX:            jsr     DO_COLON
   371 00:053C: 1B 16 10 00                  dw      DO_LITERAL,16
   372 00:0540: 64 04                        dw      BASE
   373 00:0542: 4B 05                        dw      STORE
   374 00:0544: BF 0E                        dw      EXIT
   375                        
   376                        ;===============================================================================
   377                        ; Memory Operations
   378                        ;-------------------------------------------------------------------------------
   379                        
   380                        ; ! ( x a-addr -- )
   381                        ;
   382                        ; Store x at a-addr.
  Wed Apr 20 2016 11:57                                                                                                    Page 10


   383                        
   384 00:0546: 35 05 00 01                  HEADER  1,"!",NORMAL
       00:054A: 21 
   385                        STORE:
   386 00:054B: A5 03                        lda     <3                      ; Fetch data value
   387 00:054D: 92 01                        sta     (1)                     ; .. and store
   388 00:054F: 7B                           tdc                             ; Clean up data stack
   389 00:0550: 1A                           inc     a
   390 00:0551: 1A                           inc     a
   391 00:0552: 1A                           inc     a
   392 00:0553: 1A                           inc     a
   393 00:0554: 5B                           tcd
   394 00:0555: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0559: 00 00 
   395                        
   396                        ; +! ( n|u a-addr -- )
   397                        ;
   398                        ; Add n|u to the single-cell number at a-addr.
   399                        
   400 00:055B: 49 05 00 02                  HEADER  2,"+!",NORMAL
       00:055F: 2B 21 
   401                        PLUS_STORE:
   402 00:0561: 18                           clc
   403 00:0562: A5 03                        lda     <3                      ; Fetch data value
   404 00:0564: 72 01                        adc     (1)
   405 00:0566: 92 01                        sta     (1)
   406 00:0568: 7B                           tdc                             ; Clean up data stack
   407 00:0569: 1A                           inc     a
   408 00:056A: 1A                           inc     a
   409 00:056B: 1A                           inc     a
   410 00:056C: 1A                           inc     a
   411 00:056D: 5B                           tcd
   412 00:056E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0572: 00 00 
   413                        
   414                        ; , ( x -- )
   415                        ;
   416                        ; Reserve one cell of data space and store x in the cell. If the data-space
   417                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   418                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   419                        ; is not aligned prior to execution of ,.
   420                        ;
   421                        ;   HERE ! 1 CELLS ALLOT
   422                        
   423 00:0574: 5E 05 00                     LINK    NORMAL
   424 00:0577: 01 2C                        db      1,","
   425 00:0579: 20 45 14     COMMA:          jsr     DO_COLON
   426 00:057C: 24 06                        dw      HERE
   427 00:057E: 4B 05                        dw      STORE
   428 00:0580: 1B 16 01 00                  dw      DO_LITERAL,1
   429 00:0584: 69 06                        dw      CELLS
   430 00:0586: CC 05                        dw      ALLOT
   431 00:0588: BF 0E                        dw      EXIT
   432                        
   433                        ; 2! ( x1 x2 a-addr -- )
   434                        ;
   435                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   436                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
  Wed Apr 20 2016 11:57                                                                                                    Page 11


   437                        
   438 00:058A: 77 05 00 02                  HEADER  2,"2!",NORMAL
       00:058E: 32 21 
   439 00:0590: 20 45 14     TWO_STORE:      jsr     DO_COLON
   440 00:0593: FB 07                        dw      SWAP
   441 00:0595: A8 07                        dw      OVER
   442 00:0597: 4B 05                        dw      STORE
   443 00:0599: 56 06                        dw      CELL_PLUS
   444 00:059B: 4B 05                        dw      STORE
   445 00:059D: BF 0E                        dw      EXIT
   446                        
   447                        ; 2@ ( a-addr -- x1 x2 )
   448                        ;
   449                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   450                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   451                        ; @.
   452                        
   453 00:059F: 8D 05 00 02                  HEADER  2,"2@",NORMAL
       00:05A3: 32 40 
   454 00:05A5: 20 45 14     TWO_FETCH:      jsr     DO_COLON
   455 00:05A8: 85 07                        dw      DUP
   456 00:05AA: 56 06                        dw      CELL_PLUS
   457 00:05AC: B9 05                        dw      FETCH
   458 00:05AE: FB 07                        dw      SWAP
   459 00:05B0: B9 05                        dw      FETCH
   460 00:05B2: BF 0E                        dw      EXIT
   461                        
   462                        ; @ ( a-addr -- x )
   463                        ;
   464                        ; x is the value stored at a-addr.
   465                        
   466 00:05B4: A2 05 00 01                  HEADER  1,"@",NORMAL
       00:05B8: 40 
   467                        FETCH:
   468 00:05B9: B2 01                        lda     (1)                     ; Fetch from memory
   469 00:05BB: 85 01                        sta     <1                      ; .. and replace top value
   470 00:05BD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05C1: 00 00 
   471                        
   472                        ; ALLOT ( n -- )
   473                        ;
   474                        ; If n is greater than zero, reserve n address units of data space. If n is
   475                        ; less than zero, release |n| address units of data space. If n is zero, leave
   476                        ; the data-space pointer unchanged.
   477                        ;
   478                        ; In this implementation its is defined as:
   479                        ;
   480                        ;   DP +!
   481                        
   482 00:05C3: B7 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:05C7: 41 4C 4C 4F 
       00:05CB: 54 
   483 00:05CC: 20 45 14     ALLOT:          jsr     DO_COLON
   484 00:05CF: 80 04                        dw      DP
   485 00:05D1: 61 05                        dw      PLUS_STORE
   486 00:05D3: BF 0E                        dw      EXIT
   487                        
   488                        ; C! ( char c-addr -- )
  Wed Apr 20 2016 11:57                                                                                                    Page 12


   489                        ;
   490                        ; Store char at c-addr. When character size is smaller than cell size, only the
   491                        ; number of low-order bits corresponding to character size are transferred.
   492                        
   493 00:05D5: C6 05 00 02                  HEADER  2,"C!",NORMAL
       00:05D9: 43 21 
   494                        C_STORE:
   495 00:05DB: A5 03                        lda     <3                      ; Fetch the data value
   496 00:05DD: E2 20                        short_a
   497 00:05DF: 92 01                        sta     (1)                     ; And store it
   498 00:05E1: C2 20                        long_a
   499 00:05E3: 7B                           tdc                             ; Clean up the stack
   500 00:05E4: 1A                           inc     a
   501 00:05E5: 1A                           inc     a
   502 00:05E6: 1A                           inc     a
   503 00:05E7: 1A                           inc     a
   504 00:05E8: 5B                           tcd
   505 00:05E9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05ED: 00 00 
   506                        
   507                        ; C, ( char -- )
   508                        ;
   509                        ; Reserve space for one character in the data space and store char in the
   510                        ; space. If the data-space pointer is character aligned when C, begins
   511                        ; execution, it will remain character aligned when C, finishes execution.
   512                        ; An ambiguous condition exists if the data-space pointer is not character-
   513                        ; aligned prior to execution of C,
   514                        ;
   515                        ;   HERE C! 1 CHARS ALLOT
   516                        
   517 00:05EF: D8 05 00                     LINK    NORMAL
   518 00:05F2: 02 43 2C                     db      2,"C,"
   519 00:05F5: 20 45 14     C_COMMA:        jsr     DO_COLON
   520 00:05F8: 24 06                        dw      HERE
   521 00:05FA: DB 05                        dw      C_STORE
   522 00:05FC: 1B 16 01 00                  dw      DO_LITERAL,1
   523 00:0600: 9C 06                        dw      CHARS
   524 00:0602: CC 05                        dw      ALLOT
   525 00:0604: BF 0E                        dw      EXIT
   526                        
   527                        ; C@ ( c-addr -- char )
   528                        ;
   529                        ; Fetch the character stored at c-addr. When the cell size is greater than
   530                        ; character size, the unused high-order bits are all zeroes.
   531                        
   532 00:0606: F2 05 00 02                  HEADER  2,"C@",NORMAL
       00:060A: 43 40 
   533                        C_FETCH:
   534 00:060C: E2 20                        short_a
   535 00:060E: B2 01                        lda     (1)                     ; Fetch the data byte
   536 00:0610: 85 01                        sta     <1                      ; .. and replace stack value
   537 00:0612: 64 02                        stz     <2
   538 00:0614: C2 20                        long_a
   539 00:0616: BB C8 C8 7C                  CONTINUE                        ; Done
       00:061A: 00 00 
   540                        
   541                        ; HERE ( -- addr )
   542                        ;
  Wed Apr 20 2016 11:57                                                                                                    Page 13


   543                        ; addr is the data-space pointer.
   544                        
   545 00:061C: 09 06 00 04                  HEADER  4,"HERE",NORMAL
       00:0620: 48 45 52 45 
   546 00:0624: 20 45 14     HERE:           jsr     DO_COLON
   547 00:0627: 80 04                        dw      DP
   548 00:0629: B9 05                        dw      FETCH
   549 00:062B: BF 0E                        dw      EXIT
   550                        
   551                        ;===============================================================================
   552                        ; Alignment
   553                        ;-------------------------------------------------------------------------------
   554                        
   555                        ; ALIGN ( -- )
   556                        ;
   557                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   558                        
   559 00:062D: 1F 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:0631: 41 4C 49 47 
       00:0635: 4E 
   560                        ALIGN:
   561 00:0636: BB C8 C8 7C                  CONTINUE                        ; Done
       00:063A: 00 00 
   562                        
   563                        ; ALIGNED ( addr -- a-addr )
   564                        ;
   565                        ; a-addr is the first aligned address greater than or equal to addr.
   566                        
   567 00:063C: 30 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:0640: 41 4C 49 47 
       00:0644: 4E 45 44 
   568                        ALIGNED:
   569 00:0647: BB C8 C8 7C                  CONTINUE                        ; Done
       00:064B: 00 00 
   570                        
   571                        ; CELL+ ( a-addr1 -- a-addr2 )
   572                        ;
   573                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   574                        
   575 00:064D: 3F 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:0651: 43 45 4C 4C 
       00:0655: 2B 
   576                        CELL_PLUS:
   577 00:0656: E6 01                        inc     <1                      ; Bump the address by two
   578 00:0658: E6 01                        inc     <1
   579 00:065A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:065E: 00 00 
   580                        
   581                        ; CELLS ( n1 -- n2 )
   582                        ;
   583                        ; n2 is the size in address units of n1 cells.
   584                        
   585 00:0660: 50 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:0664: 43 45 4C 4C 
       00:0668: 53 
   586                        CELLS:
   587 00:0669: 06 01                        asl     <1                      ; Two bytes per cell
   588 00:066B: BB C8 C8 7C                  CONTINUE                        ; Done
  Wed Apr 20 2016 11:57                                                                                                    Page 14


       00:066F: 00 00 
   589                        
   590                        ; CHAR+ ( c-addr1 -- c-addr2 )
   591                        ;
   592                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   593                        
   594 00:0671: 63 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0675: 43 48 41 52 
       00:0679: 2B 
   595                        CHAR_PLUS:
   596 00:067A: E6 01                        inc     <1                      ; Bump the address by one
   597 00:067C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0680: 00 00 
   598                        
   599                        ; CHAR- ( c-addr1 -- c-addr2 )
   600                        ;
   601                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   602                        
   603 00:0682: 74 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:0686: 43 48 41 52 
       00:068A: 2D 
   604                        CHAR_MINUS:
   605 00:068B: C6 01                        dec     <1
   606 00:068D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0691: 00 00 
   607                        
   608                        ; CHARS ( n1 -- n2 )
   609                        ;
   610                        ; n2 is the size in address units of n1 characters.
   611                        
   612 00:0693: 85 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:0697: 43 48 41 52 
       00:069B: 53 
   613                        CHARS:
   614 00:069C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06A0: 00 00 
   615                        
   616                        ;===============================================================================
   617                        ; Stack Operations
   618                        ;-------------------------------------------------------------------------------
   619                        
   620                        ; 2DROP ( x1 x2 -- )
   621                        ;
   622                        ; Drop cell pair x1 x2 from the stack.
   623                        
   624 00:06A2: 96 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06A6: 32 44 52 4F 
       00:06AA: 50 
   625                        TWO_DROP:
   626 00:06AB: 7B                           tdc                             ; Removed two words from stack
   627 00:06AC: 1A                           inc     a
   628 00:06AD: 1A                           inc     a
   629 00:06AE: 1A                           inc     a
   630 00:06AF: 1A                           inc     a
   631 00:06B0: 5B                           tcd
   632 00:06B1: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B5: 00 00 
   633                        
  Wed Apr 20 2016 11:57                                                                                                    Page 15


   634                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   635                        ;
   636                        ; Duplicate cell pair x1 x2.
   637                        
   638 00:06B7: A5 06 00 04                  HEADER  4,"2DUP",NORMAL
       00:06BB: 32 44 55 50 
   639                        TWO_DUP:
   640 00:06BF: 7B                           tdc                             ; Make space for new value
   641 00:06C0: 3A                           dec     a
   642 00:06C1: 3A                           dec     a
   643 00:06C2: 3A                           dec     a
   644 00:06C3: 3A                           dec     a
   645 00:06C4: 5B                           tcd
   646 00:06C5: A5 05                        lda     <5                      ; Copy top two values
   647 00:06C7: 85 01                        sta     <1
   648 00:06C9: A5 07                        lda     <7
   649 00:06CB: 85 03                        sta     <3
   650 00:06CD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06D1: 00 00 
   651                        
   652                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   653                        ;
   654                        ; Copy cell pair x1 x2 to the top of the stack.
   655                        
   656 00:06D3: BA 06 00 05                  HEADER  5,"2OVER",NORMAL
       00:06D7: 32 4F 56 45 
       00:06DB: 52 
   657                        TWO_OVER:
   658 00:06DC: 7B                           tdc                             ; Make space for new value
   659 00:06DD: 3A                           dec     a
   660 00:06DE: 3A                           dec     a
   661 00:06DF: 3A                           dec     a
   662 00:06E0: 3A                           dec     a
   663 00:06E1: 5B                           tcd
   664 00:06E2: A5 09                        lda     <9                      ; Ciopy top two values
   665 00:06E4: 85 01                        sta     <1
   666 00:06E6: A5 0B                        lda     <11
   667 00:06E8: 85 03                        sta     <3
   668 00:06EA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06EE: 00 00 
   669                        
   670                        ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
   671                        ;
   672                        ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
   673                        ; the top of the stack.
   674                        
   675 00:06F0: D6 06 00 04                  HEADER  4,"2ROT",NORMAL
       00:06F4: 32 52 4F 54 
   676 00:06F8: 20 45 14     TWO_ROT:        jsr     DO_COLON
   677 00:06FB: A5 0B                        lda     <11                     ; Save x1
   678 00:06FD: 48                           pha
   679 00:06FE: A5 09                        lda     <9                      ; Save x2
   680 00:0700: 48                           pha
   681 00:0701: A5 07                        lda     <7                      ; Move x3
   682 00:0703: 85 0B                        sta     <11
   683 00:0705: A5 05                        lda     <5                      ; Move x4
   684 00:0707: 85 09                        sta     <9
   685 00:0709: A5 03                        lda     <3                      ; Move x5
  Wed Apr 20 2016 11:57                                                                                                    Page 16


   686 00:070B: 85 07                        sta     <7
   687 00:070D: A5 01                        lda     <1                      ; Move x6
   688 00:070F: 85 05                        sta     <5
   689 00:0711: 68                           pla                             ; Restore x2
   690 00:0712: 85 01                        sta     <1
   691 00:0714: 68                           pla                             ; Restore x1
   692 00:0715: 85 03                        sta     <3
   693 00:0717: BB C8 C8 7C                  CONTINUE                        ; Done
       00:071B: 00 00 
   694                        
   695                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   696                        ;
   697                        ; Exchange the top two cell pairs.
   698                        
   699 00:071D: F3 06 00 05                  HEADER  5,"2SWAP",NORMAL
       00:0721: 32 53 57 41 
       00:0725: 50 
   700                        TWO_SWAP:
   701 00:0726: A5 03                        lda     <3                      ; Save x3
   702 00:0728: 48                           pha
   703 00:0729: A5 01                        lda     <1                      ; Save x4
   704 00:072B: 48                           pha
   705 00:072C: A5 07                        lda     <7                      ; Move x1
   706 00:072E: 85 03                        sta     <3
   707 00:0730: A5 05                        lda     <5                      ; Move x2
   708 00:0732: 85 01                        sta     <1
   709 00:0734: 68                           pla                             ; Move x4
   710 00:0735: 85 05                        sta     <5
   711 00:0737: 68                           pla                             ; Move x3
   712 00:0738: 85 07                        sta     <7
   713 00:073A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:073E: 00 00 
   714                        
   715                        ; ?DUP ( x -- 0 | x x )
   716                        ;
   717                        ; Duplicate x if it is non-zero.
   718                        
   719 00:0740: 20 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:0744: 3F 44 55 50 
   720                        QUERY_DUP:
   721 00:0748: A5 01                        lda     <1                      ; Fetch top value
   722 00:074A: D0 39                        bne     DUP                     ; Non-zero value?
   723 00:074C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0750: 00 00 
   724                        
   725                        ; DEPTH ( -- n )
   726                        
   727 00:0752: 43 07 00 05                  HEADER  5,"DEPTH",NORMAL
       00:0756: 44 45 50 54 
       00:075A: 48 
   728 00:075B: 20 45 14     DEPTH:          jsr     DO_COLON
   729 00:075E: 14 1A                        dw      AT_DP
   730 00:0760: 1B 16 7F 01                  dw      DO_LITERAL,DSTACK_END-1
   731 00:0764: FB 07                        dw      SWAP
   732 00:0766: 15 09                        dw      MINUS
   733 00:0768: 79 09                        dw      TWO_SLASH
   734 00:076A: BF 0E                        dw      EXIT
   735                        
  Wed Apr 20 2016 11:57                                                                                                    Page 17


   736                        ; DROP ( x -- )
   737                        ;
   738                        ; Remove x from the stack.
   739                        
   740 00:076C: 55 07 00 04                  HEADER  4,"DROP",NORMAL
       00:0770: 44 52 4F 50 
   741                        DROP:
   742 00:0774: 7B                           tdc                             ; Drop the top value
   743 00:0775: 1A                           inc     a
   744 00:0776: 1A                           inc     a
   745 00:0777: 5B                           tcd
   746 00:0778: BB C8 C8 7C                  CONTINUE                        ; Done
       00:077C: 00 00 
   747                        
   748                        ; DUP ( x -- x x )
   749                        ;
   750                        ; Duplicate x.
   751                        
   752 00:077E: 6F 07 00 03                  HEADER  3,"DUP",NORMAL
       00:0782: 44 55 50 
   753                        DUP:
   754 00:0785: 7B                           tdc
   755 00:0786: 3A                           dec     a
   756 00:0787: 3A                           dec     a
   757 00:0788: 5B                           tcd
   758 00:0789: A5 03                        lda     <3                      ; Fetch top value
   759 00:078B: 85 01                        sta     <1                      ; And make a copy
   760 00:078D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0791: 00 00 
   761                        
   762                        ; NIP ( x1 x2 -- x2 )
   763                        ;
   764                        ; Drop the first item below the top of stack.
   765                        
   766 00:0793: 81 07 00 03                  HEADER  3,"NIP",NORMAL
       00:0797: 4E 49 50 
   767                        NIP:
   768 00:079A: A5 01                        lda     <1                      ; Copy x2 over x1
   769 00:079C: 85 03                        sta     <3
   770 00:079E: 80 D4                        bra     DROP
   771                        
   772                        ; OVER ( x1 x2 -- x1 x2 x1 )
   773                        ;
   774                        ; Place a copy of x1 on top of the stack.
   775                        
   776 00:07A0: 96 07 00 04                  HEADER  4,"OVER",NORMAL
       00:07A4: 4F 56 45 52 
   777                        OVER:
   778 00:07A8: 7B                           tdc
   779 00:07A9: 3A                           dec     a
   780 00:07AA: 3A                           dec     a
   781 00:07AB: 5B                           tcd
   782 00:07AC: A5 05                        lda     <5                      ; Fetch second value
   783 00:07AE: 85 01                        sta     <1                      ; And make a copy
   784 00:07B0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07B4: 00 00 
   785                        
   786                        ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
  Wed Apr 20 2016 11:57                                                                                                    Page 18


   787                        ;
   788                        ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
   789                        ; if there are less than u+2 items on the stack before PICK is executed.
   790                        
   791 00:07B6: A3 07 00 04                  HEADER  4,"PICK",NORMAL
       00:07BA: 50 49 43 4B 
   792                        PICK:
   793 00:07BE: A5 01                        lda     <1                      ; Fetch the index
   794 00:07C0: 0A                           asl     a
   795 00:07C1: AA                           tax
   796 00:07C2: B5 03                        lda     <3,x                    ; Load the target value
   797 00:07C4: 85 01                        sta     <1                      ; .. and save
   798 00:07C6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07CA: 00 00 
   799                        
   800                        ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   801                        ;
   802                        ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
   803                        ; exists if there are less than u+2 items on the stack before ROLL is executed.
   804                        
   805                        ; TODO
   806                        
   807 00:07CC: B9 07 00 04                  HEADER  4,"ROLL",NORMAL
       00:07D0: 52 4F 4C 4C 
   808                        ROLL:
   809 00:07D4: BB C8 C8 7C                  CONTINUE
       00:07D8: 00 00 
   810                        
   811                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   812                        ;
   813                        ; Rotate the top three stack entries.
   814                        
   815 00:07DA: CF 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07DE: 52 4F 54 
   816                        ROT:
   817 00:07E1: A6 05                        ldx     <5                      ; Save x1
   818 00:07E3: A5 03                        lda     <3                      ; Move x2
   819 00:07E5: 85 05                        sta     <5
   820 00:07E7: A5 01                        lda     <1                      ; Move x3
   821 00:07E9: 85 03                        sta     <3
   822 00:07EB: 86 01                        stx     <1                      ; Restore x1
   823 00:07ED: BB C8 C8 7C                  CONTINUE
       00:07F1: 00 00 
   824                        
   825                        ; SWAP ( x1 x2 -- x2 x1 )
   826                        ;
   827                        ; Exchange the top two stack items.
   828                        
   829 00:07F3: DD 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:07F7: 53 57 41 50 
   830                        SWAP:
   831 00:07FB: A5 01                        lda     <1                      ; Switch top two words
   832 00:07FD: A6 03                        ldx     <3
   833 00:07FF: 85 03                        sta     <3
   834 00:0801: 86 01                        stx     <1
   835 00:0803: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0807: 00 00 
   836                        
  Wed Apr 20 2016 11:57                                                                                                    Page 19


   837                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   838                        ;
   839                        ; Copy the first (top) stack item below the second stack item.
   840                        
   841 00:0809: F6 07 00 04                  HEADER  4,"TUCK",NORMAL
       00:080D: 54 55 43 4B 
   842 00:0811: 20 45 14     TUCK:           jsr     DO_COLON
   843 00:0814: FB 07                        dw      SWAP
   844 00:0816: A8 07                        dw      OVER
   845 00:0818: BF 0E                        dw      EXIT
   846                        
   847                        ;===============================================================================
   848                        ; Return Stack Operations
   849                        ;-------------------------------------------------------------------------------
   850                        
   851                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   852                        ;
   853                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   854                        ; SWAP >R >R.
   855                        
   856 00:081A: 0C 08 00 03                  HEADER  3,"2>R",NORMAL
       00:081E: 32 3E 52 
   857                        TWO_TO_R:
   858 00:0821: A5 03                        lda     <3                      ; Transfer x1
   859 00:0823: 48                           pha
   860 00:0824: A5 01                        lda     <1                      ; Transfer x2
   861 00:0826: 48                           pha
   862 00:0827: 7B                           tdc
   863 00:0828: 1A                           inc     a                       ; Clean up data stack
   864 00:0829: 1A                           inc     a
   865 00:082A: 1A                           inc     a
   866 00:082B: 1A                           inc     a
   867 00:082C: 5B                           tcd
   868 00:082D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0831: 00 00 
   869                        
   870                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   871                        ;
   872                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   873                        ; R> SWAP.
   874                        
   875 00:0833: 1D 08 00 03                  HEADER  3,"2R>",NORMAL
       00:0837: 32 52 3E 
   876                        TWO_R_FROM:
   877 00:083A: 7B                           tdc
   878 00:083B: 3A                           dec     a                       ; Make space for values
   879 00:083C: 3A                           dec     a
   880 00:083D: 3A                           dec     a
   881 00:083E: 3A                           dec     a
   882 00:083F: 5B                           tcd
   883 00:0840: 68                           pla                             ; Transfer x2
   884 00:0841: 85 01                        sta     <1
   885 00:0843: 68                           pla                             ; Transfer x1
   886 00:0844: 85 03                        sta     <3
   887 00:0846: BB C8 C8 7C                  CONTINUE                        ; Done
       00:084A: 00 00 
   888                        
   889                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
  Wed Apr 20 2016 11:57                                                                                                    Page 20


   890                        ;
   891                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   892                        ; 2DUP >R >R SWAP.
   893                        
   894 00:084C: 36 08 00 03                  HEADER  3,"2R@",NORMAL
       00:0850: 32 52 40 
   895                        TWO_R_FETCH:
   896 00:0853: 7B                           tdc
   897 00:0854: 3A                           dec     a                       ; Make space for values
   898 00:0855: 3A                           dec     a
   899 00:0856: 3A                           dec     a
   900 00:0857: 3A                           dec     a
   901 00:0858: 5B                           tcd
   902 00:0859: A3 01                        lda     1,s                     ; Transfer x2
   903 00:085B: 85 01                        sta     <1
   904 00:085D: A3 03                        lda     3,s                     ; Transfer x1
   905 00:085F: 85 03                        sta     <3
   906 00:0861: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0865: 00 00 
   907                        
   908                        ; >R ( x -- ) ( R: -- x )
   909                        ;
   910                        ; Move x to the return stack.
   911                        
   912 00:0867: 4F 08 00 02                  HEADER  2,">R",NORMAL
       00:086B: 3E 52 
   913                        TO_R:
   914 00:086D: A5 01                        lda     <1                      ; Transfer top value
   915 00:086F: 48                           pha                             ; .. to return stack
   916 00:0870: 7B                           tdc
   917 00:0871: 1A                           inc     a
   918 00:0872: 1A                           inc     a
   919 00:0873: 5B                           tcd
   920 00:0874: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0878: 00 00 
   921                        
   922                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   923                        ;
   924                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   925                        ; exists if the loop control parameters are unavailable.
   926                        
   927 00:087A: 6A 08 00 01                  HEADER  1,"I",NORMAL
       00:087E: 49 
   928                        I:
   929 00:087F: 7B                           tdc
   930 00:0880: 3A                           dec     a
   931 00:0881: 3A                           dec     a
   932 00:0882: 5B                           tcd
   933 00:0883: A3 01                        lda     1,s
   934 00:0885: 85 01                        sta     <1
   935 00:0887: BB C8 C8 7C                  CONTINUE
       00:088B: 00 00 
   936                        
   937                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   938                        ;
   939                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   940                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   941                        ; unavailable.
  Wed Apr 20 2016 11:57                                                                                                    Page 21


   942                        
   943 00:088D: 7D 08 00 01                  HEADER  1,"J",NORMAL
       00:0891: 4A 
   944                        J:
   945 00:0892: 7B                           tdc
   946 00:0893: 3A                           dec     a
   947 00:0894: 3A                           dec     a
   948 00:0895: 5B                           tcd
   949 00:0896: A3 05                        lda     5,s
   950 00:0898: 85 01                        sta     <1
   951 00:089A: BB C8 C8 7C                  CONTINUE
       00:089E: 00 00 
   952                        
   953                        ; R> ( -- x ) ( R: x -- )
   954                        ;
   955                        ; Move x from the return stack to the data stack.
   956                        
   957 00:08A0: 90 08 00 02                  HEADER  2,"R>",NORMAL
       00:08A4: 52 3E 
   958                        R_FROM:
   959 00:08A6: 7B                           tdc
   960 00:08A7: 3A                           dec     a
   961 00:08A8: 3A                           dec     a
   962 00:08A9: 5B                           tcd
   963 00:08AA: 68                           pla                             ; Fetch return stack value
   964 00:08AB: 85 01                        sta     <1
   965 00:08AD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08B1: 00 00 
   966                        
   967                        ; R@ ( -- x ) ( R: x -- x )
   968                        ;
   969                        ; Copy x from the return stack to the data stack.
   970                        
   971 00:08B3: A3 08 00 02                  HEADER  2,"R@",NORMAL
       00:08B7: 52 40 
   972                        R_FETCH:
   973 00:08B9: 7B                           tdc
   974 00:08BA: 3A                           dec     a
   975 00:08BB: 3A                           dec     a
   976 00:08BC: 5B                           tcd
   977 00:08BD: A3 01                        lda     1,s
   978 00:08BF: 85 01                        sta     <1
   979 00:08C1: BB C8 C8 7C                  CONTINUE
       00:08C5: 00 00 
   980                        
   981                        ;===============================================================================
   982                        ; Single Precision Arithmetic
   983                        ;-------------------------------------------------------------------------------
   984                        
   985                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   986                        ;
   987                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   988                        ;
   989                        ;       M* DROP
   990                        
   991 00:08C7: B6 08 00 01                  HEADER  1,"*",NORMAL
       00:08CB: 2A 
   992 00:08CC: 20 45 14     STAR:           jsr     DO_COLON
  Wed Apr 20 2016 11:57                                                                                                    Page 22


   993 00:08CF: B4 0B                        dw      M_STAR
   994 00:08D1: 74 07                        dw      DROP
   995 00:08D3: BF 0E                        dw      EXIT
   996                        
   997                        ; */
   998                        ;
   999                        ;       */MOD NIP
  1000                        
  1001 00:08D5: CA 08 00 02                  HEADER  2,"*/",NORMAL
       00:08D9: 2A 2F 
  1002 00:08DB: 20 45 14     STAR_SLASH:     jsr     DO_COLON
  1003 00:08DE: ED 08                        dw      STAR_SLASH_MOD
  1004 00:08E0: 9A 07                        dw      NIP
  1005 00:08E2: BF 0E                        dw      EXIT
  1006                        
  1007                        ; */MOD
  1008                        ;
  1009                        ;       >R M* R> FM/MOD
  1010                        
  1011 00:08E4: D8 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:08E8: 2A 2F 4D 4F 
       00:08EC: 44 
  1012 00:08ED: 20 45 14     STAR_SLASH_MOD: jsr     DO_COLON
  1013 00:08F0: 6D 08                        dw      TO_R
  1014 00:08F2: B4 0B                        dw      M_STAR
  1015 00:08F4: A6 08                        dw      R_FROM
  1016 00:08F6: AF 09                        dw      FM_SLASH_MOD
  1017 00:08F8: BF 0E                        dw      EXIT
  1018                        
  1019                        ; + ( n1|u1 n2|u2 -- n3|u3 )
  1020                        ;
  1021                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
  1022                        
  1023 00:08FA: E7 08 00 01                  HEADER  1,"+",NORMAL
       00:08FE: 2B 
  1024                        PLUS:
  1025 00:08FF: 18                           clc                             ; Add top two values
  1026 00:0900: A5 03                        lda     <3
  1027 00:0902: 65 01                        adc     <1
  1028 00:0904: 85 03                        sta     <3                      ; Save result
  1029 00:0906: 7B                           tdc
  1030 00:0907: 1A                           inc     a                       ; Clean up data stack
  1031 00:0908: 1A                           inc     a
  1032 00:0909: 5B                           tcd
  1033 00:090A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:090E: 00 00 
  1034                        
  1035                        ; - ( n1|u1 n2|u2 -- n3|u3 )
  1036                        ;
  1037                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
  1038                        
  1039 00:0910: FD 08 00 01                  HEADER  1,"-",NORMAL
       00:0914: 2D 
  1040                        MINUS:
  1041 00:0915: 38                           sec                             ; Subtract top two values
  1042 00:0916: A5 03                        lda     <3
  1043 00:0918: E5 01                        sbc     <1
  1044 00:091A: 85 03                        sta     <3                      ; Save result
  Wed Apr 20 2016 11:57                                                                                                    Page 23


  1045 00:091C: 7B                           tdc
  1046 00:091D: 1A                           inc     a                       ; Clean up data stack
  1047 00:091E: 1A                           inc     a
  1048 00:091F: 5B                           tcd
  1049 00:0920: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0924: 00 00 
  1050                        
  1051                        ; /
  1052                        ;
  1053                        ;       /MOD NIP
  1054                        
  1055 00:0926: 13 09 00 01                  HEADER  1,"/",NORMAL
       00:092A: 2F 
  1056 00:092B: 20 45 14     SLASH:          jsr     DO_COLON
  1057 00:092E: 3C 09                        dw      SLASH_MOD
  1058 00:0930: 9A 07                        dw      NIP
  1059 00:0932: BF 0E                        dw      EXIT
  1060                        
  1061                        ; /MOD
  1062                        ;
  1063                        ;       >R S>D R> FM/MOD
  1064                        
  1065 00:0934: 29 09 00 04                  HEADER  4,"/MOD",NORMAL
       00:0938: 2F 4D 4F 44 
  1066 00:093C: 20 45 14     SLASH_MOD:      jsr     DO_COLON
  1067 00:093F: 6D 08                        dw      TO_R
  1068 00:0941: EF 0B                        dw      S_TO_D
  1069 00:0943: A6 08                        dw      R_FROM
  1070 00:0945: AF 09                        dw      FM_SLASH_MOD
  1071 00:0947: BF 0E                        dw      EXIT
  1072                        
  1073                        ; 1+ ( n1|u1 -- n2|u2 )
  1074                        ;
  1075                        ; Add one (1) to n1|u1 giving the sum n2|u2.
  1076                        
  1077 00:0949: 37 09 00 02                  HEADER  2,"1+",NORMAL
       00:094D: 31 2B 
  1078                        ONE_PLUS:
  1079 00:094F: E6 01                        inc     <1                      ; Increment top of stack
  1080 00:0951: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0955: 00 00 
  1081                        
  1082                        ; 1- ( n1|u1 -- n2|u2 )
  1083                        ;
  1084                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
  1085                        
  1086 00:0957: 4C 09 00 02                  HEADER  2,"1-",NORMAL
       00:095B: 31 2D 
  1087                        ONE_MINUS:
  1088 00:095D: C6 01                        dec     <1                      ; Decrement top of stack
  1089 00:095F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0963: 00 00 
  1090                        
  1091                        ; 2* ( x1 -- x2 )
  1092                        ;
  1093                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1094                        ; filling the vacated least-significant bit with zero.
  1095                        
  Wed Apr 20 2016 11:57                                                                                                    Page 24


  1096 00:0965: 5A 09 00 02                  HEADER  2,"2*",NORMAL
       00:0969: 32 2A 
  1097                        TWO_STAR:
  1098 00:096B: 06 01                        asl     <1                      ; Multiply top value by two
  1099 00:096D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0971: 00 00 
  1100                        
  1101                        ; 2/ ( x1 -- x2 )
  1102                        ;
  1103                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1104                        ; leaving the most-significant bit unchanged.
  1105                        
  1106 00:0973: 68 09 00 02                  HEADER  2,"2/",NORMAL
       00:0977: 32 2F 
  1107                        TWO_SLASH:
  1108 00:0979: A5 01                        lda     <1                      ; Load the top value
  1109 00:097B: 2A                           rol     a                       ; Extract the top bit
  1110 00:097C: 66 01                        ror     <1                      ; And shift back into value
  1111 00:097E: BB C8 C8 7C                  CONTINUE
       00:0982: 00 00 
  1112                        
  1113                        ; ?NEGATE
  1114                        ;
  1115                        ;       0< IF NEGATE THEN
  1116                        
  1117 00:0984: 20 45 14     QUERY_NEGATE:   jsr     DO_COLON
  1118 00:0987: B6 0C                        dw      ZERO_LESS
  1119 00:0989: D4 15 8F 09                  dw      QUERY_BRANCH,QUERY_NEGATE_1
  1120 00:098D: 38 0A                        dw      NEGATE
  1121 00:098F: BF 0E        QUERY_NEGATE_1: dw      EXIT
  1122                        
  1123                        ; ABS ( n -- u )
  1124                        ;
  1125                        ; u is the absolute value of n.
  1126                        
  1127 00:0991: 76 09 00 03                  HEADER  3,"ABS",NORMAL
       00:0995: 41 42 53 
  1128                        ABS:
  1129 00:0998: A5 01                        lda     <1
  1130 00:099A: 10 03                        bpl     ABS_1
  1131 00:099C: 4C 38 0A                     jmp     NEGATE
  1132 00:099F: BB C8 C8 7C  ABS_1:          CONTINUE                        ; Done
       00:09A3: 00 00 
  1133                        
  1134                        ; FM/MOD
  1135                        ;
  1136                        ;   DUP >R            divisor
  1137                        ;   2DUP XOR >R  sign of quotient
  1138                        ;   >R            divisor
  1139                        ;   DABS R@ ABS UM/MOD
  1140                        ;   SWAP R> ?NEGATE SWAP        apply sign to remainder
  1141                        ;   R> 0< IF                    if quotient negative,
  1142                        ;       NEGATE
  1143                        ;       OVER IF                 if remainder nonzero,
  1144                        ;       R@ ROT - SWAP 1-        adjust rem,quot
  1145                        ;       THEN
  1146                        ;   THEN  R> DROP ;
  1147                        
  Wed Apr 20 2016 11:57                                                                                                    Page 25


  1148 00:09A5: 94 09 00 06                  HEADER  6,"FM/MOD",NORMAL
       00:09A9: 46 4D 2F 4D 
       00:09AD: 4F 44 
  1149 00:09AF: 20 45 14     FM_SLASH_MOD:   jsr     DO_COLON
  1150 00:09B2: 85 07                        dw      DUP
  1151 00:09B4: 6D 08                        dw      TO_R
  1152 00:09B6: BF 06                        dw      TWO_DUP
  1153 00:09B8: 32 0E                        dw      XOR
  1154 00:09BA: 6D 08                        dw      TO_R
  1155 00:09BC: 6D 08                        dw      TO_R
  1156 00:09BE: 38 0B                        dw      DABS
  1157 00:09C0: B9 08                        dw      R_FETCH
  1158 00:09C2: 98 09                        dw      ABS
  1159 00:09C4: 81 0C                        dw      UM_SLASH_MOD
  1160 00:09C6: FB 07                        dw      SWAP
  1161 00:09C8: A6 08                        dw      R_FROM
  1162 00:09CA: 84 09                        dw      QUERY_NEGATE
  1163 00:09CC: FB 07                        dw      SWAP
  1164 00:09CE: A6 08                        dw      R_FROM
  1165 00:09D0: B6 0C                        dw      ZERO_LESS
  1166 00:09D2: D4 15 E8 09                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1167 00:09D6: 38 0A                        dw      NEGATE
  1168 00:09D8: A8 07                        dw      OVER
  1169 00:09DA: D4 15 E8 09                  dw      QUERY_BRANCH,FM_SLASH_MOD_1
  1170 00:09DE: B9 08                        dw      R_FETCH
  1171 00:09E0: E1 07                        dw      ROT
  1172 00:09E2: 15 09                        dw      MINUS
  1173 00:09E4: FB 07                        dw      SWAP
  1174 00:09E6: 5D 09                        dw      ONE_MINUS
  1175 00:09E8: A6 08        FM_SLASH_MOD_1: dw      R_FROM
  1176 00:09EA: 74 07                        dw      DROP
  1177 00:09EC: BF 0E                        dw      EXIT
  1178                        
  1179                        ; MAX
  1180                        
  1181 00:09EE: A8 09 00 03                  HEADER  3,"MAX",NORMAL
       00:09F2: 4D 41 58 
  1182 00:09F5: 20 45 14     MAX:            jsr     DO_COLON
  1183 00:09F8: BF 06                        dw      TWO_DUP
  1184 00:09FA: 08 0D                        dw      LESS
  1185 00:09FC: D4 15 02 0A                  dw      QUERY_BRANCH,MAX_1
  1186 00:0A00: FB 07                        dw      SWAP
  1187 00:0A02: 74 07        MAX_1:          dw      DROP
  1188 00:0A04: BF 0E                        dw      EXIT
  1189                        
  1190                        ; MIN
  1191                        
  1192 00:0A06: F1 09 00 03                  HEADER  3,"MIN",NORMAL
       00:0A0A: 4D 49 4E 
  1193 00:0A0D: 20 45 14     MIN:            jsr     DO_COLON
  1194 00:0A10: BF 06                        dw      TWO_DUP
  1195 00:0A12: 49 0D                        dw      GREATER
  1196 00:0A14: D4 15 1A 0A                  dw      QUERY_BRANCH,MIN_1
  1197 00:0A18: FB 07                        dw      SWAP
  1198 00:0A1A: 74 07        MIN_1:          dw      DROP
  1199 00:0A1C: BF 0E                        dw      EXIT
  1200                        
  1201                        ; MOD
  Wed Apr 20 2016 11:57                                                                                                    Page 26


  1202                        
  1203 00:0A1E: 09 0A 00 03                  HEADER  3,"MOD",NORMAL
       00:0A22: 4D 4F 44 
  1204 00:0A25: 20 45 14     MOD:            jsr     DO_COLON
  1205 00:0A28: 3C 09                        dw      SLASH_MOD
  1206 00:0A2A: 74 07                        dw      DROP
  1207 00:0A2C: BF 0E                        dw      EXIT
  1208                        
  1209                        ; NEGATE ( n1 -- n2 )
  1210                        ;
  1211                        ; Negate n1, giving its arithmetic inverse n2.
  1212                        
  1213 00:0A2E: 21 0A 00 06                  HEADER  6,"NEGATE",NORMAL
       00:0A32: 4E 45 47 41 
       00:0A36: 54 45 
  1214                        NEGATE:
  1215 00:0A38: 38                           sec                             ; Negate the top of stack
  1216 00:0A39: A9 00 00                     lda     #0
  1217 00:0A3C: E5 01                        sbc     <1
  1218 00:0A3E: 85 01                        sta     <1
  1219 00:0A40: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A44: 00 00 
  1220                        
  1221                        ; UMAX ( x1 x2 -- x1|x2 )
  1222                        
  1223 00:0A46: 31 0A 00 04                  HEADER  4,"UMAX",NORMAL
       00:0A4A: 55 4D 41 58 
  1224                        UMAX:
  1225 00:0A4E: A5 01                        lda     <1                      ; Compare the top values
  1226 00:0A50: C5 03                        cmp     <3
  1227 00:0A52: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1228 00:0A54: 4C 74 07                     jmp     DROP                    ; No, x1 is
  1229 00:0A57: 4C 9A 07     UMAX_EXIT:      jmp     NIP
  1230                        
  1231                        ; UMIN ( x1 x2 -- x1|x2 )
  1232                        
  1233 00:0A5A: 49 0A 00 04                  HEADER  4,"UMIN",NORMAL
       00:0A5E: 55 4D 49 4E 
  1234                        UMIN:
  1235 00:0A62: A5 01                        lda     <1                      ; Compare the top values
  1236 00:0A64: C5 03                        cmp     <3
  1237 00:0A66: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1238 00:0A68: 4C 74 07                     jmp     DROP                    ; No, x1 is
  1239 00:0A6B: 4C 9A 07     UMIN_EXIT:      jmp     NIP
  1240                        
  1241                        ;===============================================================================
  1242                        ; Double Precision Arithmetic
  1243                        ;-------------------------------------------------------------------------------
  1244                        
  1245                        ; ?DNEGATE
  1246                        
  1247 00:0A6E: 20 45 14     QUERY_DNEGATE:  jsr     DO_COLON
  1248 00:0A71: B6 0C                        dw      ZERO_LESS
  1249 00:0A73: D4 15 79 0A                  dw      QUERY_BRANCH,QUERY_DNEG_1
  1250 00:0A77: 88 0B                        dw      DNEGATE
  1251 00:0A79: BF 0E        QUERY_DNEG_1:   dw      EXIT
  1252                        
  1253                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  Wed Apr 20 2016 11:57                                                                                                    Page 27


  1254                        ;
  1255                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1256                        
  1257 00:0A7B: 5D 0A 00 02                  HEADER  2,"D+",NORMAL
       00:0A7F: 44 2B 
  1258                        D_PLUS:
  1259 00:0A81: 18                           clc
  1260 00:0A82: A5 07                        lda     <7                      ; Add low words
  1261 00:0A84: 65 03                        adc     <3
  1262 00:0A86: 85 07                        sta     <7
  1263 00:0A88: A5 05                        lda     <5                      ; Then the high words
  1264 00:0A8A: 65 01                        adc     <1
  1265 00:0A8C: 85 05                        sta     <5
  1266 00:0A8E: 7B                           tdc                             ; Drop top double
  1267 00:0A8F: 1A                           inc     a
  1268 00:0A90: 1A                           inc     a
  1269 00:0A91: 1A                           inc     a
  1270 00:0A92: 1A                           inc     a
  1271 00:0A93: 5B                           tcd
  1272 00:0A94: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A98: 00 00 
  1273                        
  1274                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1275                        ;
  1276                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1277                        
  1278 00:0A9A: 7E 0A 00 02                  HEADER  2,"D-",NORMAL
       00:0A9E: 44 2D 
  1279                        D_MINUS:
  1280 00:0AA0: 38                           sec
  1281 00:0AA1: A5 07                        lda     <7                      ; Subtract low words
  1282 00:0AA3: E5 03                        sbc     <3
  1283 00:0AA5: 85 07                        sta     <7
  1284 00:0AA7: A5 05                        lda     <5                      ; Then the high words
  1285 00:0AA9: E5 01                        sbc     <1
  1286 00:0AAB: 85 05                        sta     <5
  1287 00:0AAD: 7B                           tdc                             ; Drop top double
  1288 00:0AAE: 1A                           inc     a
  1289 00:0AAF: 1A                           inc     a
  1290 00:0AB0: 1A                           inc     a
  1291 00:0AB1: 1A                           inc     a
  1292 00:0AB2: 5B                           tcd
  1293 00:0AB3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0AB7: 00 00 
  1294                        
  1295                        ; D0<
  1296                        
  1297 00:0AB9: 9D 0A 00 03                  HEADER  3,"D0<",NORMAL
       00:0ABD: 44 30 3C 
  1298                        D_ZERO_LESS:
  1299 00:0AC0: A6 01                        ldx     <1                      ; Fetch sign
  1300 00:0AC2: 7B                           tdc                             ; Drop a word
  1301 00:0AC3: 1A                           inc     a
  1302 00:0AC4: 1A                           inc     a
  1303 00:0AC5: 5B                           tcd
  1304 00:0AC6: 64 01                        stz     <1                      ; Assume false
  1305 00:0AC8: 8A                           txa
  1306 00:0AC9: 10 02                        bpl     D_ZERO_LESS_1
  Wed Apr 20 2016 11:57                                                                                                    Page 28


  1307 00:0ACB: C6 01                        dec     <1
  1308 00:0ACD: BB C8 C8 7C  D_ZERO_LESS_1:  CONTINUE
       00:0AD1: 00 00 
  1309                        
  1310                        ; D0=
  1311                        
  1312 00:0AD3: BC 0A 00 03                  HEADER  3,"D0=",NORMAL
       00:0AD7: 44 30 3D 
  1313                        D_ZERO_EQUAL:
  1314 00:0ADA: A6 01                        ldx     <1                      ; Fetch sign
  1315 00:0ADC: 7B                           tdc                             ; Drop a word
  1316 00:0ADD: 1A                           inc     a
  1317 00:0ADE: 1A                           inc     a
  1318 00:0ADF: 5B                           tcd
  1319 00:0AE0: 64 01                        stz     <1                      ; Assume false
  1320 00:0AE2: 8A                           txa
  1321 00:0AE3: D0 02                        bne     D_ZERO_EQUAL_1
  1322 00:0AE5: C6 01                        dec     <1
  1323 00:0AE7: BB C8 C8 7C  D_ZERO_EQUAL_1: CONTINUE
       00:0AEB: 00 00 
  1324                        
  1325                        ; D2* ( xd1 -- xd2 )
  1326                        ;
  1327                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1328                        ; filling the vacated least-significant bit with zero.
  1329                        
  1330 00:0AED: D6 0A 00 03                  HEADER  3,"D2*",NORMAL
       00:0AF1: 44 32 2A 
  1331                        D_TWO_STAR:
  1332 00:0AF4: 06 03                        asl     <3
  1333 00:0AF6: 26 01                        rol     <1
  1334 00:0AF8: BB C8 C8 7C                  CONTINUE
       00:0AFC: 00 00 
  1335                        
  1336                        ; D2/ ( xd1 -- xd2 )
  1337                        ;
  1338                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1339                        ; leaving the most-significant bit unchanged.
  1340                        
  1341 00:0AFE: F0 0A 00 03                  HEADER  3,"D2/",NORMAL
       00:0B02: 44 32 2F 
  1342                        D_TWO_SLASH:
  1343 00:0B05: A5 01                        lda     <1
  1344 00:0B07: 2A                           rol     a
  1345 00:0B08: 66 01                        ror     <1
  1346 00:0B0A: 66 03                        ror     <3
  1347 00:0B0C: BB C8 C8 7C                  CONTINUE
       00:0B10: 00 00 
  1348                        
  1349                        ; D<
  1350                        
  1351 00:0B12: 01 0B 00 02                  HEADER  2,"D<",NORMAL
       00:0B16: 44 3C 
  1352 00:0B18: 20 45 14     D_LESS:         jsr     DO_COLON
  1353 00:0B1B: A0 0A                        dw      D_MINUS
  1354 00:0B1D: C0 0A                        dw      D_ZERO_LESS
  1355 00:0B1F: BF 0E                        dw      EXIT
  1356                        
  Wed Apr 20 2016 11:57                                                                                                    Page 29


  1357                        ; D=
  1358                        
  1359 00:0B21: 15 0B 00 02                  HEADER  2,"D=",NORMAL
       00:0B25: 44 3D 
  1360 00:0B27: 20 45 14     D_EQUAL:        jsr     DO_COLON
  1361 00:0B2A: A0 0A                        dw      D_MINUS
  1362 00:0B2C: DA 0A                        dw      D_ZERO_EQUAL
  1363 00:0B2E: BF 0E                        dw      EXIT
  1364                        
  1365                        ; DABS
  1366                        
  1367 00:0B30: 24 0B 00 04                  HEADER  4,"DABS",NORMAL
       00:0B34: 44 41 42 53 
  1368                        DABS:
  1369 00:0B38: A5 01                        lda     <1
  1370 00:0B3A: 10 03                        bpl     DABS_1
  1371 00:0B3C: 4C 88 0B                     jmp     DNEGATE
  1372 00:0B3F: BB C8 C8 7C  DABS_1:         CONTINUE
       00:0B43: 00 00 
  1373                        
  1374                        ; DMAX
  1375                        
  1376 00:0B45: 33 0B 00 04                  HEADER  4,"DMAX",NORMAL
       00:0B49: 44 4D 41 58 
  1377 00:0B4D: 20 45 14     DMAX:           jsr     DO_COLON
  1378 00:0B50: DC 06                        dw      TWO_OVER
  1379 00:0B52: DC 06                        dw      TWO_OVER
  1380 00:0B54: 18 0B                        dw      D_LESS
  1381 00:0B56: D4 15 5C 0B                  dw      QUERY_BRANCH,DMAX_1
  1382 00:0B5A: 26 07                        dw      TWO_SWAP
  1383 00:0B5C: AB 06        DMAX_1:         dw      TWO_DROP
  1384 00:0B5E: BF 0E                        dw      EXIT
  1385                        
  1386                        ; DMIN
  1387                        
  1388 00:0B60: 48 0B 00 04                  HEADER  4,"DMIN",NORMAL
       00:0B64: 44 4D 49 4E 
  1389 00:0B68: 20 45 14     DMIN:           jsr     DO_COLON
  1390 00:0B6B: DC 06                        dw      TWO_OVER
  1391 00:0B6D: DC 06                        dw      TWO_OVER
  1392 00:0B6F: 18 0B                        dw      D_LESS
  1393 00:0B71: B0 0D                        dw      INVERT
  1394 00:0B73: D4 15 79 0B                  dw      QUERY_BRANCH,DMIN_1
  1395 00:0B77: 26 07                        dw      TWO_SWAP
  1396 00:0B79: AB 06        DMIN_1:         dw      TWO_DROP
  1397 00:0B7B: BF 0E                        dw      EXIT
  1398                        
  1399                        ; DNEGATE ( d1 -- d2 )
  1400                        ;
  1401                        ; d2 is the negation of d1.
  1402                        
  1403 00:0B7D: 63 0B 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0B81: 44 4E 45 47 
       00:0B85: 41 54 45 
  1404                        DNEGATE:
  1405 00:0B88: 38                           sec
  1406 00:0B89: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1407 00:0B8C: E5 03                        sbc     <3
  Wed Apr 20 2016 11:57                                                                                                    Page 30


  1408 00:0B8E: 85 03                        sta     <3
  1409 00:0B90: A9 00 00                     lda     #0                      ; Then the high word
  1410 00:0B93: E5 01                        sbc     <1
  1411 00:0B95: 85 01                        sta     <1
  1412 00:0B97: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0B9B: 00 00 
  1413                        
  1414                        ;===============================================================================
  1415                        ; Mixed Arithmetic
  1416                        ;-------------------------------------------------------------------------------
  1417                        
  1418                        ; D>S ( d -- n )
  1419                        ;
  1420                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1421                        ; range of a signed single-cell number.
  1422                        
  1423 00:0B9D: 80 0B 00 03                  HEADER  3,"D>S",NORMAL
       00:0BA1: 44 3E 53 
  1424                        D_TO_S:
  1425 00:0BA4: 7B                           tdc
  1426 00:0BA5: 1A                           inc     a                       ; Drop the high word
  1427 00:0BA6: 1A                           inc     a
  1428 00:0BA7: 5B                           tcd
  1429 00:0BA8: BB C8 C8 7C                  CONTINUE
       00:0BAC: 00 00 
  1430                        
  1431                        ; M*
  1432                        ;
  1433                        ;   2DUP XOR >R carries sign of the result
  1434                        ;   SWAP ABS SWAP ABS UM*
  1435                        ;   R> ?DNEGATE
  1436                        
  1437 00:0BAE: A0 0B 00 02                  HEADER  2,"M*",NORMAL
       00:0BB2: 4D 2A 
  1438 00:0BB4: 20 45 14     M_STAR:         jsr     DO_COLON
  1439 00:0BB7: BF 06                        dw      TWO_DUP
  1440 00:0BB9: 32 0E                        dw      XOR
  1441 00:0BBB: 6D 08                        dw      TO_R
  1442 00:0BBD: FB 07                        dw      SWAP
  1443 00:0BBF: 98 09                        dw      ABS
  1444 00:0BC1: FB 07                        dw      SWAP
  1445 00:0BC3: 98 09                        dw      ABS
  1446 00:0BC5: 55 0C                        dw      UM_STAR
  1447 00:0BC7: A6 08                        dw      R_FROM
  1448 00:0BC9: 6E 0A                        dw      QUERY_DNEGATE
  1449 00:0BCB: BF 0E                        dw      EXIT
  1450                        
  1451                        ; M*/
  1452                        
  1453                        
  1454                        
  1455                        
  1456                        
  1457                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1458                        ;
  1459                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1460                        
  1461 00:0BCD: B1 0B 00 02                  HEADER  2,"M+",NORMAL
  Wed Apr 20 2016 11:57                                                                                                    Page 31


       00:0BD1: 4D 2B 
  1462                        M_PLUS:
  1463 00:0BD3: 18                           clc
  1464 00:0BD4: A5 01                        lda     <1
  1465 00:0BD6: 65 05                        adc     <5
  1466 00:0BD8: 85 05                        sta     <5
  1467 00:0BDA: 90 02                        bcc     $+4
  1468 00:0BDC: E6 03                        inc     <3
  1469 00:0BDE: 7B                           tdc
  1470 00:0BDF: 1A                           inc     a
  1471 00:0BE0: 1A                           inc     a
  1472 00:0BE1: 5B                           tcd
  1473 00:0BE2: BB C8 C8 7C                  CONTINUE
       00:0BE6: 00 00 
  1474                        
  1475                        ; S>D ( n -- d )
  1476                        ;
  1477                        ; Convert the number n to the double-cell number d with the same numerical
  1478                        ; value.
  1479                        
  1480 00:0BE8: D0 0B 00 03                  HEADER  3,"S>D",NORMAL
       00:0BEC: 53 3E 44 
  1481                        S_TO_D:
  1482 00:0BEF: 7B                           tdc
  1483 00:0BF0: 3A                           dec     a                       ; Assume n is positive
  1484 00:0BF1: 3A                           dec     a
  1485 00:0BF2: 5B                           tcd
  1486 00:0BF3: 64 01                        stz     <1                      ; .. push a zero value
  1487 00:0BF5: A5 03                        lda     <3                      ; Test the number
  1488 00:0BF7: 10 02                        bpl     S_TO_D_1
  1489 00:0BF9: C6 01                        dec     <1                      ; Make top -1 if negative
  1490 00:0BFB: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0BFF: 00 00 
  1491                        
  1492                        ; SM/REM
  1493                        ;
  1494                        ;   2DUP XOR >R                 sign of quotient
  1495                        ;   OVER >R                     sign of remainder
  1496                        ;   ABS >R DABS R> UM/MOD
  1497                        ;   SWAP R> ?NEGATE
  1498                        ;   SWAP R> ?NEGATE ;
  1499                        
  1500 00:0C01: EB 0B 00 06                  HEADER  6,"SM/REM",NORMAL
       00:0C05: 53 4D 2F 52 
       00:0C09: 45 4D 
  1501 00:0C0B: 20 45 14     SM_SLASH_REM:   jsr     DO_COLON
  1502 00:0C0E: BF 06                        dw      TWO_DUP
  1503 00:0C10: 32 0E                        dw      XOR
  1504 00:0C12: 6D 08                        dw      TO_R
  1505 00:0C14: A8 07                        dw      OVER
  1506 00:0C16: 6D 08                        dw      TO_R
  1507 00:0C18: 98 09                        dw      ABS
  1508 00:0C1A: 6D 08                        dw      TO_R
  1509 00:0C1C: 38 0B                        dw      DABS
  1510 00:0C1E: A6 08                        dw      R_FROM
  1511 00:0C20: 81 0C                        dw      UM_SLASH_MOD
  1512 00:0C22: FB 07                        dw      SWAP
  1513 00:0C24: A6 08                        dw      R_FROM
  Wed Apr 20 2016 11:57                                                                                                    Page 32


  1514 00:0C26: 84 09                        dw      QUERY_NEGATE
  1515 00:0C28: FB 07                        dw      SWAP
  1516 00:0C2A: A6 08                        dw      R_FROM
  1517 00:0C2C: 84 09                        dw      QUERY_NEGATE
  1518 00:0C2E: BF 0E                        dw      EXIT
  1519                        
  1520                        ; UD* ( ud1 d2 -- ud3)
  1521                        ;
  1522                        ; 32*16->32 multiply
  1523                        ;
  1524                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1525                        
  1526 00:0C30: 04 0C 00 03                  HEADER  3,"UD*",NORMAL
       00:0C34: 55 44 2A 
  1527 00:0C37: 20 45 14     UD_STAR:        jsr     DO_COLON
  1528 00:0C3A: 85 07                        dw      DUP
  1529 00:0C3C: 6D 08                        dw      TO_R
  1530 00:0C3E: 55 0C                        dw      UM_STAR
  1531 00:0C40: 74 07                        dw      DROP
  1532 00:0C42: FB 07                        dw      SWAP
  1533 00:0C44: A6 08                        dw      R_FROM
  1534 00:0C46: 55 0C                        dw      UM_STAR
  1535 00:0C48: E1 07                        dw      ROT
  1536 00:0C4A: FF 08                        dw      PLUS
  1537 00:0C4C: BF 0E                        dw      EXIT
  1538                        
  1539                        ; UM* ( n1 n2 -- d )
  1540                        
  1541 00:0C4E: 33 0C 00 03                  HEADER  3,"UM*",NORMAL
       00:0C52: 55 4D 2A 
  1542                        UM_STAR:
  1543 00:0C55: A5 01                        lda     <1                      ; Fetch multiplier
  1544 00:0C57: 48                           pha
  1545 00:0C58: 64 01                        stz     <1                      ; Clear the result
  1546 00:0C5A: A2 10 00                     ldx     #16
  1547 00:0C5D: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1548 00:0C5F: 4A                           lsr     a
  1549 00:0C60: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1550 00:0C62: A3 01                        lda     1,s                     ; Fetch multiplicand
  1551 00:0C64: 18                           clc
  1552 00:0C65: 65 01                        adc     <1
  1553 00:0C67: 85 01                        sta     <1
  1554 00:0C69: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1555 00:0C6B: 66 03                        ror     <3
  1556 00:0C6D: CA                           dex
  1557 00:0C6E: D0 ED                        bne     UM_STAR_1
  1558 00:0C70: 68                           pla
  1559 00:0C71: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C75: 00 00 
  1560                        
  1561                        ; UM/MOD ( ud u1 -- u2 u3 )
  1562                        ;
  1563                        ; Divide ud by u1, giving the quotient u3 and the remainder u2. All values and
  1564                        ; arithmetic are unsigned. An ambiguous condition exists if u1 is zero or if the
  1565                        ; quotient lies outside the range of a single-cell unsigned integer.
  1566                        
  1567 00:0C77: 51 0C 00 06                  HEADER  6,"UM/MOD",NORMAL
       00:0C7B: 55 4D 2F 4D 
  Wed Apr 20 2016 11:57                                                                                                    Page 33


       00:0C7F: 4F 44 
  1568                        UM_SLASH_MOD:
  1569 00:0C81: 38                           sec                             ; Check for overflow
  1570 00:0C82: A5 03                        lda     <3
  1571 00:0C84: E5 01                        sbc     <1
  1572 00:0C86: B0 1A                        bcs     UM_SLASH_MOD_3
  1573                        
  1574 00:0C88: A2 11 00                     ldx     #17
  1575 00:0C8B: 26 05        UM_SLASH_MOD_1: rol     <5                      ; Rotate dividend lo
  1576 00:0C8D: CA                           dex
  1577 00:0C8E: F0 19                        beq     UM_SLASH_MOD_4
  1578 00:0C90: 26 03                        rol     <3
  1579 00:0C92: B0 06                        bcs     UM_SLASH_MOD_2          ; Carry set dividend > divisor
  1580                        
  1581 00:0C94: A5 03                        lda     <3                      ; Is dividend < divisor?
  1582 00:0C96: C5 01                        cmp     <1
  1583 00:0C98: 90 F1                        bcc     UM_SLASH_MOD_1          ; Yes, shift in 0
  1584                        
  1585 00:0C9A: A5 03        UM_SLASH_MOD_2: lda     <3                      ; Reduce dividend
  1586 00:0C9C: E5 01                        sbc     <1
  1587 00:0C9E: 85 03                        sta     <3
  1588 00:0CA0: 80 E9                        bra     UM_SLASH_MOD_1          ; Shift in 1
  1589                        
  1590 00:0CA2: A9 FF FF     UM_SLASH_MOD_3: lda     #$ffff                  ; Overflowed set results
  1591 00:0CA5: 85 03                        sta     <3
  1592 00:0CA7: 85 05                        sta     <5
  1593 00:0CA9: 7B           UM_SLASH_MOD_4: tdc                             ; Drop top word
  1594 00:0CAA: 1A                           inc     a
  1595 00:0CAB: 1A                           inc     a
  1596 00:0CAC: 5B                           tcd
  1597 00:0CAD: 4C FB 07                     jmp     SWAP                    ; Swap quotient and remainder
  1598                        
  1599                        ;===============================================================================
  1600                        ; Comparisons
  1601                        ;-------------------------------------------------------------------------------
  1602                        
  1603                        ; 0< ( n -- flag )
  1604                        ;
  1605                        ; flag is true if and only if n is less than zero.
  1606                        
  1607 00:0CB0: 7A 0C 00 02                  HEADER  2,"0<",NORMAL
       00:0CB4: 30 3C 
  1608                        ZERO_LESS:
  1609 00:0CB6: A5 01                        lda     <1                      ; Test top of stack
  1610 00:0CB8: 64 01                        stz     <1                      ; Assume false result
  1611 00:0CBA: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1612 00:0CBC: C6 01                        dec     <1                      ; Yes, make true result
  1613 00:0CBE: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0CC2: 00 00 
  1614                        
  1615                        ; 0<> ( x -- flag )
  1616                        ;
  1617                        ; flag is true if and only if x is not equal to zero.
  1618                        
  1619 00:0CC4: B3 0C 00 03                  HEADER  3,"0<>",NORMAL
       00:0CC8: 30 3C 3E 
  1620                        ZERO_NOT_EQUAL:
  1621 00:0CCB: A5 01                        lda     <1                      ; Test top of stack
  Wed Apr 20 2016 11:57                                                                                                    Page 34


  1622 00:0CCD: 64 01                        stz     <1                      ; Assume false result
  1623 00:0CCF: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1624 00:0CD1: C6 01                        dec     <1                      ; Yes, make true result
  1625 00:0CD3: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0CD7: 00 00 
  1626                        
  1627                        ; 0= ( x -- flag )
  1628                        ;
  1629                        ; flag is true if and only if x is equal to zero.
  1630                        
  1631 00:0CD9: C7 0C 00 02                  HEADER  2,"0=",NORMAL
       00:0CDD: 30 3D 
  1632                        ZERO_EQUAL:
  1633 00:0CDF: A5 01                        lda     <1                      ; Test top of stack
  1634 00:0CE1: 64 01                        stz     <1                      ; Assume false result
  1635 00:0CE3: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1636 00:0CE5: C6 01                        dec     <1                      ; Yes, make true result
  1637 00:0CE7: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0CEB: 00 00 
  1638                        
  1639                        ; 0> ( n -- flag )
  1640                        ;
  1641                        ; flag is true if and only if n is greater than zero.
  1642                        
  1643 00:0CED: DC 0C 00 02                  HEADER  2,"0>",NORMAL
       00:0CF1: 30 3E 
  1644                        ZERO_GREATER:
  1645 00:0CF3: A5 01                        lda     <1                      ; Test top of stack
  1646 00:0CF5: 64 01                        stz     <1                      ; Assume false result
  1647 00:0CF7: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1648 00:0CF9: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1649 00:0CFB: C6 01                        dec     <1                      ; Yes, make true result
  1650 00:0CFD: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0D01: 00 00 
  1651                        
  1652                        ; <
  1653                        
  1654 00:0D03: F0 0C 00 01                  HEADER  1,"<",NORMAL
       00:0D07: 3C 
  1655 00:0D08: 20 45 14     LESS:           jsr     DO_COLON
  1656 00:0D0B: FB 07                        dw      SWAP
  1657 00:0D0D: 49 0D                        dw      GREATER
  1658 00:0D0F: BF 0E                        dw      EXIT
  1659                        
  1660                        ; <>
  1661                        
  1662 00:0D11: 06 0D 00 02                  HEADER  2,"<>",NORMAL
       00:0D15: 3C 3E 
  1663                        NOT_EQUAL:
  1664 00:0D17: A6 01                        ldx     <1                      ; Pull x2 from stack
  1665 00:0D19: 7B                           tdc
  1666 00:0D1A: 1A                           inc     a
  1667 00:0D1B: 1A                           inc     a
  1668 00:0D1C: 5B                           tcd
  1669 00:0D1D: E4 01                        cpx     <1                      ; Compare with x1
  1670 00:0D1F: 64 01                        stz     <1                      ; Assume equal
  1671 00:0D21: F0 02                        beq     NE_EXIT                 ; Test flags
  1672 00:0D23: C6 01                        dec     <1                      ; Make result true
  Wed Apr 20 2016 11:57                                                                                                    Page 35


  1673 00:0D25: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0D29: 00 00 
  1674                        
  1675                        ; = ( x1 x2 -- flag )
  1676                        ;
  1677                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1678                        
  1679 00:0D2B: 14 0D 00 01                  HEADER  1,"=",NORMAL
       00:0D2F: 3D 
  1680                        EQUAL:
  1681 00:0D30: A6 01                        ldx     <1                      ; Pull x2 from stack
  1682 00:0D32: 7B                           tdc
  1683 00:0D33: 1A                           inc     a
  1684 00:0D34: 1A                           inc     a
  1685 00:0D35: 5B                           tcd
  1686 00:0D36: E4 01                        cpx     <1                      ; Compare with x1
  1687 00:0D38: 64 01                        stz     <1                      ; Assume not equal
  1688 00:0D3A: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1689 00:0D3C: C6 01                        dec     <1                      ; Make result true
  1690 00:0D3E: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0D42: 00 00 
  1691                        
  1692                        ; >
  1693                        
  1694 00:0D44: 2E 0D 00 01                  HEADER  1,">",NORMAL
       00:0D48: 3E 
  1695                        GREATER:
  1696 00:0D49: A6 01                        ldx     <1                      ; Pull x2 from stack
  1697 00:0D4B: 7B                           tdc
  1698 00:0D4C: 1A                           inc     a
  1699 00:0D4D: 1A                           inc     a
  1700 00:0D4E: 5B                           tcd
  1701 00:0D4F: 8A                           txa
  1702 00:0D50: 38                           sec                             ; Compare with x1
  1703 00:0D51: E5 01                        sbc     <1
  1704 00:0D53: 64 01                        stz     <1                      ; Assume false result
  1705 00:0D55: 50 03                        bvc     GREATER_1
  1706 00:0D57: 49 00 80                     eor     #$8000
  1707 00:0D5A: 10 02        GREATER_1:      bpl     GREATER_2               ; V == 1 && N == 1
  1708 00:0D5C: C6 01                        dec     <1
  1709 00:0D5E: BB C8 C8 7C  GREATER_2:      CONTINUE
       00:0D62: 00 00 
  1710                        
  1711                        
  1712                        ; U<
  1713                        
  1714 00:0D64: 47 0D 00 02                  HEADER  2,"U<",NORMAL
       00:0D68: 55 3C 
  1715                        U_LESS:
  1716 00:0D6A: A6 01                        ldx     <1                      ; Pull x2
  1717 00:0D6C: 7B                           tdc                             ; Drop from stack
  1718 00:0D6D: 1A                           inc     a
  1719 00:0D6E: 1A                           inc     a
  1720 00:0D6F: 5B                           tcd
  1721 00:0D70: E4 01                        cpx     <1                      ; Compare with x1
  1722 00:0D72: 64 01                        stz     <1                      ; Assume false
  1723 00:0D74: F0 04                        beq     U_LESS_1                ; Equal
  1724 00:0D76: 90 02                        bcc     U_LESS_1                ; Less
  Wed Apr 20 2016 11:57                                                                                                    Page 36


  1725 00:0D78: C6 01                        dec     <1
  1726 00:0D7A: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0D7E: 00 00 
  1727                        
  1728                        ; U>
  1729                        
  1730 00:0D80: 67 0D 00 02                  HEADER  2,"U>",NORMAL
       00:0D84: 55 3E 
  1731 00:0D86: 20 45 14     U_GREATER:      jsr     DO_COLON
  1732 00:0D89: FB 07                        dw      SWAP
  1733 00:0D8B: 6A 0D                        dw      U_LESS
  1734 00:0D8D: BF 0E                        dw      EXIT
  1735                        
  1736                        ;===============================================================================
  1737                        ; Logical Operations
  1738                        ;-------------------------------------------------------------------------------
  1739                        
  1740                        ; AND ( x1 x2 -- x3 )
  1741                        ;
  1742                        ; x3 is the bit-by-bit logical and of x1 with x2.
  1743                        
  1744 00:0D8F: 83 0D 00 03                  HEADER  3,"AND",NORMAL
       00:0D93: 41 4E 44 
  1745                        AND:
  1746 00:0D96: A5 01                        lda     <1
  1747 00:0D98: 25 03                        and     <3
  1748 00:0D9A: 85 03                        sta     <3
  1749 00:0D9C: 7B                           tdc
  1750 00:0D9D: 1A                           inc     a
  1751 00:0D9E: 1A                           inc     a
  1752 00:0D9F: 5B                           tcd
  1753 00:0DA0: BB C8 C8 7C                  CONTINUE
       00:0DA4: 00 00 
  1754                        
  1755                        ; INVERT ( x1 -- x2 )
  1756                        ;
  1757                        ; Invert all bits of x1, giving its logical inverse x2.
  1758                        
  1759 00:0DA6: 92 0D 00 06                  HEADER  6,"INVERT",NORMAL
       00:0DAA: 49 4E 56 45 
       00:0DAE: 52 54 
  1760                        INVERT:
  1761 00:0DB0: A5 01                        lda     <1                      ; Fetch top value
  1762 00:0DB2: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1763 00:0DB5: 85 01                        sta     <1                      ; .. and write back
  1764 00:0DB7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0DBB: 00 00 
  1765                        
  1766                        ; LSHIFT ( x1 u -- x2 )
  1767                        ;
  1768                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1769                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1770                        ; exists if u is greater than or equal to the number of bits in a cell.
  1771                        
  1772 00:0DBD: A9 0D 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:0DC1: 4C 53 48 49 
       00:0DC5: 46 54 
  1773                        LSHIFT:
  Wed Apr 20 2016 11:57                                                                                                    Page 37


  1774 00:0DC7: A6 01                        ldx     <1                      ; Pull bit count
  1775 00:0DC9: 08                           php
  1776 00:0DCA: 7B                           tdc
  1777 00:0DCB: 1A                           inc     a                       ; .. from the stack
  1778 00:0DCC: 1A                           inc     a
  1779 00:0DCD: 5B                           tcd
  1780 00:0DCE: 28                           plp
  1781 00:0DCF: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1782 00:0DD1: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1783 00:0DD4: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1784 00:0DD6: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1785 00:0DD8: CA                           dex                             ; Update count
  1786 00:0DD9: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1787 00:0DDB: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0DDF: 00 00 
  1788 00:0DE1: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1789 00:0DE3: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0DE7: 00 00 
  1790                        
  1791                        ; OR ( x1 x2 -- x3 )
  1792                        ;
  1793                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1794                        
  1795 00:0DE9: C0 0D 00 02                  HEADER  2,"OR",NORMAL
       00:0DED: 4F 52 
  1796                        OR:
  1797 00:0DEF: A5 01                        lda     <1
  1798 00:0DF1: 05 03                        ora     <3
  1799 00:0DF3: 85 03                        sta     <3
  1800 00:0DF5: 7B                           tdc
  1801 00:0DF6: 1A                           inc     a
  1802 00:0DF7: 1A                           inc     a
  1803 00:0DF8: 5B                           tcd
  1804 00:0DF9: BB C8 C8 7C                  CONTINUE
       00:0DFD: 00 00 
  1805                        
  1806                        ; RSHIFT ( x1 u -- x2 )
  1807                        ;
  1808                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1809                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1810                        ; exists if u is greater than or equal to the number of bits in a cell.
  1811                        
  1812 00:0DFF: EC 0D 00 06                  HEADER  6,"RSHIFT",NORMAL
       00:0E03: 52 53 48 49 
       00:0E07: 46 54 
  1813                        RSHIFT:
  1814 00:0E09: A6 01                        ldx     <1                      ; Pull bit count
  1815 00:0E0B: 08                           php
  1816 00:0E0C: 7B                           tdc
  1817 00:0E0D: 1A                           inc     a                       ; .. from the stack
  1818 00:0E0E: 1A                           inc     a
  1819 00:0E0F: 5B                           tcd
  1820 00:0E10: 28                           plp
  1821 00:0E11: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1822 00:0E13: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1823 00:0E16: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1824 00:0E18: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1825 00:0E1A: CA                           dex                             ; Update count
  Wed Apr 20 2016 11:57                                                                                                    Page 38


  1826 00:0E1B: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1827 00:0E1D: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0E21: 00 00 
  1828 00:0E23: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1829 00:0E25: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0E29: 00 00 
  1830                        
  1831                        ; XOR ( x1 x2 -- x3 )
  1832                        ;
  1833                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1834                        
  1835 00:0E2B: 02 0E 00 03                  HEADER  3,"XOR",NORMAL
       00:0E2F: 58 4F 52 
  1836                        XOR:
  1837 00:0E32: A5 01                        lda     <1
  1838 00:0E34: 45 03                        eor     <3
  1839 00:0E36: 85 03                        sta     <3
  1840 00:0E38: 7B                           tdc
  1841 00:0E39: 1A                           inc     a
  1842 00:0E3A: 1A                           inc     a
  1843 00:0E3B: 5B                           tcd
  1844 00:0E3C: BB C8 C8 7C                  CONTINUE
       00:0E40: 00 00 
  1845                        
  1846                        ;===============================================================================
  1847                        ; Control Words
  1848                        ;-------------------------------------------------------------------------------
  1849                        
  1850                        ; ?ABORT
  1851                        ;
  1852                        ;   ROT IF TYPE ABORT THEN 2DROP ;
  1853                        
  1854 00:0E42: 20 45 14     QUERY_ABORT:    jsr     DO_COLON
  1855 00:0E45: E1 07                        dw      ROT
  1856 00:0E47: D4 15 4F 0E                  dw      QUERY_BRANCH,QUERY_ABORT_1
  1857 00:0E4B: 47 18                        dw      TYPE
  1858 00:0E4D: 5C 0E                        dw      ABORT
  1859 00:0E4F: AB 06        QUERY_ABORT_1:  dw      TWO_DROP
  1860 00:0E51: BF 0E                        dw      EXIT
  1861                        
  1862                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1863                        ;
  1864                        ; Empty the data stack and perform the function of QUIT, which includes
  1865                        ; emptying the return stack, without displaying a message.
  1866                        
  1867 00:0E53: 2E 0E 00 05                  HEADER  5,"ABORT",NORMAL
       00:0E57: 41 42 4F 52 
       00:0E5B: 54 
  1868 00:0E5C: 20 45 14     ABORT:          jsr     DO_COLON
  1869 00:0E5F: 63 0E                        dw      DO_ABORT
  1870 00:0E61: CE 0E                        dw      QUIT
  1871                        
  1872                        DO_ABORT:
  1873 00:0E63: A9 7F 01                     lda     #DSTACK_END-1
  1874 00:0E66: 5B                           tcd
  1875 00:0E67: BB C8 C8 7C                  CONTINUE
       00:0E6B: 00 00 
  1876                        
  Wed Apr 20 2016 11:57                                                                                                    Page 39


  1877                        ; (BUILD) ( dtc-addr -- )
  1878                        ;
  1879                        ; Adds a jump the to exection function for the new word.
  1880                        
  1881                        ;               HEADER  7,"(BUILD)",NORMAL
  1882 00:0E6D: 20 45 14     BUILD:          jsr     DO_COLON
  1883 00:0E70: 1B 16 20 00                  dw      DO_LITERAL,$20
  1884 00:0E74: F5 05                        dw      C_COMMA
  1885 00:0E76: 79 05                        dw      COMMA
  1886 00:0E78: BF 0E                        dw      EXIT
  1887                        
  1888                        ; CREATE ( -- ) [TODO]
  1889                        ;
  1890                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1891                        ; definition for name with the execution semantics defined below. If the data-
  1892                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1893                        ; data-space pointer defines names data field. CREATE does not allocate data
  1894                        ; space in names data field.
  1895                        
  1896 00:0E7A: 56 0E 00 06                  HEADER  6,"CREATE",NORMAL
       00:0E7E: 43 52 45 41 
       00:0E82: 54 45 
  1897 00:0E84: 20 45 14     CREATE:         jsr     DO_COLON
  1898 00:0E87: 94 04                        dw      LATEST
  1899 00:0E89: B9 05                        dw      FETCH
  1900 00:0E8B: 79 05                        dw      COMMA
  1901 00:0E8D: CE 04                        dw      ZERO
  1902 00:0E8F: F5 05                        dw      C_COMMA
  1903 00:0E91: 24 06                        dw      HERE
  1904 00:0E93: 94 04                        dw      LATEST
  1905 00:0E95: 4B 05                        dw      STORE
  1906 00:0E97: E0 04                        dw      BL
  1907 00:0E99: 8D 12                        dw      WORD
  1908 00:0E9B: 0C 06                        dw      C_FETCH
  1909 00:0E9D: 4F 09                        dw      ONE_PLUS
  1910 00:0E9F: CC 05                        dw      ALLOT
  1911 00:0EA1: BF 0E                        dw      EXIT
  1912                        
  1913                        ; EXECUTE ( i*x xt -- j*x )
  1914                        ;
  1915                        ; Remove xt from the stack and perform the semantics identified by it. Other
  1916                        ; stack effects are due to the word EXECUTEd.
  1917                        
  1918 00:0EA3: 7D 0E 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0EA7: 45 58 45 43 
       00:0EAB: 55 54 45 
  1919                        EXECUTE:
  1920 00:0EAE: A6 01                        ldx     <1
  1921 00:0EB0: 7B                           tdc
  1922 00:0EB1: 1A                           inc     a
  1923 00:0EB2: 1A                           inc     a
  1924 00:0EB3: 5B                           tcd
  1925 00:0EB4: CA                           dex
  1926 00:0EB5: DA                           phx
  1927 00:0EB6: 60                           rts
  1928                        
  1929                        ; EXIT ( -- ) ( R: nest-sys -- )
  1930                        ;
  Wed Apr 20 2016 11:57                                                                                                    Page 40


  1931                        ; Return control to the calling definition specified by nest-sys. Before
  1932                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  1933                        ; parameters by executing UNLOOP.
  1934                        
  1935 00:0EB7: A6 0E 00 04                  HEADER  4,"EXIT",NORMAL
       00:0EBB: 45 58 49 54 
  1936                        EXIT:
  1937 00:0EBF: 7A                           ply
  1938 00:0EC0: BB C8 C8 7C                  CONTINUE
       00:0EC4: 00 00 
  1939                        
  1940                        ; QUIT ( -- ) ( R: i*x -- )
  1941                        ;
  1942                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1943                        ; user input device the input source, and enter interpretation state. Do not
  1944                        ; display a message. Repeat the following:
  1945                        ;  Accept a line from the input source into the input buffer, set >IN to zero,
  1946                        ;   and interpret.
  1947                        ;  Display the implementation-defined system prompt if in interpretation state,
  1948                        ;   all processing has been completed, and no ambiguous condition exists.
  1949                        ;
  1950                        ; In this implementation it is defined as:
  1951                        ;
  1952                        ;   DO_QUIT 0 STATE !
  1953                        ;   0 (SOURCE-ID) !
  1954                        ;   BEGIN
  1955                        ;     REFILL
  1956                        ;     WHILE SOURCE EVALUATE
  1957                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  1958                        ;   AGAIN ;
  1959                        
  1960 00:0EC6: BA 0E 00 04                  HEADER  4,"QUIT",NORMAL
       00:0ECA: 51 55 49 54 
  1961 00:0ECE: 20 45 14     QUIT:           jsr     DO_COLON
  1962 00:0ED1: FE 0E                        dw      DO_QUIT
  1963 00:0ED3: CE 04                        dw      ZERO
  1964 00:0ED5: B8 04                        dw      STATE
  1965 00:0ED7: 4B 05                        dw      STORE
  1966 00:0ED9: CE 04                        dw      ZERO
  1967 00:0EDB: AA 04                        dw      SOURCEID
  1968 00:0EDD: 4B 05                        dw      STORE
  1969 00:0EDF: 88 11        QUIT_1:         dw      REFILL
  1970 00:0EE1: D4 15 E7 0E                  dw      QUERY_BRANCH,QUIT_2
  1971 00:0EE5: BF 10                        dw      INTERPRET
  1972 00:0EE7: B8 04        QUIT_2:         dw      STATE
  1973 00:0EE9: B9 05                        dw      FETCH
  1974 00:0EEB: DF 0C                        dw      ZERO_EQUAL
  1975 00:0EED: D4 15 FA 0E                  dw      QUERY_BRANCH,QUIT_3
  1976 00:0EF1: CA 16                        dw      DO_S_QUOTE
  1977 00:0EF3: 02 4F 6B                     db      2,"Ok"
  1978 00:0EF6: 47 18                        dw      TYPE
  1979 00:0EF8: CA 17                        dw      CR
  1980 00:0EFA: B3 15 DF 0E  QUIT_3:         dw      BRANCH,QUIT_1
  1981                        
  1982                        DO_QUIT:
  1983 00:0EFE: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  1984 00:0F01: 1B                           tcs
  1985 00:0F02: BB C8 C8 7C                  CONTINUE                        ; Done
  Wed Apr 20 2016 11:57                                                                                                    Page 41


       00:0F06: 00 00 
  1986                        
  1987                        ;===============================================================================
  1988                        ; Parser & Interpreter
  1989                        ;-------------------------------------------------------------------------------
  1990                        
  1991                        ; ?NUMBER
  1992                        ;
  1993                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  1994                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  1995                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  1996                        ;   ELSE 2DROP NIP R>
  1997                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  1998                        ;   THEN ;
  1999                        
  2000 00:0F08: C9 0E 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0F0C: 3F 4E 55 4D 
       00:0F10: 42 45 52 
  2001 00:0F13: 20 45 14     QUERY_NUMBER:   jsr     DO_COLON
  2002 00:0F16: 85 07                        dw      DUP
  2003 00:0F18: CE 04                        dw      ZERO
  2004 00:0F1A: CE 04                        dw      ZERO
  2005 00:0F1C: E1 07                        dw      ROT
  2006 00:0F1E: 9D 13                        dw      COUNT
  2007 00:0F20: 51 0F                        dw      QUERY_SIGN
  2008 00:0F22: 6D 08                        dw      TO_R
  2009 00:0F24: 98 0F                        dw      TO_NUMBER
  2010 00:0F26: D4 15 36 0F                  dw      QUERY_BRANCH,QNUM_1
  2011 00:0F2A: A6 08                        dw      R_FROM
  2012 00:0F2C: AB 06                        dw      TWO_DROP
  2013 00:0F2E: AB 06                        dw      TWO_DROP
  2014 00:0F30: CE 04                        dw      ZERO
  2015 00:0F32: B3 15 46 0F                  dw      BRANCH,QNUM_3
  2016 00:0F36: AB 06        QNUM_1:         dw      TWO_DROP
  2017 00:0F38: 9A 07                        dw      NIP
  2018 00:0F3A: A6 08                        dw      R_FROM
  2019 00:0F3C: D4 15 42 0F                  dw      QUERY_BRANCH,QNUM_2
  2020 00:0F40: 38 0A                        dw      NEGATE
  2021 00:0F42: 1B 16 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  2022 00:0F46: BF 0E        QNUM_3:         dw      EXIT
  2023                        
  2024                        ; ?SIGN ( c-addr n -- adr' n' f )
  2025                        ;
  2026                        ;   OVER C@                 -- adr n c
  2027                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  2028                        ;   DUP IF 1+               -- +=0, -=+2
  2029                        ;       >R 1 /STRING R>     -- adr' n' f
  2030                        ;   THEN ;
  2031                        
  2032 00:0F48: 0B 0F 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0F4C: 3F 53 49 47 
       00:0F50: 4E 
  2033 00:0F51: 20 45 14     QUERY_SIGN:     jsr     DO_COLON
  2034 00:0F54: A8 07                        dw      OVER
  2035 00:0F56: 0C 06                        dw      C_FETCH
  2036 00:0F58: 1B 16 2D 00                  dw      DO_LITERAL,'-'
  2037 00:0F5C: 15 09                        dw      MINUS
  2038 00:0F5E: 85 07                        dw      DUP
  Wed Apr 20 2016 11:57                                                                                                    Page 42


  2039 00:0F60: 98 09                        dw      ABS
  2040 00:0F62: 1B 16 01 00                  dw      DO_LITERAL,1
  2041 00:0F66: 30 0D                        dw      EQUAL
  2042 00:0F68: 96 0D                        dw      AND
  2043 00:0F6A: 85 07                        dw      DUP
  2044 00:0F6C: D4 15 7C 0F                  dw      QUERY_BRANCH,QSIGN_1
  2045 00:0F70: 4F 09                        dw      ONE_PLUS
  2046 00:0F72: 6D 08                        dw      TO_R
  2047 00:0F74: 1B 16 01 00                  dw      DO_LITERAL,1
  2048 00:0F78: F1 12                        dw      SLASH_STRING
  2049 00:0F7A: A6 08                        dw      R_FROM
  2050 00:0F7C: BF 0E        QSIGN_1:        dw      EXIT
  2051                        
  2052                        ; >COUNTED ( c-addr n -- )
  2053                        ;
  2054                        ;   2DUP C! CHAR+ SWAP CMOVE
  2055                        
  2056 00:0F7E: 20 45 14     TO_COUNTED:     jsr     DO_COLON
  2057 00:0F81: BF 06                        dw      TWO_DUP
  2058 00:0F83: DB 05                        dw      C_STORE
  2059 00:0F85: 7A 06                        dw      CHAR_PLUS
  2060 00:0F87: FB 07                        dw      SWAP
  2061 00:0F89: 35 13                        dw      CMOVE
  2062 00:0F8B: BF 0E                        dw      EXIT
  2063                        
  2064                        ; >NUMBER ( ud adr u -- ud' adr' u' )
  2065                        ;
  2066                        ;
  2067                        ;   BEGIN
  2068                        ;   DUP WHILE
  2069                        ;       OVER C@ DIGIT?
  2070                        ;       0= IF DROP EXIT THEN
  2071                        ;       >R 2SWAP BASE @ UD*
  2072                        ;       R> M+ 2SWAP
  2073                        ;       1 /STRING
  2074                        ;   REPEAT ;
  2075                        
  2076 00:0F8D: 4B 0F 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0F91: 3E 4E 55 4D 
       00:0F95: 42 45 52 
  2077 00:0F98: 20 45 14     TO_NUMBER:      jsr     DO_COLON
  2078 00:0F9B: 85 07        TO_NUM_1:       dw      DUP
  2079 00:0F9D: D4 15 CB 0F                  dw      QUERY_BRANCH,TO_NUM_3
  2080 00:0FA1: A8 07                        dw      OVER
  2081 00:0FA3: 0C 06                        dw      C_FETCH
  2082 00:0FA5: 4A 10                        dw      DIGIT_QUERY
  2083 00:0FA7: DF 0C                        dw      ZERO_EQUAL
  2084 00:0FA9: D4 15 B1 0F                  dw      QUERY_BRANCH,TO_NUM_2
  2085 00:0FAD: 74 07                        dw      DROP
  2086 00:0FAF: BF 0E                        dw      EXIT
  2087 00:0FB1: 6D 08        TO_NUM_2:       dw      TO_R
  2088 00:0FB3: 26 07                        dw      TWO_SWAP
  2089 00:0FB5: 64 04                        dw      BASE
  2090 00:0FB7: B9 05                        dw      FETCH
  2091 00:0FB9: 37 0C                        dw      UD_STAR
  2092 00:0FBB: A6 08                        dw      R_FROM
  2093 00:0FBD: D3 0B                        dw      M_PLUS
  2094 00:0FBF: 26 07                        dw      TWO_SWAP
  Wed Apr 20 2016 11:57                                                                                                    Page 43


  2095 00:0FC1: 1B 16 01 00                  dw      DO_LITERAL,1
  2096 00:0FC5: F1 12                        dw      SLASH_STRING
  2097 00:0FC7: B3 15 9B 0F                  dw      BRANCH,TO_NUM_1
  2098 00:0FCB: BF 0E        TO_NUM_3:       dw      EXIT
  2099                        
  2100                        ; ACCEPT ( c-addr +n1 -- +n2 )
  2101                        ;
  2102                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  2103                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  2104                        ; received. A program that depends on the presence or absence of non-graphic
  2105                        ; characters in the string has an environmental dependency. The editing
  2106                        ; functions, if any, that the system performs in order to construct the string
  2107                        ; are implementation-defined.
  2108                        ;
  2109                        ; Input terminates when an implementation-defined line terminator is received.
  2110                        ; When input terminates, nothing is appended to the string, and the display is
  2111                        ; maintained in an implementation-defined way.
  2112                        ;
  2113                        ; +n2 is the length of the string stored at c-addr.
  2114                        ;
  2115                        ;   OVER + 1- OVER      -- sa ea a
  2116                        ;   BEGIN KEY           -- sa ea a c
  2117                        ;   DUP 0D <> WHILE
  2118                        ;     DUP 8 = OVER 127 = OR IF
  2119                        ;       DROP 1-
  2120                        ;       >R OVER R> UMAX
  2121                        ;       8 EMIT SPACE 8 EMIT
  2122                        ;     ELSE
  2123                        ;       DUP EMIT        -- sa ea a c
  2124                        ;       OVER C! 1+ OVER UMIN
  2125                        ;     THEN              -- sa ea a
  2126                        ;   REPEAT              -- sa ea a c
  2127                        ;   DROP NIP SWAP - ;
  2128                        
  2129 00:0FCD: 90 0F 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0FD1: 41 43 43 45 
       00:0FD5: 50 54 
  2130 00:0FD7: 20 45 14     ACCEPT:         jsr     DO_COLON
  2131 00:0FDA: A8 07                        dw      OVER
  2132 00:0FDC: FF 08                        dw      PLUS
  2133 00:0FDE: 5D 09                        dw      ONE_MINUS
  2134 00:0FE0: A8 07                        dw      OVER
  2135 00:0FE2: F9 17        ACCEPT_1:       dw      KEY
  2136 00:0FE4: 85 07                        dw      DUP
  2137 00:0FE6: 1B 16 0D 00                  dw      DO_LITERAL,$0D
  2138 00:0FEA: 17 0D                        dw      NOT_EQUAL
  2139 00:0FEC: D4 15 36 10                  dw      QUERY_BRANCH,ACCEPT_4
  2140 00:0FF0: 85 07                        dw      DUP
  2141 00:0FF2: 1B 16 08 00                  dw      DO_LITERAL,$08
  2142 00:0FF6: 30 0D                        dw      EQUAL
  2143 00:0FF8: A8 07                        dw      OVER
  2144 00:0FFA: 1B 16 7F 00                  dw      DO_LITERAL,$7f
  2145 00:0FFE: 30 0D                        dw      EQUAL
  2146 00:1000: EF 0D                        dw      OR
  2147 00:1002: D4 15 24 10                  dw      QUERY_BRANCH,ACCEPT_2
  2148 00:1006: 74 07                        dw      DROP
  2149 00:1008: 5D 09                        dw      ONE_MINUS
  2150 00:100A: 6D 08                        dw      TO_R
  Wed Apr 20 2016 11:57                                                                                                    Page 44


  2151 00:100C: A8 07                        dw      OVER
  2152 00:100E: A6 08                        dw      R_FROM
  2153 00:1010: 4E 0A                        dw      UMAX
  2154 00:1012: 1B 16 08 00                  dw      DO_LITERAL,8
  2155 00:1016: E3 17                        dw      EMIT
  2156 00:1018: 15 18                        dw      SPACE
  2157 00:101A: 1B 16 08 00                  dw      DO_LITERAL,8
  2158 00:101E: E3 17                        dw      EMIT
  2159 00:1020: B3 15 32 10                  dw      BRANCH,ACCEPT_3
  2160 00:1024: 85 07        ACCEPT_2:       dw      DUP
  2161 00:1026: E3 17                        dw      EMIT
  2162 00:1028: A8 07                        dw      OVER
  2163 00:102A: DB 05                        dw      C_STORE
  2164 00:102C: 4F 09                        dw      ONE_PLUS
  2165 00:102E: A8 07                        dw      OVER
  2166 00:1030: 62 0A                        dw      UMIN
  2167 00:1032: B3 15 E2 0F  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  2168 00:1036: 74 07        ACCEPT_4:       dw      DROP
  2169 00:1038: 9A 07                        dw      NIP
  2170 00:103A: FB 07                        dw      SWAP
  2171 00:103C: 15 09                        dw      MINUS
  2172 00:103E: BF 0E                        dw      EXIT
  2173                        
  2174                        ; DIGIT?
  2175                        ;
  2176                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  2177                        ;   DUP 140 > 107 AND -   30 -     but it works!
  2178                        ;   DUP BASE @ U< ;
  2179                        
  2180 00:1040: D0 0F 00 06                  HEADER  6,"DIGIT?",NORMAL
       00:1044: 44 49 47 49 
       00:1048: 54 3F 
  2181 00:104A: 20 45 14     DIGIT_QUERY:    jsr     DO_COLON
  2182 00:104D: 85 07                        dw      DUP
  2183 00:104F: 1B 16 39 00                  dw      DO_LITERAL,'9'
  2184 00:1053: 49 0D                        dw      GREATER
  2185 00:1055: 1B 16 00 01                  dw      DO_LITERAL,$100
  2186 00:1059: 96 0D                        dw      AND
  2187 00:105B: FF 08                        dw      PLUS
  2188 00:105D: 85 07                        dw      DUP
  2189 00:105F: 1B 16 40 01                  dw      DO_LITERAL,$140
  2190 00:1063: 49 0D                        dw      GREATER
  2191 00:1065: 1B 16 07 01                  dw      DO_LITERAL,$107
  2192 00:1069: 96 0D                        dw      AND
  2193 00:106B: 15 09                        dw      MINUS
  2194 00:106D: 1B 16 30 00                  dw      DO_LITERAL,'0'
  2195 00:1071: 15 09                        dw      MINUS
  2196 00:1073: 85 07                        dw      DUP
  2197 00:1075: 64 04                        dw      BASE
  2198 00:1077: B9 05                        dw      FETCH
  2199 00:1079: 6A 0D                        dw      U_LESS
  2200 00:107B: BF 0E                        dw      EXIT
  2201                        
  2202                        ; EVALUATE ( i*x c-addr u -- j*x )
  2203                        ;
  2204                        ; Save the current input source specification. Store minus-one (-1) in
  2205                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  2206                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  Wed Apr 20 2016 11:57                                                                                                    Page 45


  2207                        ; parse area is empty, restore the prior input source specification. Other
  2208                        ; stack effects are due to the words EVALUATEd.
  2209                        ;
  2210                        ;   >R >R SAVE-INPUT
  2211                        ;   -1 (SOURCE-ID) !
  2212                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  2213                        ;   INTERPRET
  2214                        ;   RESTORE-INPUT DROP
  2215                        
  2216 00:107D: 43 10 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:1081: 45 56 41 4C 
       00:1085: 55 41 54 45 
  2217 00:1089: 20 45 14     EVALUATE:       jsr     DO_COLON
  2218 00:108C: 6D 08                        dw      TO_R
  2219 00:108E: 6D 08                        dw      TO_R
  2220 00:1090: 15 12                        dw      SAVE_INPUT
  2221 00:1092: A6 08                        dw      R_FROM
  2222 00:1094: A6 08                        dw      R_FROM
  2223 00:1096: 0C 05                        dw      TRUE
  2224 00:1098: AA 04                        dw      SOURCEID
  2225 00:109A: 4B 05                        dw      STORE
  2226 00:109C: CE 04                        dw      ZERO
  2227 00:109E: 57 04                        dw      TO_IN
  2228 00:10A0: 4B 05                        dw      STORE
  2229 00:10A2: 99 04                        dw      LENGTH
  2230 00:10A4: 4B 05                        dw      STORE
  2231 00:10A6: 75 04                        dw      BUFFER
  2232 00:10A8: 4B 05                        dw      STORE
  2233 00:10AA: BF 10                        dw      INTERPRET
  2234 00:10AC: C6 11                        dw      RESTORE_INPUT
  2235 00:10AE: 74 07                        dw      DROP
  2236 00:10B0: BF 0E                        dw      EXIT
  2237                        
  2238                        ; INTERPRET ( -- )
  2239                        ;
  2240                        ;
  2241                        ;   BEGIN
  2242                        ;   BL WORD DUP C@ WHILE        -- textadr
  2243                        ;       FIND                    -- a 0/1/-1
  2244                        ;       ?DUP IF                 -- xt 1/-1
  2245                        ;           1+ STATE @ 0= OR    immed or interp?
  2246                        ;           IF EXECUTE ELSE , THEN
  2247                        ;       ELSE                    -- textadr
  2248                        ;           ?NUMBER
  2249                        ;           IF STATE @
  2250                        ;               IF POSTPONE LITERAL THEN     converted ok
  2251                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  2252                        ;           THEN
  2253                        ;       THEN
  2254                        ;   REPEAT DROP ;
  2255                        
  2256 00:10B2: 80 10 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:10B6: 49 4E 54 45 
       00:10BA: 52 50 52 45 
       00:10BE: 54 
  2257 00:10BF: 20 45 14     INTERPRET:      jsr     DO_COLON
  2258 00:10C2: E0 04        INTERPRET_1:    dw      BL
  2259 00:10C4: 8D 12                        dw      WORD
  Wed Apr 20 2016 11:57                                                                                                    Page 46


  2260 00:10C6: 85 07                        dw      DUP
  2261 00:10C8: 0C 06                        dw      C_FETCH
  2262 00:10CA: D4 15 16 11                  dw      QUERY_BRANCH,INTERPRET_7
  2263 00:10CE: 22 11                        dw      FIND
  2264 00:10D0: 48 07                        dw      QUERY_DUP
  2265 00:10D2: D4 15 F0 10                  dw      QUERY_BRANCH,INTERPRET_4
  2266 00:10D6: 4F 09                        dw      ONE_PLUS
  2267 00:10D8: B8 04                        dw      STATE
  2268 00:10DA: B9 05                        dw      FETCH
  2269 00:10DC: DF 0C                        dw      ZERO_EQUAL
  2270 00:10DE: EF 0D                        dw      OR
  2271 00:10E0: D4 15 EA 10                  dw      QUERY_BRANCH,INTERPRET_2
  2272 00:10E4: AE 0E                        dw      EXECUTE
  2273 00:10E6: B3 15 EC 10                  dw      BRANCH,INTERPRET_3
  2274 00:10EA: 79 05        INTERPRET_2:    dw      COMMA
  2275 00:10EC: B3 15 12 11  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  2276 00:10F0: 13 0F        INTERPRET_4:    dw      QUERY_NUMBER
  2277 00:10F2: D4 15 04 11                  dw      QUERY_BRANCH,INTERPRET_5
  2278 00:10F6: B8 04                        dw      STATE
  2279 00:10F8: B9 05                        dw      FETCH
  2280 00:10FA: D4 15 12 11                  dw      QUERY_BRANCH,INTERPRET_6
  2281 00:10FE: 0E 16                        dw      LITERAL
  2282 00:1100: B3 15 12 11                  dw      BRANCH,INTERPRET_6
  2283 00:1104: 9D 13        INTERPRET_5:    dw      COUNT
  2284 00:1106: 47 18                        dw      TYPE
  2285 00:1108: 1B 16 3F 00                  dw      DO_LITERAL,$3f
  2286 00:110C: E3 17                        dw      EMIT
  2287 00:110E: CA 17                        dw      CR
  2288 00:1110: 5C 0E                        dw      ABORT
  2289 00:1112: B3 15 C2 10  INTERPRET_6     dw      BRANCH,INTERPRET_1
  2290 00:1116: 74 07        INTERPRET_7:    dw      DROP
  2291 00:1118: BF 0E                        dw      EXIT
  2292                        
  2293                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  2294                        ;
  2295                        ; Find the definition named in the counted string at c-addr. If the definition
  2296                        ; is not found, return c-addr and zero. If the definition is found, return its
  2297                        ; execution token xt. If the definition is immediate, also return one (1),
  2298                        ; otherwise also return minus-one (-1). For a given string, the values returned
  2299                        ; by FIND while compiling may differ from those returned while not compiling.
  2300                        ;
  2301                        ;   LATEST @ BEGIN             -- a nfa
  2302                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  2303                        ;       S=                     -- a nfa f
  2304                        ;       DUP IF
  2305                        ;           DROP
  2306                        ;           NFA>LFA @ DUP      -- a link link
  2307                        ;       THEN
  2308                        ;   0= UNTIL                   -- a nfa  OR  a 0
  2309                        ;   DUP IF
  2310                        ;       NIP DUP NFA>CFA        -- nfa xt
  2311                        ;       SWAP IMMED?            -- xt iflag
  2312                        ;       0= 1 OR                -- xt 1/-1
  2313                        ;   THEN ;
  2314                        
  2315 00:111A: B5 10 00 04                  HEADER  4,"FIND",NORMAL
       00:111E: 46 49 4E 44 
  2316 00:1122: 20 45 14     FIND:           jsr     DO_COLON
  Wed Apr 20 2016 11:57                                                                                                    Page 47


  2317 00:1125: 94 04                        dw      LATEST
  2318 00:1127: B9 05                        dw      FETCH
  2319 00:1129: BF 06        FIND1:          dw      TWO_DUP
  2320 00:112B: A8 07                        dw      OVER
  2321 00:112D: 0C 06                        dw      C_FETCH
  2322 00:112F: 7A 06                        dw      CHAR_PLUS
  2323 00:1131: DD 11                        dw      S_EQUAL
  2324 00:1133: 85 07                        dw      DUP
  2325 00:1135: D4 15 41 11                  dw      QUERY_BRANCH,FIND2
  2326 00:1139: 74 07                        dw      DROP
  2327 00:113B: 73 11                        dw      NFA_TO_LFA
  2328 00:113D: B9 05                        dw      FETCH
  2329 00:113F: 85 07                        dw      DUP
  2330 00:1141: DF 0C        FIND2:          dw      ZERO_EQUAL
  2331 00:1143: D4 15 29 11                  dw      QUERY_BRANCH,FIND1
  2332 00:1147: 85 07                        dw      DUP
  2333 00:1149: D4 15 5F 11                  dw      QUERY_BRANCH,FIND3
  2334 00:114D: 9A 07                        dw      NIP
  2335 00:114F: 85 07                        dw      DUP
  2336 00:1151: 6A 11                        dw      NFA_TO_CFA
  2337 00:1153: FB 07                        dw      SWAP
  2338 00:1155: 61 11                        dw      IMMED_QUERY
  2339 00:1157: DF 0C                        dw      ZERO_EQUAL
  2340 00:1159: 1B 16 01 00                  dw      DO_LITERAL,1
  2341 00:115D: EF 0D                        dw      OR
  2342 00:115F: BF 0E        FIND3:          dw      EXIT
  2343                        
  2344                        ; IMMED? ( nfa -- f )
  2345                        
  2346                        ;               HEADER  6,"IMMED?",NORMAL
  2347 00:1161: 20 45 14     IMMED_QUERY:    jsr     DO_COLON
  2348 00:1164: 5D 09                        dw      ONE_MINUS
  2349 00:1166: 0C 06                        dw      C_FETCH
  2350 00:1168: BF 0E                        dw      EXIT
  2351                        
  2352                        ; NFA>CFA ( nfa -- cfa )
  2353                        
  2354                        ;               HEADER  7,"NFA>CFA",NORMAL
  2355 00:116A: 20 45 14     NFA_TO_CFA:     jsr     DO_COLON
  2356 00:116D: 9D 13                        dw      COUNT
  2357 00:116F: FF 08                        dw      PLUS
  2358 00:1171: BF 0E                        dw      EXIT
  2359                        
  2360                        ; NFA>LFA ( nfa -- lfa )
  2361                        
  2362                        ;               HEADER  7,"NFA>LFA",NORMAL
  2363 00:1173: 20 45 14     NFA_TO_LFA:     jsr     DO_COLON
  2364 00:1176: 1B 16 03 00                  dw      DO_LITERAL,3
  2365 00:117A: 15 09                        dw      MINUS
  2366 00:117C: BF 0E                        dw      EXIT
  2367                        
  2368                        ; REFILL ( -- flag )
  2369                        ;
  2370                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2371                        ; if successful.
  2372                        ;
  2373                        ; When the input source is the user input device, attempt to receive input into
  2374                        ; the terminal input buffer. If successful, make the result the input buffer,
  Wed Apr 20 2016 11:57                                                                                                    Page 48


  2375                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2376                        ; is considered successful. If there is no input available from the current
  2377                        ; input source, return false.
  2378                        ;
  2379                        ; When the input source is a string from EVALUATE, return false and perform no
  2380                        ; other action.
  2381                        ;
  2382                        ; In this implementation it is defined as:
  2383                        ;
  2384                        ;   SOURCE-ID 0= IF
  2385                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2386                        ;     LENGTH ! BUFFER !
  2387                        ;     0 >IN ! TRUE EXIT
  2388                        ;   THEN
  2389                        ;   FALSE
  2390                        
  2391 00:117E: 1D 11 00 06                  HEADER  6,"REFILL",NORMAL
       00:1182: 52 45 46 49 
       00:1186: 4C 4C 
  2392 00:1188: 20 45 14     REFILL:         jsr     DO_COLON
  2393 00:118B: 7C 12                        dw      SOURCE_ID
  2394 00:118D: DF 0C                        dw      ZERO_EQUAL
  2395 00:118F: D4 15 B1 11                  dw      QUERY_BRANCH,REFILL_1
  2396 00:1193: C4 04                        dw      TIB
  2397 00:1195: 85 07                        dw      DUP
  2398 00:1197: 49 04                        dw      HASH_TIB
  2399 00:1199: B9 05                        dw      FETCH
  2400 00:119B: D7 0F                        dw      ACCEPT
  2401 00:119D: 15 18                        dw      SPACE
  2402 00:119F: 99 04                        dw      LENGTH
  2403 00:11A1: 4B 05                        dw      STORE
  2404 00:11A3: 75 04                        dw      BUFFER
  2405 00:11A5: 4B 05                        dw      STORE
  2406 00:11A7: CE 04                        dw      ZERO
  2407 00:11A9: 57 04                        dw      TO_IN
  2408 00:11AB: 4B 05                        dw      STORE
  2409 00:11AD: 0C 05                        dw      TRUE
  2410 00:11AF: BF 0E                        dw      EXIT
  2411 00:11B1: F8 04        REFILL_1:       dw      FALSE
  2412 00:11B3: BF 0E                        dw      EXIT
  2413                        
  2414                        ; RESTORE-INPUT ( xn ... x1 n -- flag )
  2415                        ;
  2416                        ; Attempt to restore the input source specification to the state described by
  2417                        ; x1 through xn. flag is true if the input source specification cannot be so
  2418                        ; restored.
  2419                        ;
  2420                        ; An ambiguous condition exists if the input source represented by the
  2421                        ; arguments is not the same as the current input source.
  2422                        ;
  2423                        ; In this implementation it is defined as:
  2424                        ;
  2425                        ;   >IN ! (LENGTH) ! BUFFER !
  2426                        ;   SOURCEID !
  2427                        ;   TRUE
  2428                        
  2429 00:11B5: 81 11 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:11B9: 52 45 53 54 
  Wed Apr 20 2016 11:57                                                                                                    Page 49


       00:11BD: 4F 52 45 2D 
       00:11C1: 49 4E 50 55 
       00:11C5: 54 
  2430 00:11C6: 20 45 14     RESTORE_INPUT   jsr     DO_COLON
  2431 00:11C9: 57 04                        dw      TO_IN
  2432 00:11CB: 4B 05                        dw      STORE
  2433 00:11CD: 99 04                        dw      LENGTH
  2434 00:11CF: 4B 05                        dw      STORE
  2435 00:11D1: 75 04                        dw      BUFFER
  2436 00:11D3: 4B 05                        dw      STORE
  2437 00:11D5: AA 04                        dw      SOURCEID
  2438 00:11D7: 4B 05                        dw      STORE
  2439 00:11D9: 0C 05                        dw      TRUE
  2440 00:11DB: BF 0E                        dw      EXIT
  2441                        
  2442                        ; S= ( c-addr1 caddr2 u -- n)
  2443                        ;
  2444                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2445                        
  2446                        S_EQUAL:
  2447 00:11DD: 5A                           phy
  2448 00:11DE: A6 01                        ldx     <1                      ; Fetch maximum length
  2449 00:11E0: F0 14                        beq     S_EQUAL_3
  2450 00:11E2: A0 00 00                     ldy     #0
  2451 00:11E5: E2 20                        short_a
  2452                        S_EQUAL_1:
  2453 00:11E7: B1 05                        lda     (5),y                   ; Compare bytes
  2454 00:11E9: D1 03                        cmp     (3),y
  2455 00:11EB: D0 06                        bne     S_EQUAL_2
  2456 00:11ED: C8                           iny
  2457 00:11EE: CA                           dex                             ; End of strings?
  2458 00:11EF: D0 F6                        bne     S_EQUAL_1               ; No
  2459 00:11F1: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2460                        S_EQUAL_2:
  2461 00:11F3: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2462                        S_EQUAL_3:
  2463 00:11F6: C2 20                        long_a
  2464 00:11F8: 7B                           tdc                             ; Clean up the stack
  2465 00:11F9: 1A                           inc     a
  2466 00:11FA: 1A                           inc     a
  2467 00:11FB: 1A                           inc     a
  2468 00:11FC: 1A                           inc     a
  2469 00:11FD: 5B                           tcd
  2470 00:11FE: 86 01                        stx     <1                      ; Save the flag
  2471 00:1200: 7A                           ply
  2472 00:1201: BB C8 C8 7C                  CONTINUE
       00:1205: 00 00 
  2473                        
  2474                        ; SAVE-INPUT ( -- xn ... x1 n )
  2475                        ;
  2476                        ; x1 through xn describe the current state of the input source specification
  2477                        ; for later use by RESTORE-INPUT.
  2478                        
  2479 00:1207: B8 11 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:120B: 53 41 56 45 
       00:120F: 2D 49 4E 50 
       00:1213: 55 54 
  2480 00:1215: 20 45 14     SAVE_INPUT:     jsr     DO_COLON
  Wed Apr 20 2016 11:57                                                                                                    Page 50


  2481 00:1218: AA 04                        dw      SOURCEID
  2482 00:121A: B9 05                        dw      FETCH
  2483 00:121C: 75 04                        dw      BUFFER
  2484 00:121E: B9 05                        dw      FETCH
  2485 00:1220: 99 04                        dw      LENGTH
  2486 00:1222: B9 05                        dw      FETCH
  2487 00:1224: 57 04                        dw      TO_IN
  2488 00:1226: B9 05                        dw      FETCH
  2489 00:1228: BF 0E                        dw      EXIT
  2490                        
  2491                        ; SCAN ( c-addr n c == c-addr' n' )
  2492                        
  2493                        SCAN:
  2494                        SCAN_1:
  2495 00:122A: A5 03                        lda     <3                      ; Any data left to scan?
  2496 00:122C: F0 10                        beq     SCAN_2                  ; No.
  2497 00:122E: A5 01                        lda     <1                      ; Fetch and compare with scan
  2498 00:1230: E2 20                        short_a
  2499 00:1232: D2 05                        cmp     (5)
  2500 00:1234: C2 20                        long_a
  2501 00:1236: F0 06                        beq     SCAN_2
  2502 00:1238: E6 05                        inc     <5
  2503 00:123A: C6 03                        dec     <3
  2504 00:123C: 80 EC                        bra     SCAN_1
  2505                        SCAN_2:
  2506 00:123E: 4C 74 07                     jmp     DROP                    ; Drop the character
  2507                        
  2508                        ; SKIP ( c-addr n c == c-addr' n' )
  2509                        ;
  2510                        
  2511                        SKIP:
  2512 00:1241: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  2513 00:1243: F0 10                        beq     SKIP_2                  ; No.
  2514 00:1245: A5 01                        lda     <1                      ; Fetch and compare with skip
  2515 00:1247: E2 20                        short_a
  2516 00:1249: D2 05                        cmp     (5)
  2517 00:124B: C2 20                        long_a
  2518 00:124D: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2519 00:124F: E6 05                        inc     <5                      ; Bump data address
  2520 00:1251: C6 03                        dec     <3                      ; and update length
  2521 00:1253: 80 EC                        bra     SKIP_1                  ; And repeat
  2522                        SKIP_2:
  2523 00:1255: 4C 74 07                     jmp     DROP                    ; Drop the character
  2524                        
  2525                        ; SOURCE ( -- c-addr u )
  2526                        ;
  2527                        ; c-addr is the address of, and u is the number of characters in, the input
  2528                        ; buffer.
  2529                        ;
  2530                        ; In this implementation it is defined as
  2531                        ;
  2532                        ;   BUFFER @ LENGTH @
  2533                        
  2534 00:1258: 0A 12 00 06                  HEADER  6,"SOURCE",NORMAL
       00:125C: 53 4F 55 52 
       00:1260: 43 45 
  2535 00:1262: 20 45 14     SOURCE:         jsr     DO_COLON
  2536 00:1265: 75 04                        dw      BUFFER
  Wed Apr 20 2016 11:57                                                                                                    Page 51


  2537 00:1267: B9 05                        dw      FETCH
  2538 00:1269: 99 04                        dw      LENGTH
  2539 00:126B: B9 05                        dw      FETCH
  2540 00:126D: BF 0E                        dw      EXIT
  2541                        
  2542                        ; SOURCE-ID ( -- 0 | -1 )
  2543                        ;
  2544                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2545                        ; device.
  2546                        
  2547 00:126F: 5B 12 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:1273: 53 4F 55 52 
       00:1277: 43 45 2D 49 
       00:127B: 44 
  2548 00:127C: 20 45 14     SOURCE_ID:      jsr     DO_COLON
  2549 00:127F: AA 04                        dw      SOURCEID
  2550 00:1281: B9 05                        dw      FETCH
  2551 00:1283: BF 0E                        dw      EXIT
  2552                        
  2553                        ; WORD ( char <chars>ccc<char> -- c-addr )
  2554                        ;
  2555                        ; Skip leading delimiters. Parse characters ccc delimited by char. An
  2556                        ; ambiguous condition exists if the length of the parsed string is greater
  2557                        ; than the implementation-defined length of a counted string.
  2558                        ;
  2559                        ; c-addr is the address of a transient region containing the parsed word as
  2560                        ; a counted string. If the parse area was empty or contained no characters
  2561                        ; other than the delimiter, the resulting string has a zero length. A space,
  2562                        ; not included in the length, follows the string. A program may replace
  2563                        ; characters within the string.
  2564                        ;
  2565                        ; In this implementation it is defined as:
  2566                        ;
  2567                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2568                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2569                        ;   OVER >R  ROT SCAN           -- adr" n"
  2570                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2571                        ;   R> R> ROT -   >IN +!        update >IN offset
  2572                        ;   TUCK -                      -- adr' N
  2573                        ;   HERE >counted               --
  2574                        ;   HERE                        -- a
  2575                        ;   BL OVER COUNT + C! ;    append trailing blank
  2576                        
  2577 00:1285: 72 12 00 04                  HEADER  4,"WORD",NORMAL
       00:1289: 57 4F 52 44 
  2578 00:128D: 20 45 14     WORD:           jsr     DO_COLON
  2579 00:1290: 85 07                        dw      DUP
  2580 00:1292: 62 12                        dw      SOURCE
  2581 00:1294: 57 04                        dw      TO_IN
  2582 00:1296: B9 05                        dw      FETCH
  2583 00:1298: F1 12                        dw      SLASH_STRING
  2584 00:129A: 85 07                        dw      DUP
  2585 00:129C: 6D 08                        dw      TO_R
  2586 00:129E: E1 07                        dw      ROT
  2587 00:12A0: 41 12                        dw      SKIP
  2588 00:12A2: A8 07                        dw      OVER
  2589 00:12A4: 6D 08                        dw      TO_R
  2590 00:12A6: E1 07                        dw      ROT
  Wed Apr 20 2016 11:57                                                                                                    Page 52


  2591 00:12A8: 2A 12                        dw      SCAN
  2592 00:12AA: 85 07                        dw      DUP
  2593 00:12AC: D4 15 B2 12                  dw      QUERY_BRANCH,WORD_1
  2594 00:12B0: 8B 06                        dw      CHAR_MINUS
  2595 00:12B2: A6 08        WORD_1:         dw      R_FROM
  2596 00:12B4: A6 08                        dw      R_FROM
  2597 00:12B6: E1 07                        dw      ROT
  2598 00:12B8: 15 09                        dw      MINUS
  2599 00:12BA: 57 04                        dw      TO_IN
  2600 00:12BC: 61 05                        dw      PLUS_STORE
  2601 00:12BE: 11 08                        dw      TUCK
  2602 00:12C0: 15 09                        dw      MINUS
  2603 00:12C2: 24 06                        dw      HERE
  2604 00:12C4: 7E 0F                        dw      TO_COUNTED
  2605 00:12C6: 24 06                        dw      HERE
  2606 00:12C8: E0 04                        dw      BL
  2607 00:12CA: A8 07                        dw      OVER
  2608 00:12CC: 9D 13                        dw      COUNT
  2609 00:12CE: FF 08                        dw      PLUS
  2610 00:12D0: DB 05                        dw      C_STORE
  2611 00:12D2: BF 0E                        dw      EXIT
  2612                        
  2613                        ;===============================================================================
  2614                        ; String Words
  2615                        ;-------------------------------------------------------------------------------
  2616                        
  2617                        ; -TRAILING ( c-addr u1 -- c-addr u2 )
  2618                        ;
  2619                        ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
  2620                        ; the end of the character string specified by c-addr u1. If u1 is zero or the
  2621                        ; entire string consists of spaces, u2 is zero.
  2622                        
  2623 00:12D4: 88 12 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:12D8: 2D 54 52 41 
       00:12DC: 49 4C 49 4E 
       00:12E0: 47 
  2624 00:12E1: 20 45 14     DASH_TRAILING:  jsr     DO_COLON
  2625                        ; TODO
  2626 00:12E4: BF 0E                        dw      EXIT
  2627                        
  2628                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2629                        ;
  2630                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2631                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2632                        ; characters and is u1 minus n characters long.
  2633                        ;
  2634                        ;   ROT OVER + ROT ROT -
  2635                        
  2636 00:12E6: D7 12 00 07                  HEADER  7,"/STRING",NORMAL
       00:12EA: 2F 53 54 52 
       00:12EE: 49 4E 47 
  2637 00:12F1: 20 45 14     SLASH_STRING:   jsr     DO_COLON
  2638 00:12F4: E1 07                        dw      ROT
  2639 00:12F6: A8 07                        dw      OVER
  2640 00:12F8: FF 08                        dw      PLUS
  2641 00:12FA: E1 07                        dw      ROT
  2642 00:12FC: E1 07                        dw      ROT
  2643 00:12FE: 15 09                        dw      MINUS
  Wed Apr 20 2016 11:57                                                                                                    Page 53


  2644 00:1300: BF 0E                        dw      EXIT
  2645                        
  2646                        ; BLANK ( c-addr u -- )
  2647                        ;
  2648                        ; If u is greater than zero, store the character value for space in u
  2649                        ; consecutive character positions beginning at c-addr.
  2650                        ;
  2651                        ; In this implementation it is defined as
  2652                        ;
  2653                        ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
  2654                        
  2655 00:1302: E9 12 00 05                  HEADER  5,"BLANK",NORMAL
       00:1306: 42 4C 41 4E 
       00:130A: 4B 
  2656 00:130B: 20 45 14     BLANK:          jsr     DO_COLON
  2657 00:130E: 48 07                        dw      QUERY_DUP
  2658 00:1310: D4 15 28 13                  dw      QUERY_BRANCH,BLANK_2
  2659 00:1314: A8 07                        dw      OVER
  2660 00:1316: FF 08                        dw      PLUS
  2661 00:1318: FB 07                        dw      SWAP
  2662 00:131A: 82 15                        dw      DO_DO
  2663 00:131C: E0 04        BLANK_1:        dw      BL
  2664 00:131E: 7F 08                        dw      I
  2665 00:1320: DB 05                        dw      C_STORE
  2666 00:1322: 41 16 1C 13                  dw      DO_LOOP,BLANK_1
  2667 00:1326: BF 0E                        dw      EXIT
  2668 00:1328: 74 07        BLANK_2:        dw      DROP
  2669 00:132A: BF 0E                        dw      EXIT
  2670                        
  2671                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2672                        ;
  2673                        ; If u is greater than zero, copy u consecutive characters from the data space
  2674                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2675                        ; character from lower addresses to higher addresses.
  2676                        
  2677 00:132C: 05 13 00 05                  HEADER  5,"CMOVE",NORMAL
       00:1330: 43 4D 4F 56 
       00:1334: 45 
  2678                        CMOVE:
  2679 00:1335: 5A                           phy
  2680 00:1336: A6 01                        ldx     <1                      ; Any characters to move?
  2681 00:1338: F0 0F                        beq     CMOVE_2                 ; No
  2682 00:133A: A0 00 00                     ldy     #0
  2683 00:133D: E2 20                        short_a
  2684                        CMOVE_1:                                        ; Transfer a byte
  2685 00:133F: B1 05                        lda     (5),y
  2686 00:1341: 91 03                        sta     (3),y
  2687 00:1343: C8                           iny
  2688 00:1344: CA                           dex                             ; Decrement count
  2689 00:1345: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2690 00:1347: C2 20                        long_a
  2691                        CMOVE_2:
  2692 00:1349: 7B                           tdc                             ; Clean up the stack
  2693 00:134A: 18                           clc
  2694 00:134B: 69 06 00                     adc     #6
  2695 00:134E: 5B                           tcd
  2696 00:134F: 7A                           ply
  2697 00:1350: BB C8 C8 7C                  CONTINUE                        ; Done
  Wed Apr 20 2016 11:57                                                                                                    Page 54


       00:1354: 00 00 
  2698                        
  2699                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  2700                        ;
  2701                        ; If u is greater than zero, copy u consecutive characters from the data space
  2702                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2703                        ; character from higher addresses to lower addresses.
  2704                        
  2705 00:1356: 2F 13 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:135A: 43 4D 4F 56 
       00:135E: 45 3E 
  2706                        CMOVE_GREATER:
  2707 00:1360: 5A                           phy
  2708 00:1361: A6 01                        ldx     <1                      ; Any characters to move?
  2709 00:1363: F0 0E                        beq     CMOVE_GT_2              ; No.
  2710 00:1365: A4 01                        ldy     <1
  2711 00:1367: E2 20                        short_a
  2712                        CMOVE_GT_1:
  2713 00:1369: 88                           dey                             ; Transfer a byte
  2714 00:136A: B1 05                        lda     (5),y
  2715 00:136C: 91 03                        sta     (3),y
  2716 00:136E: CA                           dex                             ; Decrement length
  2717 00:136F: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2718 00:1371: C2 20                        long_a
  2719                        CMOVE_GT_2:
  2720 00:1373: 7B                           tdc                             ; Clean up the stack
  2721 00:1374: 18                           clc
  2722 00:1375: 69 06 00                     adc     #6
  2723 00:1378: 5B                           tcd
  2724 00:1379: 7A           		ply
  2725 00:137A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:137E: 00 00 
  2726                        
  2727                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2728                        ;
  2729                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2730                        ; u2. The strings are compared, beginning at the given addresses, character by
  2731                        ; character, up to the length of the shorter string or until a difference is
  2732                        ; found. If the two strings are identical, n is zero. If the two strings are
  2733                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2734                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2735                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2736                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2737                        ; numeric value than the corresponding character in the string specified by
  2738                        ; c-addr2 u2 and one (1) otherwise.
  2739                        
  2740 00:1380: 59 13 00 07                  HEADER  7,"COMPARE",NORMAL
       00:1384: 43 4F 4D 50 
       00:1388: 41 52 45 
  2741 00:138B: 20 45 14     COMPARE:        jsr     DO_COLON
  2742                        ; TODO
  2743 00:138E: BB C8 C8 7C                  CONTINUE
       00:1392: 00 00 
  2744                        
  2745                        ; COUNT ( c-addr1 -- c-addr2 u )
  2746                        ;
  2747                        ; Return the character string specification for the counted string stored at
  2748                        ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
  Wed Apr 20 2016 11:57                                                                                                    Page 55


  2749                        ; the contents of the character at c-addr1, which is the length in characters
  2750                        ; of the string at c-addr2.
  2751                        ;
  2752                        ; In this implementation it is defined as
  2753                        ;
  2754                        ;   DUP CHAR+ SWAP C@
  2755                        
  2756 00:1394: 83 13 00 05                  HEADER  5,"COUNT",NORMAL
       00:1398: 43 4F 55 4E 
       00:139C: 54 
  2757 00:139D: 20 45 14     COUNT:          jsr     DO_COLON
  2758 00:13A0: 85 07                        dw      DUP
  2759 00:13A2: 7A 06                        dw      CHAR_PLUS
  2760 00:13A4: FB 07                        dw      SWAP
  2761 00:13A6: 0C 06                        dw      C_FETCH
  2762 00:13A8: BF 0E                        dw      EXIT
  2763                        
  2764                        ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
  2765                        ;
  2766                        ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
  2767                        ; u2. If flag is true, a match was found at c-addr3 with u3 characters
  2768                        ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
  2769                        ; is u1.
  2770                        
  2771 00:13AA: 97 13 00 06                  HEADER  6,"SEARCH",NORMAL
       00:13AE: 53 45 41 52 
       00:13B2: 43 48 
  2772 00:13B4: 20 45 14     SEARCH:         jsr     DO_COLON
  2773                        ; TODO
  2774 00:13B7: BB C8 C8 7C                  CONTINUE
       00:13BB: 00 00 
  2775                        
  2776                        ;===============================================================================
  2777                        ; Compiling Words
  2778                        ;-------------------------------------------------------------------------------
  2779                        
  2780                        ; ( ( -- )
  2781                        ;
  2782                        ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
  2783                        ;
  2784                        ; The number of characters in ccc may be zero to the number of characters in the
  2785                        ; parse area.
  2786                        ;
  2787                        ; In this implementation it is defined as:
  2788                        ;
  2789                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2790                        
  2791 00:13BD: AD 13 80 01                  HEADER  1,"(",IMMEDIATE
       00:13C1: 28 
  2792 00:13C2: 20 45 14                     jsr     DO_COLON
  2793 00:13C5: 1B 16 29 00                  dw      DO_LITERAL,')'
  2794 00:13C9: 8D 12                        dw      WORD
  2795 00:13CB: 74 07                        dw      DROP
  2796 00:13CD: BF 0E                        dw      EXIT
  2797                        
  2798                        ; .(
  2799                        
  2800 00:13CF: C0 13 80 02                  HEADER  2,".(",IMMEDIATE
  Wed Apr 20 2016 11:57                                                                                                    Page 56


       00:13D3: 2E 28 
  2801 00:13D5: 20 45 14     DOT_PAREN:      jsr     DO_COLON
  2802 00:13D8: 1B 16 29 00                  dw      DO_LITERAL,')'
  2803 00:13DC: 8D 12                        dw      WORD
  2804 00:13DE: 9D 13                        dw      COUNT
  2805 00:13E0: 47 18                        dw      TYPE
  2806 00:13E2: BF 0E                        dw      EXIT
  2807                        
  2808                        ; ." ( -- )
  2809                        
  2810 00:13E4: D2 13 80                     LINK    IMMEDIATE
  2811 00:13E7: 02 2E 22                     db      2,".",'"'
  2812 00:13EA: 20 45 14     DOT_QUOTE:      jsr     DO_COLON
  2813 00:13ED: B1 16                        dw      S_QUOTE
  2814 00:13EF: 1B 16 47 18                  dw      DO_LITERAL,TYPE
  2815 00:13F3: 79 05                        dw      COMMA
  2816 00:13F5: BF 0E                        dw      EXIT
  2817                        
  2818                        
  2819                        ; +LOOP ( -- )
  2820                        
  2821 00:13F7: E7 13 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:13FB: 2B 4C 4F 4F 
       00:13FF: 50 
  2822 00:1400: 20 45 14     PLUS_LOOP:      jsr     DO_COLON
  2823 00:1403: 1B 16 0D 14                  dw      DO_LITERAL,DO_PLUS_LOOP
  2824 00:1407: 79 05                        dw      COMMA
  2825 00:1409: 79 05                        dw      COMMA
  2826 00:140B: BF 0E                        dw      EXIT
  2827                        
  2828                        DO_PLUS_LOOP:
  2829 00:140D: A6 01                        ldx     <1                      ; Fetch increment
  2830 00:140F: 7B                           tdc                             ; And drop
  2831 00:1410: 1A                           inc     a
  2832 00:1411: 1A                           inc     a
  2833 00:1412: 5B                           tcd
  2834 00:1413: 18                           clc                             ; Add to loop counter
  2835 00:1414: 8A                           txa
  2836 00:1415: 63 01                        adc     1,s
  2837 00:1417: 83 01                        sta     1,s
  2838 00:1419: C3 03                        cmp     3,s                     ; Reached limit?
  2839 00:141B: B0 0A                        bcs     DO_PLOOP_END            ; Yes
  2840 00:141D: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2841 00:1420: A8                           tay
  2842 00:1421: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1425: 00 00 
  2843                        
  2844 00:1427: C8           DO_PLOOP_END:   iny                             ; Skip over address
  2845 00:1428: C8                           iny
  2846 00:1429: 68                           pla                             ; Drop loop variables
  2847 00:142A: 68                           pla
  2848 00:142B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:142F: 00 00 
  2849                        
  2850                        ; : ( -- )
  2851                        
  2852 00:1431: FA 13 00 01                  HEADER  1,":",NORMAL
       00:1435: 3A 
  Wed Apr 20 2016 11:57                                                                                                    Page 57


  2853 00:1436: 20 45 14     COLON:          jsr     DO_COLON
  2854 00:1439: 84 0E                        dw      CREATE
  2855 00:143B: 1B 16 45 14                  dw      DO_LITERAL,DO_COLON
  2856 00:143F: 6D 0E                        dw      BUILD
  2857 00:1441: B7 17                        dw      RIGHT_BRACKET
  2858 00:1443: BF 0E                        dw      EXIT
  2859                        
  2860                        DO_COLON:
  2861 00:1445: FA                           plx                             ; Pull new word IP-1
  2862 00:1446: 5A                           phy                             ; Save the old IP
  2863 00:1447: E8                           inx                             ; Work out new IP
  2864 00:1448: 9B                           txy
  2865 00:1449: BB C8 C8 7C                  CONTINUE                        ; Done
       00:144D: 00 00 
  2866                        
  2867                        ; :NONAME ( -- xt )
  2868                        
  2869 00:144F: 34 14 00 07                  HEADER  7,":NONAME",NORMAL
       00:1453: 3A 4E 4F 4E 
       00:1457: 41 4D 45 
  2870 00:145A: 20 45 14     NONAME:         jsr     DO_COLON
  2871 00:145D: 24 06                        dw      HERE
  2872 00:145F: 1B 16 45 14                  dw      DO_LITERAL,DO_COLON
  2873 00:1463: 6D 0E                        dw      BUILD
  2874 00:1465: B7 17                        dw      RIGHT_BRACKET
  2875 00:1467: BF 0E                        dw      EXIT
  2876                        
  2877                        ; ; ( -- )
  2878                        
  2879 00:1469: 52 14 80                     LINK    IMMEDIATE
  2880 00:146C: 01 3B                        db      1,";"
  2881 00:146E: 20 45 14     SEMICOLON:      jsr     DO_COLON
  2882 00:1471: 1B 16 BF 0E                  dw      DO_LITERAL,EXIT
  2883 00:1475: 79 05                        dw      COMMA
  2884 00:1477: 95 17                        dw      LEFT_BRACKET
  2885 00:1479: BF 0E                        dw      EXIT
  2886                        
  2887                        ; 2CONSTANT ( x <spaces>name -- )
  2888                        ;
  2889                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2890                        ; definition for name with the execution semantics defined below.
  2891                        
  2892 00:147B: 6C 14 00 09                  HEADER  9,"2CONSTANT",NORMAL
       00:147F: 32 43 4F 4E 
       00:1483: 53 54 41 4E 
       00:1487: 54 
  2893 00:1488: 20 45 14     TWO_CONSTANT:   jsr     DO_COLON
  2894 00:148B: 84 0E                        dw      CREATE
  2895 00:148D: 1B 16 99 14                  dw      DO_LITERAL,DO_TWO_CONSTANT
  2896 00:1491: 6D 0E                        dw      BUILD
  2897 00:1493: 79 05                        dw      COMMA
  2898 00:1495: 79 05                        dw      COMMA
  2899 00:1497: BF 0E                        dw      EXIT; AGAIN ( -- )
  2900                        
  2901                        DO_TWO_CONSTANT:
  2902 00:1499: FA                           plx                             ; Get return address
  2903 00:149A: 7B                           tdc                             ; Create space on stack
  2904 00:149B: 3A                           dec     a
  Wed Apr 20 2016 11:57                                                                                                    Page 58


  2905 00:149C: 3A                           dec     a
  2906 00:149D: 3A                           dec     a
  2907 00:149E: 3A                           dec     a
  2908 00:149F: 5B                           tcd
  2909 00:14A0: BD 01 00                     lda     !1,x                    ; Transfer the value
  2910 00:14A3: 85 01                        sta     <1
  2911 00:14A5: BD 03 00                     lda     !3,x
  2912 00:14A8: 85 03                        sta     <3
  2913 00:14AA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14AE: 00 00 
  2914                        
  2915                        ; 2LITERAL
  2916                        
  2917 00:14B0: 7E 14 80 08                  HEADER  8,"2LITERAL",IMMEDIATE
       00:14B4: 32 4C 49 54 
       00:14B8: 45 52 41 4C 
  2918 00:14BC: 20 45 14     TWO_LITERAL:    jsr     DO_COLON
  2919 00:14BF: 1B 16 CB 14                  dw      DO_LITERAL,DO_TWO_LITERAL
  2920 00:14C3: 79 05                        dw      COMMA
  2921 00:14C5: 79 05                        dw      COMMA
  2922 00:14C7: 79 05                        dw      COMMA
  2923 00:14C9: BF 0E                        dw      EXIT
  2924                        
  2925                        DO_TWO_LITERAL:
  2926 00:14CB: 7B                           tdc                             ; Make room on stack
  2927 00:14CC: 3A                           dec     a
  2928 00:14CD: 3A                           dec     a
  2929 00:14CE: 3A                           dec     a
  2930 00:14CF: 3A                           dec     a
  2931 00:14D0: 5B                           tcd
  2932 00:14D1: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  2933 00:14D4: 85 01                        sta     <1
  2934 00:14D6: B9 02 00                     lda     !2,y
  2935 00:14D9: 85 03                        sta     <3
  2936 00:14DB: C8                           iny                             ; Bump IP
  2937 00:14DC: C8                           iny
  2938 00:14DD: C8                           iny
  2939 00:14DE: C8                           iny
  2940 00:14DF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:14E3: 00 00 
  2941                        
  2942                        ; 2VARIABLE
  2943                        
  2944 00:14E5: B3 14 80 09                  HEADER  9,"2VARIABLE",IMMEDIATE
       00:14E9: 32 56 41 52 
       00:14ED: 49 41 42 4C 
       00:14F1: 45 
  2945 00:14F2: 20 45 14     TWO_VARIABLE:   jsr     DO_COLON
  2946 00:14F5: 84 0E                        dw      CREATE
  2947 00:14F7: 1B 16 5A 17                  dw      DO_LITERAL,DO_VARIABLE
  2948 00:14FB: 6D 0E                        dw      BUILD
  2949 00:14FD: 1B 16 02 00                  dw      DO_LITERAL,2
  2950 00:1501: 69 06                        dw      CELLS
  2951 00:1503: CC 05                        dw      ALLOT
  2952 00:1505: BF 0E                        dw      EXIT
  2953                        
  2954                        ; ABORT" ( -- )
  2955                        
  Wed Apr 20 2016 11:57                                                                                                    Page 59


  2956 00:1507: E8 14 80                     LINK    IMMEDIATE
  2957 00:150A: 06 41 42 4F                  db      6,"ABORT",'"'
       00:150E: 52 54 22 
  2958 00:1511: 20 45 14     ABORT_QUOTE:    jsr     DO_COLON
  2959 00:1514: B1 16                        dw      S_QUOTE
  2960 00:1516: 1B 16 42 0E                  dw      DO_LITERAL,QUERY_ABORT
  2961 00:151A: 79 05                        dw      COMMA
  2962 00:151C: BF 0E                        dw      EXIT
  2963                        
  2964                        ; AGAIN ( -- )
  2965 00:151E: 0A 15 80 05                  HEADER  5,"AGAIN",IMMEDIATE
       00:1522: 41 47 41 49 
       00:1526: 4E 
  2966 00:1527: 20 45 14     AGAIN:          jsr     DO_COLON
  2967 00:152A: 1B 16 B3 15                  dw      DO_LITERAL,BRANCH
  2968 00:152E: 79 05                        dw      COMMA
  2969 00:1530: 79 05                        dw      COMMA
  2970 00:1532: BF 0E                        dw      EXIT
  2971                        
  2972                        ; BEGIN ( -- )
  2973                        
  2974 00:1534: 21 15 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:1538: 42 45 47 49 
       00:153C: 4E 
  2975 00:153D: 20 45 14     BEGIN:          jsr     DO_COLON
  2976 00:1540: 24 06                        dw      HERE
  2977 00:1542: BF 0E                        dw      EXIT
  2978                        
  2979                        ; CONSTANT ( x <spaces>name -- )
  2980                        ;
  2981                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2982                        ; definition for name with the execution semantics defined below.
  2983                        
  2984 00:1544: 37 15 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:1548: 43 4F 4E 53 
       00:154C: 54 41 4E 54 
  2985 00:1550: 20 45 14     CONSTANT:       jsr     DO_COLON
  2986 00:1553: 84 0E                        dw      CREATE
  2987 00:1555: 1B 16 5F 15                  dw      DO_LITERAL,DO_CONSTANT
  2988 00:1559: 6D 0E                        dw      BUILD
  2989 00:155B: 79 05                        dw      COMMA
  2990 00:155D: BF 0E                        dw      EXIT
  2991                        
  2992                        DO_CONSTANT:
  2993 00:155F: FA                           plx                             ; Get return address
  2994 00:1560: 7B                           tdc                             ; Create space on stack
  2995 00:1561: 3A                           dec     a
  2996 00:1562: 3A                           dec     a
  2997 00:1563: 5B                           tcd
  2998 00:1564: BD 01 00                     lda     !1,x                    ; Transfer the value
  2999 00:1567: 85 01                        sta     <1
  3000 00:1569: BB C8 C8 7C                  CONTINUE                        ; Done
       00:156D: 00 00 
  3001                        
  3002                        ; DO ( -- )
  3003                        
  3004 00:156F: 47 15 80 02                  HEADER  2,"DO",IMMEDIATE
       00:1573: 44 4F 
  Wed Apr 20 2016 11:57                                                                                                    Page 60


  3005 00:1575: 20 45 14     DO:             jsr     DO_COLON
  3006 00:1578: 1B 16 82 15                  dw      DO_LITERAL,DO_DO
  3007 00:157C: 79 05                        dw      COMMA
  3008 00:157E: 24 06                        dw      HERE
  3009 00:1580: BF 0E                        dw      EXIT
  3010                        
  3011                        DO_DO:
  3012 00:1582: A5 03                        lda     <3
  3013 00:1584: 48                           pha
  3014 00:1585: A5 01                        lda     <1
  3015 00:1587: 48                           pha
  3016 00:1588: 7B                           tdc
  3017 00:1589: 1A                           inc     a
  3018 00:158A: 1A                           inc     a
  3019 00:158B: 1A                           inc     a
  3020 00:158C: 1A                           inc     a
  3021 00:158D: 5B                           tcd
  3022 00:158E: BB C8 C8 7C                  CONTINUE
       00:1592: 00 00 
  3023                        
  3024                        ; ELSE ( -- )
  3025                        
  3026 00:1594: 72 15 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:1598: 45 4C 53 45 
  3027 00:159C: 20 45 14     ELSE:           jsr     DO_COLON
  3028 00:159F: 1B 16 B3 15                  dw      DO_LITERAL,BRANCH
  3029 00:15A3: 79 05                        dw      COMMA
  3030 00:15A5: 24 06                        dw      HERE
  3031 00:15A7: CE 04                        dw      ZERO
  3032 00:15A9: 79 05                        dw      COMMA
  3033 00:15AB: 24 06                        dw      HERE
  3034 00:15AD: FB 07                        dw      SWAP
  3035 00:15AF: 4B 05                        dw      STORE
  3036 00:15B1: BF 0E                        dw      EXIT
  3037                        
  3038                        BRANCH:
  3039 00:15B3: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  3040 00:15B6: A8                           tay
  3041 00:15B7: BB C8 C8 7C                  CONTINUE                        ; Done
       00:15BB: 00 00 
  3042                        
  3043                        ; IF ( -- )
  3044                        
  3045 00:15BD: 97 15 80 02                  HEADER  2,"IF",IMMEDIATE
       00:15C1: 49 46 
  3046 00:15C3: 20 45 14     IF:             jsr     DO_COLON
  3047 00:15C6: 1B 16 D4 15                  dw      DO_LITERAL,QUERY_BRANCH
  3048 00:15CA: 79 05                        dw      COMMA
  3049 00:15CC: 24 06                        dw      HERE
  3050 00:15CE: CE 04                        dw      ZERO
  3051 00:15D0: 79 05                        dw      COMMA
  3052 00:15D2: BF 0E                        dw      EXIT
  3053                        
  3054                        QUERY_BRANCH:
  3055 00:15D4: A6 01                        ldx     <1                      ; Pull the top of stack value
  3056 00:15D6: 7B                           tdc
  3057 00:15D7: 1A                           inc     a                       ; Drop top item
  3058 00:15D8: 1A                           inc     a
  Wed Apr 20 2016 11:57                                                                                                    Page 61


  3059 00:15D9: 5B                           tcd
  3060 00:15DA: 8A                           txa
  3061 00:15DB: F0 D6                        beq     BRANCH                  ; Branch if top was zero
  3062 00:15DD: C8                           iny                             ; Otherwise skip address
  3063 00:15DE: C8                           iny
  3064 00:15DF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:15E3: 00 00 
  3065                        
  3066                        ; IMMEDIATE ( -- )
  3067                        
  3068 00:15E5: C0 15 80 09                  HEADER  9,"IMMEDIATE",IMMEDIATE
       00:15E9: 49 4D 4D 45 
       00:15ED: 44 49 41 54 
       00:15F1: 45 
  3069 00:15F2: 20 45 14                     jsr     DO_COLON
  3070 00:15F5: 1B 16 80 00                  dw      DO_LITERAL,IMMEDIATE
  3071 00:15F9: 94 04                        dw      LATEST
  3072 00:15FB: B9 05                        dw      FETCH
  3073 00:15FD: 5D 09                        dw      ONE_MINUS
  3074 00:15FF: DB 05                        dw      C_STORE
  3075 00:1601: BF 0E                        dw      EXIT
  3076                        
  3077                        ; LITERAL ( x -- )
  3078                        ;
  3079                        ; Append the run-time semantics given below to the current definition.
  3080                        
  3081 00:1603: E8 15 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:1607: 4C 49 54 45 
       00:160B: 52 41 4C 
  3082 00:160E: 20 45 14     LITERAL:        jsr     DO_COLON
  3083 00:1611: 1B 16 1B 16                  dw      DO_LITERAL,DO_LITERAL
  3084 00:1615: 79 05                        dw      COMMA
  3085 00:1617: 79 05                        dw      COMMA
  3086 00:1619: BF 0E                        dw      EXIT
  3087                        
  3088                        DO_LITERAL:
  3089 00:161B: 7B                           tdc                             ; Make room on stack
  3090 00:161C: 3A                           dec     a
  3091 00:161D: 3A                           dec     a
  3092 00:161E: 5B                           tcd
  3093 00:161F: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  3094 00:1622: 85 01                        sta     <1
  3095 00:1624: C8                           iny
  3096 00:1625: C8                           iny
  3097 00:1626: BB C8 C8 7C                  CONTINUE                        ; Done
       00:162A: 00 00 
  3098                        
  3099                        ; LOOP
  3100                        
  3101 00:162C: 06 16 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:1630: 4C 4F 4F 50 
  3102 00:1634: 20 45 14     LOOP:           jsr     DO_COLON
  3103 00:1637: 1B 16 41 16                  dw      DO_LITERAL,DO_LOOP
  3104 00:163B: 79 05                        dw      COMMA
  3105 00:163D: 79 05                        dw      COMMA
  3106 00:163F: BF 0E                        dw      EXIT
  3107                        
  3108                        ; (LOOP)
  Wed Apr 20 2016 11:57                                                                                                    Page 62


  3109                        
  3110                        ;               HEADER  6,"(LOOP)",NORMAL
  3111                        DO_LOOP
  3112 00:1641: A3 01                        lda     1,s                     ; Add one to loop counter
  3113 00:1643: 1A                           inc     a
  3114 00:1644: 83 01                        sta     1,s
  3115 00:1646: C3 03                        cmp     3,s                     ; Reached limit?
  3116 00:1648: B0 0A                        bcs     DO_LOOP_END             ; Yes
  3117 00:164A: B9 00 00                     lda     !0,y                    ; No, branch back to start
  3118 00:164D: A8                           tay
  3119 00:164E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1652: 00 00 
  3120                        
  3121 00:1654: C8           DO_LOOP_END:    iny                             ; Skip over address
  3122 00:1655: C8                           iny
  3123 00:1656: 68                           pla                             ; Drop loop variables
  3124 00:1657: 68                           pla
  3125 00:1658: BB C8 C8 7C                  CONTINUE                        ; Done
       00:165C: 00 00 
  3126                        
  3127                        ; POSTPONE
  3128                        
  3129                        ;   BL WORD FIND
  3130                        ;   DUP 0= ABORT" ?"
  3131                        ;   0< IF   -- xt       non immed: add code to current
  3132                        ;                       def'n to compile xt later.
  3133                        ;       ['] LIT ,XT  ,  add "LIT,xt,COMMAXT"
  3134                        ;       ['] ,XT ,XT     to current definition
  3135                        ;   ELSE  ,XT      immed: compile into cur. def'n
  3136                        ;   THEN ; IMMEDIATE
  3137                        
  3138 00:165E: 2F 16 80 08                  HEADER  8,"POSTPONE",IMMEDIATE
       00:1662: 50 4F 53 54 
       00:1666: 50 4F 4E 45 
  3139 00:166A: 20 45 14     POSTPONE:       jsr     DO_COLON
  3140 00:166D: E0 04                        dw      BL
  3141 00:166F: 8D 12                        dw      WORD
  3142 00:1671: 22 11                        dw      FIND
  3143 00:1673: 85 07                        dw      DUP
  3144 00:1675: DF 0C                        dw      ZERO_EQUAL
  3145 00:1677: CA 16                        dw      DO_S_QUOTE
  3146 00:1679: 01 3F                        db      1,"?"
  3147 00:167B: 42 0E                        dw      QUERY_ABORT
  3148 00:167D: B6 0C                        dw      ZERO_LESS
  3149 00:167F: D4 15 8F 16                  dw      QUERY_BRANCH,POSTPONE_1
  3150 00:1683: 1B 16 1B 16                  dw      DO_LITERAL,DO_LITERAL
  3151 00:1687: 79 05                        dw      COMMA
  3152 00:1689: 79 05                        dw      COMMA
  3153 00:168B: B3 15 91 16                  dw      BRANCH,POSTPONE_2
  3154 00:168F: 79 05        POSTPONE_1:     dw      COMMA
  3155 00:1691: BF 0E        POSTPONE_2:     dw      EXIT
  3156                        
  3157                        ; RECURSE ( -- )
  3158                        
  3159 00:1693: 61 16 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:1697: 52 45 43 55 
       00:169B: 52 53 45 
  3160 00:169E: 20 45 14     RECURSE:        jsr     DO_COLON
  Wed Apr 20 2016 11:57                                                                                                    Page 63


  3161 00:16A1: 94 04                        dw      LATEST
  3162 00:16A3: B9 05                        dw      FETCH
  3163 00:16A5: 6A 11                        dw      NFA_TO_CFA
  3164 00:16A7: 79 05                        dw      COMMA
  3165 00:16A9: BF 0E                        dw      EXIT
  3166                        
  3167                        ; S"
  3168                        
  3169 00:16AB: 96 16 80                     LINK    IMMEDIATE
  3170 00:16AE: 02 53 22                     db      2,"S",'"'
  3171 00:16B1: 20 45 14     S_QUOTE:        jsr     DO_COLON
  3172 00:16B4: 1B 16 CA 16                  dw      DO_LITERAL,DO_S_QUOTE
  3173 00:16B8: 79 05                        dw      COMMA
  3174 00:16BA: 1B 16 22 00                  dw      DO_LITERAL,'"'
  3175 00:16BE: 8D 12                        dw      WORD
  3176 00:16C0: 0C 06                        dw      C_FETCH
  3177 00:16C2: 4F 09                        dw      ONE_PLUS
  3178 00:16C4: 47 06                        dw      ALIGNED
  3179 00:16C6: CC 05                        dw      ALLOT
  3180 00:16C8: BF 0E                        dw      EXIT
  3181                        
  3182                        ; (S") ( -- c-addr u )
  3183                        
  3184                        DO_S_QUOTE:
  3185 00:16CA: 20 45 14                     jsr     DO_COLON
  3186 00:16CD: A6 08                        dw      R_FROM
  3187 00:16CF: 9D 13                        dw      COUNT
  3188 00:16D1: BF 06                        dw      TWO_DUP
  3189 00:16D3: FF 08                        dw      PLUS
  3190 00:16D5: 47 06                        dw      ALIGNED
  3191 00:16D7: 6D 08                        dw      TO_R
  3192 00:16D9: BF 0E                        dw      EXIT
  3193                        
  3194                        ; THEN ( -- )
  3195                        
  3196 00:16DB: AE 16 80 04                  HEADER  4,"THEN",IMMEDIATE
       00:16DF: 54 48 45 4E 
  3197 00:16E3: 20 45 14     THEN:           jsr     DO_COLON
  3198 00:16E6: 24 06                        dw      HERE
  3199 00:16E8: FB 07                        dw      SWAP
  3200 00:16EA: 4B 05                        dw      STORE
  3201 00:16EC: BF 0E                        dw      EXIT
  3202                        
  3203                        ; UNTIL ( -- )
  3204                        
  3205 00:16EE: DE 16 80 05                  HEADER  5,"UNTIL",IMMEDIATE
       00:16F2: 55 4E 54 49 
       00:16F6: 4C 
  3206 00:16F7: 20 45 14     UNTIL:          jsr     DO_COLON
  3207 00:16FA: 1B 16 D4 15                  dw      DO_LITERAL,QUERY_BRANCH
  3208 00:16FE: 79 05                        dw      COMMA
  3209 00:1700: 79 05                        dw      COMMA
  3210 00:1702: BF 0E                        dw      EXIT
  3211                        
  3212                        ; USER
  3213                        
  3214 00:1704: F1 16 00 04                  HEADER  4,"USER",NORMAL
       00:1708: 55 53 45 52 
  Wed Apr 20 2016 11:57                                                                                                    Page 64


  3215 00:170C: 20 45 14     USER:           jsr     DO_COLON
  3216 00:170F: 84 0E                        dw      CREATE
  3217 00:1711: 1B 16 25 17                  dw      DO_LITERAL,DO_USER
  3218 00:1715: 6D 0E                        dw      BUILD
  3219 00:1717: 79 05                        dw      COMMA
  3220 00:1719: BF 0E                        dw      EXIT
  3221                        
  3222 00:171B: 07 17 00 06                  HEADER  6,"(USER)",NORMAL
       00:171F: 28 55 53 45 
       00:1723: 52 29 
  3223                        DO_USER:
  3224 00:1725: 7B                           tdc
  3225 00:1726: 3A                           dec     a                       ; Push on data stack
  3226 00:1727: 3A                           dec     a
  3227 00:1728: 5B                           tcd
  3228 00:1729: FA                           plx
  3229 00:172A: 18                           clc
  3230 00:172B: BD 01 00                     lda     !1,x
  3231 00:172E: 69 00 00                     adc     #USER_AREA
  3232 00:1731: 85 01                        sta     <1
  3233 00:1733: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1737: 00 00 
  3234                        
  3235                        ; VARIABLE ( <spaces>name -- )
  3236                        ;
  3237                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  3238                        ; definition for name with the execution semantics defined below. Reserve one
  3239                        ; cell of data space at an aligned address.
  3240                        
  3241 00:1739: 1E 17 00                     LINK    NORMAL
  3242 00:173C: 08 56 41 52                  db      8,"VARIABLE"
       00:1740: 49 41 42 4C 
       00:1744: 45 
  3243 00:1745: 20 45 14     VARIABLE:       jsr     DO_COLON
  3244 00:1748: 84 0E                        dw      CREATE
  3245 00:174A: 1B 16 5A 17                  dw      DO_LITERAL,DO_VARIABLE
  3246 00:174E: 6D 0E                        dw      BUILD
  3247 00:1750: 1B 16 01 00                  dw      DO_LITERAL,1
  3248 00:1754: 69 06                        dw      CELLS
  3249 00:1756: CC 05                        dw      ALLOT
  3250 00:1758: BF 0E                        dw      EXIT
  3251                        
  3252                        DO_VARIABLE:
  3253 00:175A: 7B                           tdc
  3254 00:175B: 3A                           dec     a
  3255 00:175C: 3A                           dec     a
  3256 00:175D: 5B                           tcd
  3257 00:175E: 68                           pla
  3258 00:175F: 1A                           inc     a
  3259 00:1760: 85 01                        sta     <1
  3260 00:1762: BB C8 C8 7C                  CONTINUE
       00:1766: 00 00 
  3261                        
  3262                        ; WORDS ( -- )
  3263                        ;
  3264                        ;   LATEST @ BEGIN
  3265                        ;       DUP COUNT TYPE SPACE
  3266                        ;       NFA>LFA @
  Wed Apr 20 2016 11:57                                                                                                    Page 65


  3267                        ;   DUP 0= UNTIL
  3268                        ;   DROP ;
  3269                        
  3270 00:1768: 3C 17 00 05                  HEADER  5,"WORDS",NORMAL
       00:176C: 57 4F 52 44 
       00:1770: 53 
  3271 00:1771: 20 45 14                     jsr     DO_COLON
  3272 00:1774: 94 04                        dw      LATEST
  3273 00:1776: B9 05                        dw      FETCH
  3274 00:1778: 85 07        WORDS_1:        dw      DUP
  3275 00:177A: 9D 13                        dw      COUNT
  3276 00:177C: 47 18                        dw      TYPE
  3277 00:177E: 15 18                        dw      SPACE
  3278 00:1780: 73 11                        dw      NFA_TO_LFA
  3279 00:1782: B9 05                        dw      FETCH
  3280 00:1784: 85 07                        dw      DUP
  3281 00:1786: DF 0C                        dw      ZERO_EQUAL
  3282 00:1788: D4 15 78 17                  dw      QUERY_BRANCH,WORDS_1
  3283 00:178C: 74 07                        dw      DROP
  3284 00:178E: BF 0E                        dw      EXIT
  3285                        
  3286                        ; [
  3287                        ;
  3288                        ; In this implementation it is defined as
  3289                        ;
  3290                        ;   0 STATE !
  3291                        
  3292 00:1790: 6B 17 80 01                  HEADER  1,"[",IMMEDIATE
       00:1794: 5B 
  3293 00:1795: 20 45 14     LEFT_BRACKET:   jsr     DO_COLON
  3294 00:1798: CE 04                        dw      ZERO
  3295 00:179A: B8 04                        dw      STATE
  3296 00:179C: 4B 05                        dw      STORE
  3297 00:179E: BF 0E                        dw      EXIT
  3298                        
  3299                        ; \ ( -- )
  3300                        ;
  3301                        ; Parse and discard the remainder of the parse area. \ is an immediate word.
  3302                        ;
  3303                        ; In this implementation it is defined as
  3304                        ;
  3305                        ;   1 WORD DROP
  3306                        
  3307 00:17A0: 93 17 80 01                  HEADER  1,"\",IMMEDIATE
       00:17A4: 5C 
  3308 00:17A5: 20 45 14     BACKSLASH:      jsr     DO_COLON
  3309 00:17A8: 1B 16 01 00                  dw      DO_LITERAL,1
  3310 00:17AC: 8D 12                        dw      WORD
  3311 00:17AE: 74 07                        dw      DROP
  3312 00:17B0: BF 0E                        dw      EXIT
  3313                        
  3314                        ; ]
  3315                        ;
  3316                        ; In this implementation it is defined as
  3317                        ;
  3318                        ;   -1 STATE !
  3319                        
  3320 00:17B2: A3 17 00 01                  HEADER  1,"]",NORMAL
  Wed Apr 20 2016 11:57                                                                                                    Page 66


       00:17B6: 5D 
  3321 00:17B7: 20 45 14     RIGHT_BRACKET:  jsr     DO_COLON
  3322 00:17BA: 1B 16 FF FF                  dw      DO_LITERAL,-1
  3323 00:17BE: B8 04                        dw      STATE
  3324 00:17C0: 4B 05                        dw      STORE
  3325 00:17C2: BF 0E                        dw      EXIT
  3326                        
  3327                        ;===============================================================================
  3328                        ; I/O Operations
  3329                        ;-------------------------------------------------------------------------------
  3330                        
  3331                        ; CR ( -- )
  3332                        ;
  3333                        ; Cause subsequent output to appear at the beginning of the next line.
  3334                        ;
  3335                        ; In this implementation it is defined as
  3336                        ;
  3337                        ;   13 EMIT 10 EMIT
  3338                        
  3339 00:17C4: B5 17 00 02                  HEADER  2,"CR",NORMAL
       00:17C8: 43 52 
  3340 00:17CA: 20 45 14     CR:             jsr     DO_COLON
  3341 00:17CD: 1B 16 0D 00                  dw      DO_LITERAL,13
  3342 00:17D1: E3 17                        dw      EMIT
  3343 00:17D3: 1B 16 0A 00                  dw      DO_LITERAL,10
  3344 00:17D7: E3 17                        dw      EMIT
  3345 00:17D9: BF 0E                        dw      EXIT
  3346                        
  3347                        ; EMIT ( x -- )
  3348                        ;
  3349                        ; If x is a graphic character in the implementation-defined character set,
  3350                        ; display x. The effect of EMIT for all other values of x is implementation
  3351                        ; -defined.
  3352                        
  3353 00:17DB: C7 17 00 04                  HEADER  4,"EMIT",NORMAL
       00:17DF: 45 4D 49 54 
  3354                                        extern  UartTx
  3355                        EMIT:
  3356 00:17E3: A5 01                        lda     <1                      ; Fetch character from stack
  3357 00:17E5: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  3358 00:17E8: 7B                           tdc
  3359 00:17E9: 1A                           inc     a                       ; Drop the character
  3360 00:17EA: 1A                           inc     a
  3361 00:17EB: 5B                           tcd
  3362 00:17EC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:17F0: 00 00 
  3363                        
  3364                        ; KEY ( -- char )
  3365                        ;
  3366                        ; Receive one character char, a member of the implementation-defined character
  3367                        ; set. Keyboard events that do not correspond to such characters are discarded
  3368                        ; until a valid character is received, and those events are subsequently
  3369                        ; unavailable.
  3370                        ;
  3371                        ; All standard characters can be received. Characters received by KEY are not
  3372                        ; displayed.
  3373                        
  3374 00:17F2: DE 17 00 03                  HEADER  3,"KEY",NORMAL
  Wed Apr 20 2016 11:57                                                                                                    Page 67


       00:17F6: 4B 45 59 
  3375                                        extern  UartRx
  3376                        KEY:
  3377 00:17F9: 20 xx xx                     jsr     UartRx                  ; Receive a character
  3378 00:17FC: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  3379 00:17FF: AA                           tax
  3380 00:1800: 7B                           tdc
  3381 00:1801: 3A                           dec     a                       ; And push to stack
  3382 00:1802: 3A                           dec     a
  3383 00:1803: 5B                           tcd
  3384 00:1804: 86 01                        stx     <1
  3385 00:1806: BB C8 C8 7C                  CONTINUE                        ; Done
       00:180A: 00 00 
  3386                        
  3387                        ; SPACE ( -- )
  3388                        ;
  3389                        ; Display one space.
  3390                        ;
  3391                        ; In this implementation it is defined as
  3392                        ;
  3393                        ;   BL EMIT
  3394                        
  3395 00:180C: F5 17 00 05                  HEADER  5,"SPACE",NORMAL
       00:1810: 53 50 41 43 
       00:1814: 45 
  3396 00:1815: 20 45 14     SPACE:          jsr     DO_COLON
  3397 00:1818: E0 04                        dw      BL
  3398 00:181A: E3 17                        dw      EMIT
  3399 00:181C: BF 0E                        dw      EXIT
  3400                        
  3401                        ; SPACES ( n -- )
  3402                        ;
  3403                        ; If n is greater than zero, display n spaces.
  3404                        ;
  3405                        ; In this implementation it is defined as
  3406                        ;
  3407                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  3408                        
  3409 00:181E: 0F 18 00 06                  HEADER  6,"SPACES",NORMAL
       00:1822: 53 50 41 43 
       00:1826: 45 53 
  3410 00:1828: 20 45 14     SPACES:         jsr     DO_COLON
  3411 00:182B: 85 07        SPACES_1:       dw      DUP
  3412 00:182D: F3 0C                        dw      ZERO_GREATER
  3413 00:182F: D4 15 3B 18                  dw      QUERY_BRANCH,SPACES_2
  3414 00:1833: 15 18                        dw      SPACE
  3415 00:1835: 5D 09                        dw      ONE_MINUS
  3416 00:1837: B3 15 2B 18                  dw      BRANCH,SPACES_1
  3417 00:183B: 74 07        SPACES_2:       dw      DROP
  3418 00:183D: BF 0E                        dw      EXIT
  3419                        
  3420                        ; TYPE ( c-addr u -- )
  3421                        ;
  3422                        ; If u is greater than zero, display the character string specified by c-addr
  3423                        ; and u.
  3424                        ;
  3425                        ; In this implementation it is defined as
  3426                        ;
  Wed Apr 20 2016 11:57                                                                                                    Page 68


  3427                        ;   ?DUP IF
  3428                        ;     OVER + SWAP DO I C@ EMIT LOOP
  3429                        ;   ELSE DROP THEN
  3430                        
  3431 00:183F: 21 18 00 04                  HEADER  4,"TYPE",NORMAL
       00:1843: 54 59 50 45 
  3432 00:1847: 20 45 14     TYPE:           jsr     DO_COLON
  3433 00:184A: 48 07                        dw      QUERY_DUP
  3434 00:184C: D4 15 66 18                  dw      QUERY_BRANCH,TYPE_2
  3435 00:1850: A8 07                        dw      OVER
  3436 00:1852: FF 08                        dw      PLUS
  3437 00:1854: FB 07                        dw      SWAP
  3438 00:1856: 82 15                        dw      DO_DO
  3439 00:1858: 7F 08        TYPE_1:         dw      I
  3440 00:185A: 0C 06                        dw      C_FETCH
  3441 00:185C: E3 17                        dw      EMIT
  3442 00:185E: 41 16 58 18                  dw      DO_LOOP,TYPE_1
  3443 00:1862: B3 15 68 18                  dw      BRANCH,TYPE_3
  3444 00:1866: 74 07        TYPE_2          dw      DROP
  3445 00:1868: BF 0E        TYPE_3          dw      EXIT
  3446                        
  3447                        ;===============================================================================
  3448                        ; Formatted Output
  3449                        ;-------------------------------------------------------------------------------
  3450                        
  3451                        ; # ( ud1 -- ud2 )
  3452                        ;
  3453                        ; Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n.
  3454                        ; (n is the least-significant digit of ud1.) Convert n to external form and add
  3455                        ; the resulting character to the beginning of the pictured numeric output string.
  3456                        ; An ambiguous condition exists if # executes outside of a <# #> delimited
  3457                        ; number conversion.
  3458                        ;
  3459                        ;       BASE @ >R 0 R@ UM/MOD ROT ROT R> UM/MOD ROT ROT DUP 9 > 7 AND + 30 + HOLD
  3460                        
  3461 00:186A: 42 18 00 01                  HEADER  1,"#",NORMAL
       00:186E: 23 
  3462 00:186F: 20 45 14     HASH:           jsr     DO_COLON
  3463 00:1872: 64 04                        dw      BASE
  3464 00:1874: B9 05                        dw      FETCH
  3465 00:1876: 6D 08                        dw      TO_R
  3466 00:1878: CE 04                        dw      ZERO
  3467 00:187A: B9 08                        dw      R_FETCH
  3468 00:187C: 81 0C                        dw      UM_SLASH_MOD
  3469 00:187E: E1 07                        dw      ROT
  3470 00:1880: E1 07                        dw      ROT
  3471 00:1882: A6 08                        dw      R_FROM
  3472 00:1884: 81 0C                        dw      UM_SLASH_MOD
  3473 00:1886: E1 07                        dw      ROT
  3474 00:1888: E1 07                        dw      ROT
  3475 00:188A: 85 07                        dw      DUP
  3476 00:188C: 1B 16 09 00                  dw      DO_LITERAL,9
  3477 00:1890: 49 0D                        dw      GREATER
  3478 00:1892: 1B 16 07 00                  dw      DO_LITERAL,7
  3479 00:1896: 96 0D                        dw      AND
  3480 00:1898: FF 08                        dw      PLUS
  3481 00:189A: 1B 16 30 00                  dw      DO_LITERAL,'0'
  3482 00:189E: FF 08                        dw      PLUS
  Wed Apr 20 2016 11:57                                                                                                    Page 69


  3483 00:18A0: 09 19                        dw      HOLD
  3484 00:18A2: BF 0E                        dw      EXIT
  3485                        
  3486                        ; #> ( xd -- c-addr u )
  3487                        ;
  3488                        ; Drop xd. Make the pictured numeric output string available as a character
  3489                        ; string. c-addr and u specify the resulting character string. A program may
  3490                        ; replace characters within the string.
  3491                        ;
  3492                        ;       2DROP HP @ PAD OVER -
  3493                        
  3494 00:18A4: 6D 18 00 02                  HEADER  2,"#>",NORMAL
       00:18A8: 23 3E 
  3495 00:18AA: 20 45 14     HASH_GREATER:   jsr     DO_COLON
  3496 00:18AD: AB 06                        dw      TWO_DROP
  3497 00:18AF: 85 04                        dw      HP
  3498 00:18B1: B9 05                        dw      FETCH
  3499 00:18B3: 23 19                        dw      PAD
  3500 00:18B5: A8 07                        dw      OVER
  3501 00:18B7: 15 09                        dw      MINUS
  3502 00:18B9: BF 0E                        dw      EXIT
  3503                        
  3504                        ; #S ( ud1 -- ud2 )
  3505                        ;
  3506                        ; Convert one digit of ud1 according to the rule for #. Continue conversion
  3507                        ; until the quotient is zero. ud2 is zero. An ambiguous condition exists if #S
  3508                        ; executes outside of a <# #> delimited number conversion.
  3509                        ;
  3510                        ;       BEGIN # 2DUP OR 0= UNTIL
  3511                        
  3512 00:18BB: A7 18 00 02                  HEADER  2,"#S",NORMAL
       00:18BF: 23 53 
  3513 00:18C1: 20 45 14     HASH_S:         jsr     DO_COLON
  3514 00:18C4: 6F 18        HASH_S_1:       dw      HASH
  3515 00:18C6: BF 06                        dw      TWO_DUP
  3516 00:18C8: EF 0D                        dw      OR
  3517 00:18CA: DF 0C                        dw      ZERO_EQUAL
  3518 00:18CC: D4 15 C4 18                  dw      QUERY_BRANCH,HASH_S_1
  3519 00:18D0: BF 0E                        dw      EXIT
  3520                        
  3521                        ; . ( n -- )
  3522                        ;
  3523                        ; Display n in free field format.
  3524                        ;
  3525                        ;       <# DUP ABS 0 #S ROT SIGN #> TYPE SPACE
  3526                        
  3527 00:18D2: BE 18 00 01                  HEADER  1,".",NORMAL
       00:18D6: 2E 
  3528 00:18D7: 20 45 14     DOT:            jsr     DO_COLON
  3529 00:18DA: F6 18                        dw      LESS_HASH
  3530 00:18DC: 85 07                        dw      DUP
  3531 00:18DE: 98 09                        dw      ABS
  3532 00:18E0: CE 04                        dw      ZERO
  3533 00:18E2: C1 18                        dw      HASH_S
  3534 00:18E4: E1 07                        dw      ROT
  3535 00:18E6: 30 19                        dw      SIGN
  3536 00:18E8: AA 18                        dw      HASH_GREATER
  3537 00:18EA: 47 18                        dw      TYPE
  Wed Apr 20 2016 11:57                                                                                                    Page 70


  3538 00:18EC: 15 18                        dw      SPACE
  3539 00:18EE: BF 0E                        dw      EXIT
  3540                        
  3541                        ; <# ( -- )
  3542                        ;
  3543                        ; Initialize the pictured numeric output conversion process.
  3544                        ;
  3545                        ;       PAD HP !
  3546                        
  3547 00:18F0: D5 18 00 02                  HEADER  2,"<#",NORMAL
       00:18F4: 3C 23 
  3548 00:18F6: 20 45 14     LESS_HASH:      jsr     DO_COLON
  3549 00:18F9: 23 19                        dw      PAD
  3550 00:18FB: 85 04                        dw      HP
  3551 00:18FD: 4B 05                        dw      STORE
  3552 00:18FF: BF 0E                        dw      EXIT
  3553                        
  3554                        ; HOLD ( char -- )
  3555                        
  3556                        ; Add char to the beginning of the pictured numeric output string. An
  3557                        ; ambiguous condition exists if HOLD executes outside of a <# #> delimited
  3558                        ; number conversion.
  3559                        ;
  3560                        ;       -1 HP +!  HP @ C!
  3561                        
  3562 00:1901: F3 18 00 04                  HEADER  4,"HOLD",NORMAL
       00:1905: 48 4F 4C 44 
  3563 00:1909: 20 45 14     HOLD:           jsr     DO_COLON
  3564 00:190C: 1B 16 FF FF                  dw      DO_LITERAL,-1
  3565 00:1910: 85 04                        dw      HP
  3566 00:1912: 61 05                        dw      PLUS_STORE
  3567 00:1914: 85 04                        dw      HP
  3568 00:1916: B9 05                        dw      FETCH
  3569 00:1918: DB 05                        dw      C_STORE
  3570 00:191A: BF 0E                        dw      EXIT
  3571                        
  3572                        ; PAD ( -- c-addr )
  3573                        ;
  3574                        ; c-addr is the address of a transient region that can be used to hold data
  3575                        ; for intermediate processing.
  3576                        
  3577 00:191C: 04 19 00 03                  HEADER  3,"PAD",NORMAL
       00:1920: 50 41 44 
  3578 00:1923: 20 5F 15     PAD:            jsr     DO_CONSTANT
  3579 00:1926: B0 02                        dw      PAD_AREA
  3580                        
  3581                        ; SIGN ( n -- )
  3582                        ;
  3583                        ; If n is negative, add a minus sign to the beginning of the pictured numeric
  3584                        ; output string. An ambiguous condition exists if SIGN executes outside of a
  3585                        ; <# #> delimited number conversion.
  3586                        ;
  3587                        ;       [ HEX ] 0< IF 2D HOLD THEN
  3588                        
  3589 00:1928: 1F 19 00 04                  HEADER  4,"SIGN",NORMAL
       00:192C: 53 49 47 4E 
  3590 00:1930: 20 45 14     SIGN:           jsr     DO_COLON
  3591 00:1933: B6 0C                        dw      ZERO_LESS
  Wed Apr 20 2016 11:57                                                                                                    Page 71


  3592 00:1935: D4 15 3F 19                  dw      QUERY_BRANCH,SIGN_1
  3593 00:1939: 1B 16 2D 00                  dw      DO_LITERAL,'-'
  3594 00:193D: 09 19                        dw      HOLD
  3595 00:193F: BF 0E        SIGN_1:         dw      EXIT
  3596                        
  3597                        ; U. ( u -- )
  3598                        ;
  3599                        ; Display u in free field format.
  3600                        ;
  3601                        ;  <# 0 #S #> TYPE SPACE
  3602                        
  3603 00:1941: 2B 19 00 02                  HEADER  2,"U.",NORMAL
       00:1945: 55 2E 
  3604 00:1947: 20 45 14     U_DOT:          jsr     DO_COLON
  3605 00:194A: F6 18                        dw      LESS_HASH
  3606 00:194C: CE 04                        dw      ZERO
  3607 00:194E: C1 18                        dw      HASH_S
  3608 00:1950: AA 18                        dw      HASH_GREATER
  3609 00:1952: 47 18                        dw      TYPE
  3610 00:1954: 15 18                        dw      SPACE
  3611 00:1956: BF 0E                        dw      EXIT
  3612                        
  3613                        ;===============================================================================
  3614                        ; Programming Tools
  3615                        ;-------------------------------------------------------------------------------
  3616                        
  3617                        ; .NYBBLE ( n -- )
  3618                        ;
  3619                        ; Print the least significant nybble of the top value on the stack in hex.
  3620                        
  3621                        ;               HEADER  7,".NYBBLE",NORMAL
  3622                        DOT_NYBBLE:
  3623 00:1958: A5 01                        lda     <1
  3624 00:195A: 29 0F 00                     and     #$000f
  3625 00:195D: 09 30 00                     ora     #$0030
  3626 00:1960: C9 3A 00                     cmp     #$003a
  3627 00:1963: 90 03                        bcc     $+5
  3628 00:1965: 69 06 00                     adc     #$0006
  3629 00:1968: 20 xx xx                     jsr     UartTx
  3630 00:196B: 4C 74 07                     jmp     DROP
  3631                        
  3632                        ; .BYTE ( n -- )
  3633                        ;
  3634                        ; Print least significant byte of top value on the stack in hex followed by
  3635                        ; a space.
  3636                        
  3637 00:196E: 44 19 00 05                  HEADER  5,".BYTE",NORMAL
       00:1972: 2E 42 59 54 
       00:1976: 45 
  3638 00:1977: 20 45 14     DOT_BYTE:       jsr     DO_COLON
  3639 00:197A: 85 07                        dw      DUP
  3640 00:197C: 1B 16 04 00                  dw      DO_LITERAL,4
  3641 00:1980: 09 0E                        dw      RSHIFT
  3642 00:1982: 58 19                        dw      DOT_NYBBLE
  3643 00:1984: 58 19                        dw      DOT_NYBBLE
  3644 00:1986: 15 18                        dw      SPACE
  3645 00:1988: BF 0E                        dw      EXIT
  3646                        
  Wed Apr 20 2016 11:57                                                                                                    Page 72


  3647                        ; .WORD ( n -- )
  3648                        ;
  3649                        ; Print the top value on the stack in hex followed by a space.
  3650                        
  3651 00:198A: 71 19 00 05                  HEADER  5,".WORD",NORMAL
       00:198E: 2E 57 4F 52 
       00:1992: 44 
  3652 00:1993: 20 45 14     DOT_WORD:       jsr     DO_COLON
  3653 00:1996: 85 07                        dw      DUP
  3654 00:1998: 1B 16 0C 00                  dw      DO_LITERAL,12
  3655 00:199C: 09 0E                        dw      RSHIFT
  3656 00:199E: 58 19                        dw      DOT_NYBBLE
  3657 00:19A0: 85 07                        dw      DUP
  3658 00:19A2: 1B 16 08 00                  dw      DO_LITERAL,8
  3659 00:19A6: 09 0E                        dw      RSHIFT
  3660 00:19A8: 58 19                        dw      DOT_NYBBLE
  3661 00:19AA: 85 07                        dw      DUP
  3662 00:19AC: 1B 16 04 00                  dw      DO_LITERAL,4
  3663 00:19B0: 09 0E                        dw      RSHIFT
  3664 00:19B2: 58 19                        dw      DOT_NYBBLE
  3665 00:19B4: 58 19                        dw      DOT_NYBBLE
  3666 00:19B6: 15 18                        dw      SPACE
  3667 00:19B8: BF 0E                        dw      EXIT
  3668                        
  3669                        ; .DP
  3670                        
  3671 00:19BA: 8D 19 00 03                  HEADER  3,".DP",NORMAL
       00:19BE: 2E 44 50 
  3672 00:19C1: 20 45 14                     jsr     DO_COLON
  3673 00:19C4: 14 1A                        dw      AT_DP
  3674 00:19C6: 93 19                        dw      DOT_WORD
  3675 00:19C8: BF 0E                        dw      EXIT
  3676                        
  3677 00:19CA: BD 19 00 03                  HEADER  3,".RP",NORMAL
       00:19CE: 2E 52 50 
  3678 00:19D1: 20 45 14                     jsr     DO_COLON
  3679 00:19D4: 29 1A                        dw      AT_RP
  3680 00:19D6: 93 19                        dw      DOT_WORD
  3681 00:19D8: BF 0E                        dw      EXIT
  3682                        
  3683                        ; .S ( -- )
  3684                        ;
  3685                        ; Copy and display the values currently on the data stack. The format of the
  3686                        ; display is implementation-dependent.
  3687                        
  3688 00:19DA: CD 19 00 02                  HEADER  2,".S",NORMAL
       00:19DE: 2E 53 
  3689 00:19E0: 20 45 14                     jsr     DO_COLON
  3690 00:19E3: 14 1A                        dw      AT_DP
  3691 00:19E5: 4F 09                        dw      ONE_PLUS
  3692 00:19E7: 1B 16 80 01                  dw      DO_LITERAL,DSTACK_END
  3693 00:19EB: FB 07                        dw      SWAP
  3694 00:19ED: 82 15                        dw      DO_DO
  3695 00:19EF: 7F 08        DOT_S_1:        dw      I
  3696 00:19F1: B9 05                        dw      FETCH
  3697 00:19F3: 93 19                        dw      DOT_WORD
  3698 00:19F5: 1B 16 02 00                  dw      DO_LITERAL,2
  3699 00:19F9: 0D 14                        dw      DO_PLUS_LOOP
  Wed Apr 20 2016 11:57                                                                                                    Page 73


  3700 00:19FB: EF 19                        dw      DOT_S_1
  3701 00:19FD: BF 0E                        dw      EXIT
  3702                        
  3703                        ; ? ( a-addr -- )
  3704                        ;
  3705                        ; Display the value stored at a-addr.
  3706                        
  3707 00:19FF: DD 19 00 01                  HEADER  1,"?",NORMAL
       00:1A03: 3F 
  3708 00:1A04: 20 45 14                     jsr     DO_COLON
  3709 00:1A07: B9 05                        dw      FETCH
  3710 00:1A09: 93 19                        dw      DOT_WORD
  3711 00:1A0B: BF 0E                        dw      EXIT
  3712                        
  3713 00:1A0D: 02 1A 00 03                  HEADER  3,"@DP",NORMAL
       00:1A11: 40 44 50 
  3714                        AT_DP:
  3715 00:1A14: 0B                           phd
  3716 00:1A15: 7B                           tdc
  3717 00:1A16: 3A                           dec     a
  3718 00:1A17: 3A                           dec     a
  3719 00:1A18: 5B                           tcd
  3720 00:1A19: 68                           pla
  3721 00:1A1A: 85 01                        sta     <1
  3722 00:1A1C: BB C8 C8 7C                  CONTINUE
       00:1A20: 00 00 
  3723                        
  3724 00:1A22: 10 1A 00 03                  HEADER  3,"@RP",NORMAL
       00:1A26: 40 52 50 
  3725                        AT_RP:
  3726 00:1A29: 7B                           tdc
  3727 00:1A2A: 3A                           dec     a
  3728 00:1A2B: 3A                           dec     a
  3729 00:1A2C: 5B                           tcd
  3730 00:1A2D: BA                           tsx
  3731 00:1A2E: 86 01                        stx     <1
  3732 00:1A30: BB C8 C8 7C                  CONTINUE
       00:1A34: 00 00 
  3733                        
  3734                        
  3735                        ;-------------------------------------------------------------------------------
  3736                        
  3737                                        include "device.asm"
     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _ ____   __  ____
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )___ \ / /_| ___|
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/  __) | '_ \___ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |    / __/| (_) |__) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|   |_____|\___/____/
     7                        ;
     8                        ; Device Specific Words for the W65C265SXB
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
  Wed Apr 20 2016 11:57                                                                                                    Page 74


    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ;------------------------------------------------------------------------------
    23                        
    24                        ; (TITLE) - ( -- )
    25                        ;
    26                        
    27                        ;               HEADER  7,"(TITLE)",NORMAL
    28 00:1A36: 20 45 14     DO_TITLE:       jsr     DO_COLON
    29 00:1A39: CA 16                        dw      DO_S_QUOTE
    30 00:1A3B: 1C 57 36 35                  db      28,"W65C265SXB ANS-Forth [16.04]"
       00:1A3F: 43 32 36 35 
       00:1A43: 53 58 42 20 
       00:1A47: 41 4E 53 2D 
       00:1A4B: 46 6F 72 74 
       00:1A4F: 68 20 5B 31 
       00:1A53: 36 2E 30 34 
       00:1A57: 5D 
    31 00:1A58: BF 0E                        dw      EXIT
    32                        
    33                        ; BYE ( -- )
    34                        ;
    35                        ; Return control to the host operating system, if any.
    36                        
    37 00:1A5A: 25 1A 00 03                  HEADER  3,"BYE",NORMAL
       00:1A5E: 42 59 45 
    38                        BYE:
    39 00:1A61: 78                           sei
    40 00:1A62: D8                           cld
    41 00:1A63: 38 FB                        emulate
    42 00:1A65: 6C FC FF                     jmp     ($fffc)         ; Reset the processor
    43                        
    44                        ; UNUSED ( -- u )
    45                        ;
    46                        ; u is the amount of space remaining in the region addressed by HERE , in
    47                        ; address units.
    48                        
    49 00:1A68: 5D 1A 00 06                  HEADER  6,"UNUSED",NORMAL
       00:1A6C: 55 4E 55 53 
       00:1A70: 45 44 
    50 00:1A72: 20 45 14     UNUSED:         jsr     DO_COLON
    51 00:1A75: 1B 16 00 80                  dw      DO_LITERAL,$8000
    52 00:1A79: 24 06                        dw      HERE
    53 00:1A7B: 15 09                        dw      MINUS
    54 00:1A7D: BF 0E                        dw      EXIT
    55                        
    56                        
    57                        ;-------------------------------------------------------------------------------
    58                        
    59                        
  3738                        
  3739                                        TRAILER
  3740                        NEXT_WORD:
  3741                        
  Wed Apr 20 2016 11:57                                                                                                    Page 75


  3742                                        end


      Lines assembled: 5509
      Errors: 0
